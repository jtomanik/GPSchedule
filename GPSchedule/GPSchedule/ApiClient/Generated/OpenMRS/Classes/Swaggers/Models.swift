// Models.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation

protocol JSONEncodable {
    func encodeToJSON() -> Any
}

public enum ErrorResponse : Error {
    case HttpError(statusCode: Int, data: Data?, error: Error)
    case DecodeError(response: Data?, decodeError: DecodeError)
}

open class Response<T> {
    open let statusCode: Int
    open let header: [String: String]
    open let body: T?

    public init(statusCode: Int, header: [String: String], body: T?) {
        self.statusCode = statusCode
        self.header = header
        self.body = body
    }

    public convenience init(response: HTTPURLResponse, body: T?) {
        let rawHeader = response.allHeaderFields
        var header = [String:String]()
        for case let (key, value) as (String, String) in rawHeader {
            header[key] = value
        }
        self.init(statusCode: response.statusCode, header: header, body: body)
    }
}

public enum Decoded<ValueType> {
    case success(ValueType)
    case failure(DecodeError)
}

public extension Decoded {
    var value: ValueType? {
        switch self {
        case let .success(value):
            return value
        case .failure:
            return nil
        }
    }
}

public enum DecodeError {
    case typeMismatch(expected: String, actual: String)
    case missingKey(key: String)
    case parseError(message: String)
}

private var once = Int()
public class Decoders {
    static fileprivate var decoders = Dictionary<String, ((AnyObject, AnyObject?) -> AnyObject)>()

    static open func addDecoder<T>(clazz: T.Type, decoder: @escaping ((AnyObject, AnyObject?) -> Decoded<T>)) {
        let key = "\(T.self)"
        decoders[key] = { decoder($0, $1) as AnyObject }
    }

    static open func decode<T>(clazz: T.Type, discriminator: String, source: AnyObject) -> Decoded<T> {
        let key = discriminator
        if let decoder = decoders[key], let value = decoder(source, nil) as? Decoded<T> {
            return value
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static open func decode<T>(clazz: [T].Type, source: AnyObject) -> Decoded<[T]> {
        if let sourceArray = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in sourceArray {
                switch Decoders.decode(clazz: T.self, source: sourceValue, instance: nil) {
                case let .success(value):
                    values.append(value)
                case let .failure(error):
                    return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static open func decode<T>(clazz: T.Type, source: AnyObject) -> Decoded<T> {
        switch Decoders.decode(clazz: T.self, source: source, instance: nil) {
    	    case let .success(value):
                return .success(value)
            case let .failure(error):
                return .failure(error)
        }
    }

    static open func decode<T: RawRepresentable>(clazz: T.Type, source: AnyObject) -> Decoded<T> {
        if let value = source as? T.RawValue {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "\(T.RawValue.self) matching a case from the enumeration \(T.self)", actual: String(describing: type(of: source))))
        }
    }

    public static func decode<T, Key: Hashable>(clazz: [Key:T].Type, source: AnyObject) -> Decoded<[Key:T]> {
        if let sourceDictionary = source as? [Key: AnyObject] {
            var dictionary = [Key:T]()
            for (key, value) in sourceDictionary {
                switch Decoders.decode(clazz: T.self, source: value, instance: nil) {
                case let .success(value):
                    dictionary[key] = value
                case let .failure(error):
                    return .failure(error)
                }
            }
            return .success(dictionary)
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    public static func decodeOptional<T: RawRepresentable>(clazz: T.Type, source: AnyObject?) -> Decoded<T?> {
        guard !(source is NSNull), source != nil else { return .success(nil) }
        if let value = source as? T.RawValue {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "\(T.RawValue.self) matching a case from the enumeration \(T.self)", actual: String(describing: type(of: source))))
        }
    }

    public static func decode<T>(clazz: T.Type, source: AnyObject, instance: AnyObject?) -> Decoded<T> {
        initialize()
        if let sourceNumber = source as? NSNumber, let value = sourceNumber.int32Value as? T, T.self is Int32.Type {
            return .success(value)
        }
        if let sourceNumber = source as? NSNumber, let value = sourceNumber.int32Value as? T, T.self is Int64.Type {
     	    return .success(value)
        }
        if let intermediate = source as? String, let value = UUID(uuidString: intermediate) as? T, source is String, T.self is UUID.Type {
            return .success(value)
        }
        if let value = source as? T {
            return .success(value)
        }
        if let intermediate = source as? String, let value = Data(base64Encoded: intermediate) as? T {
            return .success(value)
        }
        let key = "\(T.self)"
        if let decoder = decoders[key], let value = decoder(source, instance) as? Decoded<T> {
           return value
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    //Convert a Decoded so that its value is optional. DO WE STILL NEED THIS?
    static func toOptional<T>(decoded: Decoded<T>) -> Decoded<T?> {
        return .success(decoded.value)
    }

    static func decodeOptional<T>(clazz: T.Type, source: AnyObject?) -> Decoded<T?> {
        if let source = source, !(source is NSNull) {
            switch Decoders.decode(clazz: clazz, source: source, instance: nil) {
            case let .success(value): return .success(value)
            case let .failure(error): return .failure(error)
            }
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T>(clazz: [T].Type, source: AnyObject?) -> Decoded<[T]?> where T: RawRepresentable {
        if let source = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in source {
                switch Decoders.decodeOptional(clazz: T.self, source: sourceValue) {
                case let .success(value): if let value = value { values.append(value) }
                case let .failure(error): return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T>(clazz: [T].Type, source: AnyObject?) -> Decoded<[T]?> {
        if let source = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in source {
                switch Decoders.decode(clazz: T.self, source: sourceValue, instance: nil) {
                case let .success(value): values.append(value)
                case let .failure(error): return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T, Key: Hashable>(clazz: [Key:T].Type, source: AnyObject?) -> Decoded<[Key:T]?> {
        if let sourceDictionary = source as? [Key: AnyObject] {
            var dictionary = [Key:T]()
            for (key, value) in sourceDictionary {
                switch Decoders.decode(clazz: T.self, source: value, instance: nil) {
                case let .success(value): dictionary[key] = value
                case let .failure(error): return .failure(error)
                }
            }
            return .success(dictionary)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T: RawRepresentable, U: AnyObject>(clazz: T, source: AnyObject) -> Decoded<T?> where T.RawValue == U {
        if let value = source as? U {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "String", actual: String(describing: type(of: source))))
        }
    }


    private static var __once: () = {
        let formatters = [
            "yyyy-MM-dd",
            "yyyy-MM-dd'T'HH:mm:ssZZZZZ",
            "yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ",
            "yyyy-MM-dd'T'HH:mm:ss'Z'",
            "yyyy-MM-dd'T'HH:mm:ss.SSS",
            "yyyy-MM-dd HH:mm:ss"
        ].map { (format: String) -> DateFormatter in
            let formatter = DateFormatter()
            formatter.locale = Locale(identifier: "en_US_POSIX")
            formatter.dateFormat = format
            return formatter
        }
        // Decoder for Date
        Decoders.addDecoder(clazz: Date.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Date> in
           if let sourceString = source as? String {
                for formatter in formatters {
                    if let date = formatter.date(from: sourceString) {
                        return .success(date)
                    }
                }
            }
            if let sourceInt = source as? Int {
                // treat as a java date
                return .success(Date(timeIntervalSince1970: Double(sourceInt / 1000) ))
            }
            if source is String || source is Int {
                return .failure(.parseError(message: "Could not decode date"))
            } else {
                return .failure(.typeMismatch(expected: "String or Int", actual: "\(source)"))
            }
        }

        // Decoder for ISOFullDate
        Decoders.addDecoder(clazz: ISOFullDate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ISOFullDate> in
            if let string = source as? String,
               let isoDate = ISOFullDate.from(string: string) {
                return .success(isoDate)
            } else {
            	return .failure(.typeMismatch(expected: "ISO date", actual: "\(source)"))
            }
        }

        // Decoder for [AppGet]
        Decoders.addDecoder(clazz: [AppGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppGet]> in
            return Decoders.decode(clazz: [AppGet].self, source: source)
        }

        // Decoder for AppGet
        Decoders.addDecoder(clazz: AppGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = AppGet()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppGet", actual: "\(source)"))
            }
        }
        // Decoder for [AppGetFull]
        Decoders.addDecoder(clazz: [AppGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppGetFull]> in
            return Decoders.decode(clazz: [AppGetFull].self, source: source)
        }

        // Decoder for AppGetFull
        Decoders.addDecoder(clazz: AppGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = AppGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [AppGetRef]
        Decoders.addDecoder(clazz: [AppGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppGetRef]> in
            return Decoders.decode(clazz: [AppGetRef].self, source: source)
        }

        // Decoder for AppGetRef
        Decoders.addDecoder(clazz: AppGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = AppGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmentGet]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmentGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmentGet]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmentGet].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmentGet
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmentGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmentGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = AppointmentschedulingAppointmentGet()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmentGet", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmentGetFull]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmentGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmentGetFull]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmentGetFull].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmentGetFull
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmentGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmentGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = AppointmentschedulingAppointmentGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmentGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmentGetRef]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmentGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmentGetRef]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmentGetRef].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmentGetRef
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmentGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmentGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = AppointmentschedulingAppointmentGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmentGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmentblockGet]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmentblockGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmentblockGet]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmentblockGet].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmentblockGet
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmentblockGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmentblockGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = AppointmentschedulingAppointmentblockGet()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmentblockGet", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmentblockGetFull]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmentblockGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmentblockGetFull]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmentblockGetFull].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmentblockGetFull
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmentblockGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmentblockGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = AppointmentschedulingAppointmentblockGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmentblockGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmentblockGetRef]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmentblockGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmentblockGetRef]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmentblockGetRef].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmentblockGetRef
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmentblockGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmentblockGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = AppointmentschedulingAppointmentblockGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmentblockGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmentrequestGet]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmentrequestGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmentrequestGet]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmentrequestGet].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmentrequestGet
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmentrequestGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmentrequestGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = AppointmentschedulingAppointmentrequestGet()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmentrequestGet", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmentrequestGetFull]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmentrequestGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmentrequestGetFull]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmentrequestGetFull].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmentrequestGetFull
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmentrequestGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmentrequestGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = AppointmentschedulingAppointmentrequestGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmentrequestGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmentrequestGetRef]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmentrequestGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmentrequestGetRef]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmentrequestGetRef].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmentrequestGetRef
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmentrequestGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmentrequestGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = AppointmentschedulingAppointmentrequestGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmentrequestGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmenttypeCreate]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmenttypeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmenttypeCreate]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmenttypeCreate].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmenttypeCreate
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmenttypeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmenttypeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmenttypeCreate", actual: "\(nameSource)"))
                }
                let _result = AppointmentschedulingAppointmenttypeCreate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmenttypeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmenttypeCreateFull]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmenttypeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmenttypeCreateFull]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmenttypeCreateFull].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmenttypeCreateFull
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmenttypeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmenttypeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmenttypeCreateFull", actual: "\(nameSource)"))
                }
                let _result = AppointmentschedulingAppointmenttypeCreateFull(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmenttypeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmenttypeGet]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmenttypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmenttypeGet]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmenttypeGet].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmenttypeGet
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmenttypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmenttypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = AppointmentschedulingAppointmenttypeGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmenttypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmenttypeGetFull]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmenttypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmenttypeGetFull]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmenttypeGetFull].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmenttypeGetFull
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmenttypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmenttypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = AppointmentschedulingAppointmenttypeGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmenttypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmenttypeGetRef]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmenttypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmenttypeGetRef]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmenttypeGetRef].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmenttypeGetRef
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmenttypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmenttypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = AppointmentschedulingAppointmenttypeGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmenttypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmenttypeUpdate]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmenttypeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmenttypeUpdate]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmenttypeUpdate].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmenttypeUpdate
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmenttypeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmenttypeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmenttypeUpdate", actual: "\(nameSource)"))
                }
                let _result = AppointmentschedulingAppointmenttypeUpdate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmenttypeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingTimeslotGet]
        Decoders.addDecoder(clazz: [AppointmentschedulingTimeslotGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingTimeslotGet]> in
            return Decoders.decode(clazz: [AppointmentschedulingTimeslotGet].self, source: source)
        }

        // Decoder for AppointmentschedulingTimeslotGet
        Decoders.addDecoder(clazz: AppointmentschedulingTimeslotGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingTimeslotGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = AppointmentschedulingTimeslotGet()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingTimeslotGet", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingTimeslotGetFull]
        Decoders.addDecoder(clazz: [AppointmentschedulingTimeslotGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingTimeslotGetFull]> in
            return Decoders.decode(clazz: [AppointmentschedulingTimeslotGetFull].self, source: source)
        }

        // Decoder for AppointmentschedulingTimeslotGetFull
        Decoders.addDecoder(clazz: AppointmentschedulingTimeslotGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingTimeslotGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = AppointmentschedulingTimeslotGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingTimeslotGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingTimeslotGetRef]
        Decoders.addDecoder(clazz: [AppointmentschedulingTimeslotGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingTimeslotGetRef]> in
            return Decoders.decode(clazz: [AppointmentschedulingTimeslotGetRef].self, source: source)
        }

        // Decoder for AppointmentschedulingTimeslotGetRef
        Decoders.addDecoder(clazz: AppointmentschedulingTimeslotGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingTimeslotGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = AppointmentschedulingTimeslotGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingTimeslotGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ApptemplateGet]
        Decoders.addDecoder(clazz: [ApptemplateGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ApptemplateGet]> in
            return Decoders.decode(clazz: [ApptemplateGet].self, source: source)
        }

        // Decoder for ApptemplateGet
        Decoders.addDecoder(clazz: ApptemplateGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ApptemplateGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ApptemplateGet()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ApptemplateGet", actual: "\(source)"))
            }
        }
        // Decoder for [ApptemplateGetFull]
        Decoders.addDecoder(clazz: [ApptemplateGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ApptemplateGetFull]> in
            return Decoders.decode(clazz: [ApptemplateGetFull].self, source: source)
        }

        // Decoder for ApptemplateGetFull
        Decoders.addDecoder(clazz: ApptemplateGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ApptemplateGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ApptemplateGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ApptemplateGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ApptemplateGetRef]
        Decoders.addDecoder(clazz: [ApptemplateGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ApptemplateGetRef]> in
            return Decoders.decode(clazz: [ApptemplateGetRef].self, source: source)
        }

        // Decoder for ApptemplateGetRef
        Decoders.addDecoder(clazz: ApptemplateGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ApptemplateGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ApptemplateGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ApptemplateGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [CaresettingGet]
        Decoders.addDecoder(clazz: [CaresettingGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CaresettingGet]> in
            return Decoders.decode(clazz: [CaresettingGet].self, source: source)
        }

        // Decoder for CaresettingGet
        Decoders.addDecoder(clazz: CaresettingGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CaresettingGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = CaresettingGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: CaresettingGet.CareSettingType.self, source: sourceDictionary["careSettingType"] as AnyObject?) {
                case let .success(value): _result.careSettingType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CaresettingGet", actual: "\(source)"))
            }
        }
        // Decoder for [CaresettingGetFull]
        Decoders.addDecoder(clazz: [CaresettingGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CaresettingGetFull]> in
            return Decoders.decode(clazz: [CaresettingGetFull].self, source: source)
        }

        // Decoder for CaresettingGetFull
        Decoders.addDecoder(clazz: CaresettingGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CaresettingGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = CaresettingGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: CaresettingGetFull.CareSettingType.self, source: sourceDictionary["careSettingType"] as AnyObject?) {
                case let .success(value): _result.careSettingType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CaresettingGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [CaresettingGetRef]
        Decoders.addDecoder(clazz: [CaresettingGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CaresettingGetRef]> in
            return Decoders.decode(clazz: [CaresettingGetRef].self, source: source)
        }

        // Decoder for CaresettingGetRef
        Decoders.addDecoder(clazz: CaresettingGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CaresettingGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = CaresettingGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CaresettingGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ChartSearchPreferenceGet]
        Decoders.addDecoder(clazz: [ChartSearchPreferenceGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ChartSearchPreferenceGet]> in
            return Decoders.decode(clazz: [ChartSearchPreferenceGet].self, source: source)
        }

        // Decoder for ChartSearchPreferenceGet
        Decoders.addDecoder(clazz: ChartSearchPreferenceGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ChartSearchPreferenceGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ChartSearchPreferenceGet()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ChartSearchPreferenceGet", actual: "\(source)"))
            }
        }
        // Decoder for [ChartSearchPreferenceGetFull]
        Decoders.addDecoder(clazz: [ChartSearchPreferenceGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ChartSearchPreferenceGetFull]> in
            return Decoders.decode(clazz: [ChartSearchPreferenceGetFull].self, source: source)
        }

        // Decoder for ChartSearchPreferenceGetFull
        Decoders.addDecoder(clazz: ChartSearchPreferenceGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ChartSearchPreferenceGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ChartSearchPreferenceGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ChartSearchPreferenceGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ChartSearchPreferenceGetRef]
        Decoders.addDecoder(clazz: [ChartSearchPreferenceGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ChartSearchPreferenceGetRef]> in
            return Decoders.decode(clazz: [ChartSearchPreferenceGetRef].self, source: source)
        }

        // Decoder for ChartSearchPreferenceGetRef
        Decoders.addDecoder(clazz: ChartSearchPreferenceGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ChartSearchPreferenceGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ChartSearchPreferenceGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ChartSearchPreferenceGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ChartsearchnoteGet]
        Decoders.addDecoder(clazz: [ChartsearchnoteGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ChartsearchnoteGet]> in
            return Decoders.decode(clazz: [ChartsearchnoteGet].self, source: source)
        }

        // Decoder for ChartsearchnoteGet
        Decoders.addDecoder(clazz: ChartsearchnoteGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ChartsearchnoteGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ChartsearchnoteGet()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ChartsearchnoteGet", actual: "\(source)"))
            }
        }
        // Decoder for [ChartsearchnoteGetFull]
        Decoders.addDecoder(clazz: [ChartsearchnoteGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ChartsearchnoteGetFull]> in
            return Decoders.decode(clazz: [ChartsearchnoteGetFull].self, source: source)
        }

        // Decoder for ChartsearchnoteGetFull
        Decoders.addDecoder(clazz: ChartsearchnoteGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ChartsearchnoteGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ChartsearchnoteGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ChartsearchnoteGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ChartsearchnoteGetRef]
        Decoders.addDecoder(clazz: [ChartsearchnoteGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ChartsearchnoteGetRef]> in
            return Decoders.decode(clazz: [ChartsearchnoteGetRef].self, source: source)
        }

        // Decoder for ChartsearchnoteGetRef
        Decoders.addDecoder(clazz: ChartsearchnoteGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ChartsearchnoteGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ChartsearchnoteGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ChartsearchnoteGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [CohortCreate]
        Decoders.addDecoder(clazz: [CohortCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CohortCreate]> in
            return Decoders.decode(clazz: [CohortCreate].self, source: source)
        }

        // Decoder for CohortCreate
        Decoders.addDecoder(clazz: CohortCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CohortCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "CohortCreate", actual: "\(nameSource)"))
                }
                guard let descriptionSource = sourceDictionary["description"] as AnyObject? else {
                    return .failure(.missingKey(key: "description"))
                }
                guard let description = Decoders.decode(clazz: String.self.self, source: descriptionSource).value else {
                    return .failure(.typeMismatch(expected: "CohortCreate", actual: "\(descriptionSource)"))
                }
                guard let memberIdsSource = sourceDictionary["memberIds"] as AnyObject? else {
                    return .failure(.missingKey(key: "memberIds"))
                }
                guard let memberIds = Decoders.decode(clazz: [Int32].self.self, source: memberIdsSource).value else {
                    return .failure(.typeMismatch(expected: "CohortCreate", actual: "\(memberIdsSource)"))
                }
                let _result = CohortCreate(name: name, description: description, memberIds: memberIds)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CohortCreate", actual: "\(source)"))
            }
        }
        // Decoder for [CohortCreateFull]
        Decoders.addDecoder(clazz: [CohortCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CohortCreateFull]> in
            return Decoders.decode(clazz: [CohortCreateFull].self, source: source)
        }

        // Decoder for CohortCreateFull
        Decoders.addDecoder(clazz: CohortCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CohortCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "CohortCreateFull", actual: "\(nameSource)"))
                }
                guard let descriptionSource = sourceDictionary["description"] as AnyObject? else {
                    return .failure(.missingKey(key: "description"))
                }
                guard let description = Decoders.decode(clazz: String.self.self, source: descriptionSource).value else {
                    return .failure(.typeMismatch(expected: "CohortCreateFull", actual: "\(descriptionSource)"))
                }
                guard let memberIdsSource = sourceDictionary["memberIds"] as AnyObject? else {
                    return .failure(.missingKey(key: "memberIds"))
                }
                guard let memberIds = Decoders.decode(clazz: [Int32].self.self, source: memberIdsSource).value else {
                    return .failure(.typeMismatch(expected: "CohortCreateFull", actual: "\(memberIdsSource)"))
                }
                let _result = CohortCreateFull(name: name, description: description, memberIds: memberIds)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CohortCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [CohortGet]
        Decoders.addDecoder(clazz: [CohortGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CohortGet]> in
            return Decoders.decode(clazz: [CohortGet].self, source: source)
        }

        // Decoder for CohortGet
        Decoders.addDecoder(clazz: CohortGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CohortGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = CohortGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CohortGet", actual: "\(source)"))
            }
        }
        // Decoder for [CohortGetFull]
        Decoders.addDecoder(clazz: [CohortGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CohortGetFull]> in
            return Decoders.decode(clazz: [CohortGetFull].self, source: source)
        }

        // Decoder for CohortGetFull
        Decoders.addDecoder(clazz: CohortGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CohortGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = CohortGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CohortGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [CohortGetRef]
        Decoders.addDecoder(clazz: [CohortGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CohortGetRef]> in
            return Decoders.decode(clazz: [CohortGetRef].self, source: source)
        }

        // Decoder for CohortGetRef
        Decoders.addDecoder(clazz: CohortGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CohortGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = CohortGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CohortGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [CohortMembershipCreate]
        Decoders.addDecoder(clazz: [CohortMembershipCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CohortMembershipCreate]> in
            return Decoders.decode(clazz: [CohortMembershipCreate].self, source: source)
        }

        // Decoder for CohortMembershipCreate
        Decoders.addDecoder(clazz: CohortMembershipCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CohortMembershipCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = CohortMembershipCreate()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["patientUuid"] as AnyObject?) {
                case let .success(value): _result.patientUuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CohortMembershipCreate", actual: "\(source)"))
            }
        }
        // Decoder for [CohortMembershipCreateFull]
        Decoders.addDecoder(clazz: [CohortMembershipCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CohortMembershipCreateFull]> in
            return Decoders.decode(clazz: [CohortMembershipCreateFull].self, source: source)
        }

        // Decoder for CohortMembershipCreateFull
        Decoders.addDecoder(clazz: CohortMembershipCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CohortMembershipCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = CohortMembershipCreateFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["patientUuid"] as AnyObject?) {
                case let .success(value): _result.patientUuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CohortMembershipCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [CohortMembershipGet]
        Decoders.addDecoder(clazz: [CohortMembershipGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CohortMembershipGet]> in
            return Decoders.decode(clazz: [CohortMembershipGet].self, source: source)
        }

        // Decoder for CohortMembershipGet
        Decoders.addDecoder(clazz: CohortMembershipGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CohortMembershipGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = CohortMembershipGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["patientUuid"] as AnyObject?) {
                case let .success(value): _result.patientUuid = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CohortMembershipGet", actual: "\(source)"))
            }
        }
        // Decoder for [CohortMembershipGetFull]
        Decoders.addDecoder(clazz: [CohortMembershipGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CohortMembershipGetFull]> in
            return Decoders.decode(clazz: [CohortMembershipGetFull].self, source: source)
        }

        // Decoder for CohortMembershipGetFull
        Decoders.addDecoder(clazz: CohortMembershipGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CohortMembershipGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = CohortMembershipGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["patientUuid"] as AnyObject?) {
                case let .success(value): _result.patientUuid = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CohortMembershipGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [CohortMembershipGetRef]
        Decoders.addDecoder(clazz: [CohortMembershipGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CohortMembershipGetRef]> in
            return Decoders.decode(clazz: [CohortMembershipGetRef].self, source: source)
        }

        // Decoder for CohortMembershipGetRef
        Decoders.addDecoder(clazz: CohortMembershipGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CohortMembershipGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = CohortMembershipGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CohortMembershipGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [CohortMembershipUpdate]
        Decoders.addDecoder(clazz: [CohortMembershipUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CohortMembershipUpdate]> in
            return Decoders.decode(clazz: [CohortMembershipUpdate].self, source: source)
        }

        // Decoder for CohortMembershipUpdate
        Decoders.addDecoder(clazz: CohortMembershipUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CohortMembershipUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = CohortMembershipUpdate()
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CohortMembershipUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [CohortUpdate]
        Decoders.addDecoder(clazz: [CohortUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CohortUpdate]> in
            return Decoders.decode(clazz: [CohortUpdate].self, source: source)
        }

        // Decoder for CohortUpdate
        Decoders.addDecoder(clazz: CohortUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CohortUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "CohortUpdate", actual: "\(nameSource)"))
                }
                guard let descriptionSource = sourceDictionary["description"] as AnyObject? else {
                    return .failure(.missingKey(key: "description"))
                }
                guard let description = Decoders.decode(clazz: String.self.self, source: descriptionSource).value else {
                    return .failure(.typeMismatch(expected: "CohortUpdate", actual: "\(descriptionSource)"))
                }
                let _result = CohortUpdate(name: name, description: description)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CohortUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptAttributeCreate]
        Decoders.addDecoder(clazz: [ConceptAttributeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptAttributeCreate]> in
            return Decoders.decode(clazz: [ConceptAttributeCreate].self, source: source)
        }

        // Decoder for ConceptAttributeCreate
        Decoders.addDecoder(clazz: ConceptAttributeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptAttributeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let attributeTypeSource = sourceDictionary["attributeType"] as AnyObject? else {
                    return .failure(.missingKey(key: "attributeType"))
                }
                guard let attributeType = Decoders.decode(clazz: String.self.self, source: attributeTypeSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptAttributeCreate", actual: "\(attributeTypeSource)"))
                }
                guard let valueSource = sourceDictionary["value"] as AnyObject? else {
                    return .failure(.missingKey(key: "value"))
                }
                guard let value = Decoders.decode(clazz: String.self.self, source: valueSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptAttributeCreate", actual: "\(valueSource)"))
                }
                let _result = ConceptAttributeCreate(attributeType: attributeType, value: value)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptAttributeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptAttributeCreateFull]
        Decoders.addDecoder(clazz: [ConceptAttributeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptAttributeCreateFull]> in
            return Decoders.decode(clazz: [ConceptAttributeCreateFull].self, source: source)
        }

        // Decoder for ConceptAttributeCreateFull
        Decoders.addDecoder(clazz: ConceptAttributeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptAttributeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let attributeTypeSource = sourceDictionary["attributeType"] as AnyObject? else {
                    return .failure(.missingKey(key: "attributeType"))
                }
                guard let attributeType = Decoders.decode(clazz: String.self.self, source: attributeTypeSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptAttributeCreateFull", actual: "\(attributeTypeSource)"))
                }
                guard let valueSource = sourceDictionary["value"] as AnyObject? else {
                    return .failure(.missingKey(key: "value"))
                }
                guard let value = Decoders.decode(clazz: String.self.self, source: valueSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptAttributeCreateFull", actual: "\(valueSource)"))
                }
                let _result = ConceptAttributeCreateFull(attributeType: attributeType, value: value)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptAttributeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptAttributeGet]
        Decoders.addDecoder(clazz: [ConceptAttributeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptAttributeGet]> in
            return Decoders.decode(clazz: [ConceptAttributeGet].self, source: source)
        }

        // Decoder for ConceptAttributeGet
        Decoders.addDecoder(clazz: ConceptAttributeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptAttributeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptAttributeGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptAttributeGet", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptAttributeGetFull]
        Decoders.addDecoder(clazz: [ConceptAttributeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptAttributeGetFull]> in
            return Decoders.decode(clazz: [ConceptAttributeGetFull].self, source: source)
        }

        // Decoder for ConceptAttributeGetFull
        Decoders.addDecoder(clazz: ConceptAttributeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptAttributeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptAttributeGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptAttributeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptAttributeGetRef]
        Decoders.addDecoder(clazz: [ConceptAttributeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptAttributeGetRef]> in
            return Decoders.decode(clazz: [ConceptAttributeGetRef].self, source: source)
        }

        // Decoder for ConceptAttributeGetRef
        Decoders.addDecoder(clazz: ConceptAttributeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptAttributeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptAttributeGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptAttributeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptAttributeUpdate]
        Decoders.addDecoder(clazz: [ConceptAttributeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptAttributeUpdate]> in
            return Decoders.decode(clazz: [ConceptAttributeUpdate].self, source: source)
        }

        // Decoder for ConceptAttributeUpdate
        Decoders.addDecoder(clazz: ConceptAttributeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptAttributeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let attributeTypeSource = sourceDictionary["attributeType"] as AnyObject? else {
                    return .failure(.missingKey(key: "attributeType"))
                }
                guard let attributeType = Decoders.decode(clazz: String.self.self, source: attributeTypeSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptAttributeUpdate", actual: "\(attributeTypeSource)"))
                }
                guard let valueSource = sourceDictionary["value"] as AnyObject? else {
                    return .failure(.missingKey(key: "value"))
                }
                guard let value = Decoders.decode(clazz: String.self.self, source: valueSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptAttributeUpdate", actual: "\(valueSource)"))
                }
                let _result = ConceptAttributeUpdate(attributeType: attributeType, value: value)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptAttributeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptCreate]
        Decoders.addDecoder(clazz: [ConceptCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptCreate]> in
            return Decoders.decode(clazz: [ConceptCreate].self, source: source)
        }

        // Decoder for ConceptCreate
        Decoders.addDecoder(clazz: ConceptCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let namesSource = sourceDictionary["names"] as AnyObject? else {
                    return .failure(.missingKey(key: "names"))
                }
                guard let names = Decoders.decode(clazz: [ConceptNameCreate].self.self, source: namesSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptCreate", actual: "\(namesSource)"))
                }
                guard let datatypeSource = sourceDictionary["datatype"] as AnyObject? else {
                    return .failure(.missingKey(key: "datatype"))
                }
                guard let datatype = Decoders.decode(clazz: String.self.self, source: datatypeSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptCreate", actual: "\(datatypeSource)"))
                }
                guard let conceptClassSource = sourceDictionary["conceptClass"] as AnyObject? else {
                    return .failure(.missingKey(key: "conceptClass"))
                }
                guard let conceptClass = Decoders.decode(clazz: String.self.self, source: conceptClassSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptCreate", actual: "\(conceptClassSource)"))
                }
                let _result = ConceptCreate(names: names, datatype: datatype, conceptClass: conceptClass)
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["set"] as AnyObject?) {
                case let .success(value): _result._set = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["version"] as AnyObject?) {
                case let .success(value): _result.version = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["answers"] as AnyObject?) {
                case let .success(value): _result.answers = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["setMembers"] as AnyObject?) {
                case let .success(value): _result.setMembers = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hiNormal"] as AnyObject?) {
                case let .success(value): _result.hiNormal = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hiAbsolute"] as AnyObject?) {
                case let .success(value): _result.hiAbsolute = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hiCritical"] as AnyObject?) {
                case let .success(value): _result.hiCritical = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["lowNormal"] as AnyObject?) {
                case let .success(value): _result.lowNormal = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["lowAbsolute"] as AnyObject?) {
                case let .success(value): _result.lowAbsolute = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["lowCritical"] as AnyObject?) {
                case let .success(value): _result.lowCritical = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["units"] as AnyObject?) {
                case let .success(value): _result.units = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["allowDecimal"] as AnyObject?) {
                case let .success(value): _result.allowDecimal = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["displayPrecision"] as AnyObject?) {
                case let .success(value): _result.displayPrecision = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["descriptions"] as AnyObject?) {
                case let .success(value): _result.descriptions = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["mappings"] as AnyObject?) {
                case let .success(value): _result.mappings = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptCreateFull]
        Decoders.addDecoder(clazz: [ConceptCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptCreateFull]> in
            return Decoders.decode(clazz: [ConceptCreateFull].self, source: source)
        }

        // Decoder for ConceptCreateFull
        Decoders.addDecoder(clazz: ConceptCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let namesSource = sourceDictionary["names"] as AnyObject? else {
                    return .failure(.missingKey(key: "names"))
                }
                guard let names = Decoders.decode(clazz: [ConceptNameCreate].self.self, source: namesSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptCreateFull", actual: "\(namesSource)"))
                }
                guard let datatypeSource = sourceDictionary["datatype"] as AnyObject? else {
                    return .failure(.missingKey(key: "datatype"))
                }
                guard let datatype = Decoders.decode(clazz: String.self.self, source: datatypeSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptCreateFull", actual: "\(datatypeSource)"))
                }
                guard let conceptClassSource = sourceDictionary["conceptClass"] as AnyObject? else {
                    return .failure(.missingKey(key: "conceptClass"))
                }
                guard let conceptClass = Decoders.decode(clazz: ConceptclassCreate.self.self, source: conceptClassSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptCreateFull", actual: "\(conceptClassSource)"))
                }
                let _result = ConceptCreateFull(names: names, datatype: datatype, conceptClass: conceptClass)
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["set"] as AnyObject?) {
                case let .success(value): _result._set = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["version"] as AnyObject?) {
                case let .success(value): _result.version = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["answers"] as AnyObject?) {
                case let .success(value): _result.answers = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["setMembers"] as AnyObject?) {
                case let .success(value): _result.setMembers = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hiNormal"] as AnyObject?) {
                case let .success(value): _result.hiNormal = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hiAbsolute"] as AnyObject?) {
                case let .success(value): _result.hiAbsolute = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hiCritical"] as AnyObject?) {
                case let .success(value): _result.hiCritical = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["lowNormal"] as AnyObject?) {
                case let .success(value): _result.lowNormal = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["lowAbsolute"] as AnyObject?) {
                case let .success(value): _result.lowAbsolute = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["lowCritical"] as AnyObject?) {
                case let .success(value): _result.lowCritical = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["units"] as AnyObject?) {
                case let .success(value): _result.units = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["allowDecimal"] as AnyObject?) {
                case let .success(value): _result.allowDecimal = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["displayPrecision"] as AnyObject?) {
                case let .success(value): _result.displayPrecision = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ConceptDescriptionCreate].self, source: sourceDictionary["descriptions"] as AnyObject?) {
                case let .success(value): _result.descriptions = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ConceptMappingCreate].self, source: sourceDictionary["mappings"] as AnyObject?) {
                case let .success(value): _result.mappings = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptDescriptionCreate]
        Decoders.addDecoder(clazz: [ConceptDescriptionCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptDescriptionCreate]> in
            return Decoders.decode(clazz: [ConceptDescriptionCreate].self, source: source)
        }

        // Decoder for ConceptDescriptionCreate
        Decoders.addDecoder(clazz: ConceptDescriptionCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptDescriptionCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let descriptionSource = sourceDictionary["description"] as AnyObject? else {
                    return .failure(.missingKey(key: "description"))
                }
                guard let description = Decoders.decode(clazz: String.self.self, source: descriptionSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptDescriptionCreate", actual: "\(descriptionSource)"))
                }
                guard let localeSource = sourceDictionary["locale"] as AnyObject? else {
                    return .failure(.missingKey(key: "locale"))
                }
                guard let locale = Decoders.decode(clazz: String.self.self, source: localeSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptDescriptionCreate", actual: "\(localeSource)"))
                }
                let _result = ConceptDescriptionCreate(description: description, locale: locale)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptDescriptionCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptDescriptionCreateFull]
        Decoders.addDecoder(clazz: [ConceptDescriptionCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptDescriptionCreateFull]> in
            return Decoders.decode(clazz: [ConceptDescriptionCreateFull].self, source: source)
        }

        // Decoder for ConceptDescriptionCreateFull
        Decoders.addDecoder(clazz: ConceptDescriptionCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptDescriptionCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let descriptionSource = sourceDictionary["description"] as AnyObject? else {
                    return .failure(.missingKey(key: "description"))
                }
                guard let description = Decoders.decode(clazz: String.self.self, source: descriptionSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptDescriptionCreateFull", actual: "\(descriptionSource)"))
                }
                guard let localeSource = sourceDictionary["locale"] as AnyObject? else {
                    return .failure(.missingKey(key: "locale"))
                }
                guard let locale = Decoders.decode(clazz: String.self.self, source: localeSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptDescriptionCreateFull", actual: "\(localeSource)"))
                }
                let _result = ConceptDescriptionCreateFull(description: description, locale: locale)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptDescriptionCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptDescriptionGet]
        Decoders.addDecoder(clazz: [ConceptDescriptionGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptDescriptionGet]> in
            return Decoders.decode(clazz: [ConceptDescriptionGet].self, source: source)
        }

        // Decoder for ConceptDescriptionGet
        Decoders.addDecoder(clazz: ConceptDescriptionGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptDescriptionGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptDescriptionGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["locale"] as AnyObject?) {
                case let .success(value): _result.locale = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptDescriptionGet", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptDescriptionGetFull]
        Decoders.addDecoder(clazz: [ConceptDescriptionGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptDescriptionGetFull]> in
            return Decoders.decode(clazz: [ConceptDescriptionGetFull].self, source: source)
        }

        // Decoder for ConceptDescriptionGetFull
        Decoders.addDecoder(clazz: ConceptDescriptionGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptDescriptionGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptDescriptionGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["locale"] as AnyObject?) {
                case let .success(value): _result.locale = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptDescriptionGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptDescriptionGetRef]
        Decoders.addDecoder(clazz: [ConceptDescriptionGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptDescriptionGetRef]> in
            return Decoders.decode(clazz: [ConceptDescriptionGetRef].self, source: source)
        }

        // Decoder for ConceptDescriptionGetRef
        Decoders.addDecoder(clazz: ConceptDescriptionGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptDescriptionGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptDescriptionGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptDescriptionGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptDescriptionUpdate]
        Decoders.addDecoder(clazz: [ConceptDescriptionUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptDescriptionUpdate]> in
            return Decoders.decode(clazz: [ConceptDescriptionUpdate].self, source: source)
        }

        // Decoder for ConceptDescriptionUpdate
        Decoders.addDecoder(clazz: ConceptDescriptionUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptDescriptionUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let descriptionSource = sourceDictionary["description"] as AnyObject? else {
                    return .failure(.missingKey(key: "description"))
                }
                guard let description = Decoders.decode(clazz: String.self.self, source: descriptionSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptDescriptionUpdate", actual: "\(descriptionSource)"))
                }
                guard let localeSource = sourceDictionary["locale"] as AnyObject? else {
                    return .failure(.missingKey(key: "locale"))
                }
                guard let locale = Decoders.decode(clazz: String.self.self, source: localeSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptDescriptionUpdate", actual: "\(localeSource)"))
                }
                let _result = ConceptDescriptionUpdate(description: description, locale: locale)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptDescriptionUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptGet]
        Decoders.addDecoder(clazz: [ConceptGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptGet]> in
            return Decoders.decode(clazz: [ConceptGet].self, source: source)
        }

        // Decoder for ConceptGet
        Decoders.addDecoder(clazz: ConceptGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptNameGet.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptdatatypeGetRef.self, source: sourceDictionary["datatype"] as AnyObject?) {
                case let .success(value): _result.datatype = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptclassGetRef.self, source: sourceDictionary["conceptClass"] as AnyObject?) {
                case let .success(value): _result.conceptClass = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["set"] as AnyObject?) {
                case let .success(value): _result._set = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["version"] as AnyObject?) {
                case let .success(value): _result.version = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ConceptNameGetRef].self, source: sourceDictionary["names"] as AnyObject?) {
                case let .success(value): _result.names = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ConceptDescriptionGetRef].self, source: sourceDictionary["descriptions"] as AnyObject?) {
                case let .success(value): _result.descriptions = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ConceptMappingGetRef].self, source: sourceDictionary["mappings"] as AnyObject?) {
                case let .success(value): _result.mappings = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Any].self, source: sourceDictionary["answers"] as AnyObject?) {
                case let .success(value): _result.answers = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Any].self, source: sourceDictionary["setMembers"] as AnyObject?) {
                case let .success(value): _result.setMembers = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptGet", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptGetFull]
        Decoders.addDecoder(clazz: [ConceptGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptGetFull]> in
            return Decoders.decode(clazz: [ConceptGetFull].self, source: source)
        }

        // Decoder for ConceptGetFull
        Decoders.addDecoder(clazz: ConceptGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptGetRef]
        Decoders.addDecoder(clazz: [ConceptGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptGetRef]> in
            return Decoders.decode(clazz: [ConceptGetRef].self, source: source)
        }

        // Decoder for ConceptGetRef
        Decoders.addDecoder(clazz: ConceptGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptMappingCreate]
        Decoders.addDecoder(clazz: [ConceptMappingCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptMappingCreate]> in
            return Decoders.decode(clazz: [ConceptMappingCreate].self, source: source)
        }

        // Decoder for ConceptMappingCreate
        Decoders.addDecoder(clazz: ConceptMappingCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptMappingCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let conceptReferenceTermSource = sourceDictionary["conceptReferenceTerm"] as AnyObject? else {
                    return .failure(.missingKey(key: "conceptReferenceTerm"))
                }
                guard let conceptReferenceTerm = Decoders.decode(clazz: ConceptreferencetermCreate.self.self, source: conceptReferenceTermSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptMappingCreate", actual: "\(conceptReferenceTermSource)"))
                }
                guard let conceptMapTypeSource = sourceDictionary["conceptMapType"] as AnyObject? else {
                    return .failure(.missingKey(key: "conceptMapType"))
                }
                guard let conceptMapType = Decoders.decode(clazz: ConceptmaptypeCreate.self.self, source: conceptMapTypeSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptMappingCreate", actual: "\(conceptMapTypeSource)"))
                }
                let _result = ConceptMappingCreate(conceptReferenceTerm: conceptReferenceTerm, conceptMapType: conceptMapType)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptMappingCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptMappingCreateFull]
        Decoders.addDecoder(clazz: [ConceptMappingCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptMappingCreateFull]> in
            return Decoders.decode(clazz: [ConceptMappingCreateFull].self, source: source)
        }

        // Decoder for ConceptMappingCreateFull
        Decoders.addDecoder(clazz: ConceptMappingCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptMappingCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let conceptReferenceTermSource = sourceDictionary["conceptReferenceTerm"] as AnyObject? else {
                    return .failure(.missingKey(key: "conceptReferenceTerm"))
                }
                guard let conceptReferenceTerm = Decoders.decode(clazz: ConceptreferencetermCreate.self.self, source: conceptReferenceTermSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptMappingCreateFull", actual: "\(conceptReferenceTermSource)"))
                }
                guard let conceptMapTypeSource = sourceDictionary["conceptMapType"] as AnyObject? else {
                    return .failure(.missingKey(key: "conceptMapType"))
                }
                guard let conceptMapType = Decoders.decode(clazz: ConceptmaptypeCreate.self.self, source: conceptMapTypeSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptMappingCreateFull", actual: "\(conceptMapTypeSource)"))
                }
                let _result = ConceptMappingCreateFull(conceptReferenceTerm: conceptReferenceTerm, conceptMapType: conceptMapType)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptMappingCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptMappingGet]
        Decoders.addDecoder(clazz: [ConceptMappingGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptMappingGet]> in
            return Decoders.decode(clazz: [ConceptMappingGet].self, source: source)
        }

        // Decoder for ConceptMappingGet
        Decoders.addDecoder(clazz: ConceptMappingGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptMappingGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptMappingGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptreferencetermGetRef.self, source: sourceDictionary["conceptReferenceTerm"] as AnyObject?) {
                case let .success(value): _result.conceptReferenceTerm = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptmaptypeGetRef.self, source: sourceDictionary["conceptMapType"] as AnyObject?) {
                case let .success(value): _result.conceptMapType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptMappingGet", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptMappingGetFull]
        Decoders.addDecoder(clazz: [ConceptMappingGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptMappingGetFull]> in
            return Decoders.decode(clazz: [ConceptMappingGetFull].self, source: source)
        }

        // Decoder for ConceptMappingGetFull
        Decoders.addDecoder(clazz: ConceptMappingGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptMappingGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptMappingGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptreferencetermGet.self, source: sourceDictionary["conceptReferenceTerm"] as AnyObject?) {
                case let .success(value): _result.conceptReferenceTerm = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptmaptypeGet.self, source: sourceDictionary["conceptMapType"] as AnyObject?) {
                case let .success(value): _result.conceptMapType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptMappingGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptMappingGetRef]
        Decoders.addDecoder(clazz: [ConceptMappingGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptMappingGetRef]> in
            return Decoders.decode(clazz: [ConceptMappingGetRef].self, source: source)
        }

        // Decoder for ConceptMappingGetRef
        Decoders.addDecoder(clazz: ConceptMappingGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptMappingGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptMappingGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptMappingGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptMappingUpdate]
        Decoders.addDecoder(clazz: [ConceptMappingUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptMappingUpdate]> in
            return Decoders.decode(clazz: [ConceptMappingUpdate].self, source: source)
        }

        // Decoder for ConceptMappingUpdate
        Decoders.addDecoder(clazz: ConceptMappingUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptMappingUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let conceptReferenceTermSource = sourceDictionary["conceptReferenceTerm"] as AnyObject? else {
                    return .failure(.missingKey(key: "conceptReferenceTerm"))
                }
                guard let conceptReferenceTerm = Decoders.decode(clazz: ConceptreferencetermCreate.self.self, source: conceptReferenceTermSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptMappingUpdate", actual: "\(conceptReferenceTermSource)"))
                }
                guard let conceptMapTypeSource = sourceDictionary["conceptMapType"] as AnyObject? else {
                    return .failure(.missingKey(key: "conceptMapType"))
                }
                guard let conceptMapType = Decoders.decode(clazz: ConceptmaptypeCreate.self.self, source: conceptMapTypeSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptMappingUpdate", actual: "\(conceptMapTypeSource)"))
                }
                let _result = ConceptMappingUpdate(conceptReferenceTerm: conceptReferenceTerm, conceptMapType: conceptMapType)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptMappingUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptNameCreate]
        Decoders.addDecoder(clazz: [ConceptNameCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptNameCreate]> in
            return Decoders.decode(clazz: [ConceptNameCreate].self, source: source)
        }

        // Decoder for ConceptNameCreate
        Decoders.addDecoder(clazz: ConceptNameCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptNameCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptNameCreate", actual: "\(nameSource)"))
                }
                guard let localeSource = sourceDictionary["locale"] as AnyObject? else {
                    return .failure(.missingKey(key: "locale"))
                }
                guard let locale = Decoders.decode(clazz: String.self.self, source: localeSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptNameCreate", actual: "\(localeSource)"))
                }
                let _result = ConceptNameCreate(name: name, locale: locale)
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["localePreferred"] as AnyObject?) {
                case let .success(value): _result.localePreferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptNameCreate.ConceptNameType.self, source: sourceDictionary["conceptNameType"] as AnyObject?) {
                case let .success(value): _result.conceptNameType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptNameCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptNameCreateFull]
        Decoders.addDecoder(clazz: [ConceptNameCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptNameCreateFull]> in
            return Decoders.decode(clazz: [ConceptNameCreateFull].self, source: source)
        }

        // Decoder for ConceptNameCreateFull
        Decoders.addDecoder(clazz: ConceptNameCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptNameCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptNameCreateFull", actual: "\(nameSource)"))
                }
                guard let localeSource = sourceDictionary["locale"] as AnyObject? else {
                    return .failure(.missingKey(key: "locale"))
                }
                guard let locale = Decoders.decode(clazz: String.self.self, source: localeSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptNameCreateFull", actual: "\(localeSource)"))
                }
                let _result = ConceptNameCreateFull(name: name, locale: locale)
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["localePreferred"] as AnyObject?) {
                case let .success(value): _result.localePreferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptNameCreateFull.ConceptNameType.self, source: sourceDictionary["conceptNameType"] as AnyObject?) {
                case let .success(value): _result.conceptNameType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptNameCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptNameGet]
        Decoders.addDecoder(clazz: [ConceptNameGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptNameGet]> in
            return Decoders.decode(clazz: [ConceptNameGet].self, source: source)
        }

        // Decoder for ConceptNameGet
        Decoders.addDecoder(clazz: ConceptNameGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptNameGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptNameGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["locale"] as AnyObject?) {
                case let .success(value): _result.locale = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["localePreferred"] as AnyObject?) {
                case let .success(value): _result.localePreferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptNameGet.ConceptNameType.self, source: sourceDictionary["conceptNameType"] as AnyObject?) {
                case let .success(value): _result.conceptNameType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptNameGet", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptNameGetFull]
        Decoders.addDecoder(clazz: [ConceptNameGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptNameGetFull]> in
            return Decoders.decode(clazz: [ConceptNameGetFull].self, source: source)
        }

        // Decoder for ConceptNameGetFull
        Decoders.addDecoder(clazz: ConceptNameGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptNameGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptNameGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["locale"] as AnyObject?) {
                case let .success(value): _result.locale = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["localePreferred"] as AnyObject?) {
                case let .success(value): _result.localePreferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptNameGetFull.ConceptNameType.self, source: sourceDictionary["conceptNameType"] as AnyObject?) {
                case let .success(value): _result.conceptNameType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptNameGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptNameGetRef]
        Decoders.addDecoder(clazz: [ConceptNameGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptNameGetRef]> in
            return Decoders.decode(clazz: [ConceptNameGetRef].self, source: source)
        }

        // Decoder for ConceptNameGetRef
        Decoders.addDecoder(clazz: ConceptNameGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptNameGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptNameGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptNameGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptNameUpdate]
        Decoders.addDecoder(clazz: [ConceptNameUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptNameUpdate]> in
            return Decoders.decode(clazz: [ConceptNameUpdate].self, source: source)
        }

        // Decoder for ConceptNameUpdate
        Decoders.addDecoder(clazz: ConceptNameUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptNameUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptNameUpdate()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptNameUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptUpdate]
        Decoders.addDecoder(clazz: [ConceptUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptUpdate]> in
            return Decoders.decode(clazz: [ConceptUpdate].self, source: source)
        }

        // Decoder for ConceptUpdate
        Decoders.addDecoder(clazz: ConceptUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptUpdate()
                switch Decoders.decodeOptional(clazz: ConceptNameCreate.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ConceptNameCreate].self, source: sourceDictionary["names"] as AnyObject?) {
                case let .success(value): _result.names = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ConceptDescriptionCreate].self, source: sourceDictionary["descriptions"] as AnyObject?) {
                case let .success(value): _result.descriptions = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptattributetypeCreate]
        Decoders.addDecoder(clazz: [ConceptattributetypeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptattributetypeCreate]> in
            return Decoders.decode(clazz: [ConceptattributetypeCreate].self, source: source)
        }

        // Decoder for ConceptattributetypeCreate
        Decoders.addDecoder(clazz: ConceptattributetypeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptattributetypeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptattributetypeCreate", actual: "\(nameSource)"))
                }
                guard let datatypeClassnameSource = sourceDictionary["datatypeClassname"] as AnyObject? else {
                    return .failure(.missingKey(key: "datatypeClassname"))
                }
                guard let datatypeClassname = Decoders.decode(clazz: String.self.self, source: datatypeClassnameSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptattributetypeCreate", actual: "\(datatypeClassnameSource)"))
                }
                let _result = ConceptattributetypeCreate(name: name, datatypeClassname: datatypeClassname)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptattributetypeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptattributetypeCreateFull]
        Decoders.addDecoder(clazz: [ConceptattributetypeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptattributetypeCreateFull]> in
            return Decoders.decode(clazz: [ConceptattributetypeCreateFull].self, source: source)
        }

        // Decoder for ConceptattributetypeCreateFull
        Decoders.addDecoder(clazz: ConceptattributetypeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptattributetypeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptattributetypeCreateFull", actual: "\(nameSource)"))
                }
                guard let datatypeClassnameSource = sourceDictionary["datatypeClassname"] as AnyObject? else {
                    return .failure(.missingKey(key: "datatypeClassname"))
                }
                guard let datatypeClassname = Decoders.decode(clazz: String.self.self, source: datatypeClassnameSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptattributetypeCreateFull", actual: "\(datatypeClassnameSource)"))
                }
                let _result = ConceptattributetypeCreateFull(name: name, datatypeClassname: datatypeClassname)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptattributetypeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptattributetypeGet]
        Decoders.addDecoder(clazz: [ConceptattributetypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptattributetypeGet]> in
            return Decoders.decode(clazz: [ConceptattributetypeGet].self, source: source)
        }

        // Decoder for ConceptattributetypeGet
        Decoders.addDecoder(clazz: ConceptattributetypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptattributetypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptattributetypeGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptattributetypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptattributetypeGetFull]
        Decoders.addDecoder(clazz: [ConceptattributetypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptattributetypeGetFull]> in
            return Decoders.decode(clazz: [ConceptattributetypeGetFull].self, source: source)
        }

        // Decoder for ConceptattributetypeGetFull
        Decoders.addDecoder(clazz: ConceptattributetypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptattributetypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptattributetypeGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptattributetypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptattributetypeGetRef]
        Decoders.addDecoder(clazz: [ConceptattributetypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptattributetypeGetRef]> in
            return Decoders.decode(clazz: [ConceptattributetypeGetRef].self, source: source)
        }

        // Decoder for ConceptattributetypeGetRef
        Decoders.addDecoder(clazz: ConceptattributetypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptattributetypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptattributetypeGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptattributetypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptattributetypeUpdate]
        Decoders.addDecoder(clazz: [ConceptattributetypeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptattributetypeUpdate]> in
            return Decoders.decode(clazz: [ConceptattributetypeUpdate].self, source: source)
        }

        // Decoder for ConceptattributetypeUpdate
        Decoders.addDecoder(clazz: ConceptattributetypeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptattributetypeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptattributetypeUpdate", actual: "\(nameSource)"))
                }
                guard let datatypeClassnameSource = sourceDictionary["datatypeClassname"] as AnyObject? else {
                    return .failure(.missingKey(key: "datatypeClassname"))
                }
                guard let datatypeClassname = Decoders.decode(clazz: String.self.self, source: datatypeClassnameSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptattributetypeUpdate", actual: "\(datatypeClassnameSource)"))
                }
                let _result = ConceptattributetypeUpdate(name: name, datatypeClassname: datatypeClassname)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptattributetypeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptclassCreate]
        Decoders.addDecoder(clazz: [ConceptclassCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptclassCreate]> in
            return Decoders.decode(clazz: [ConceptclassCreate].self, source: source)
        }

        // Decoder for ConceptclassCreate
        Decoders.addDecoder(clazz: ConceptclassCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptclassCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptclassCreate", actual: "\(nameSource)"))
                }
                let _result = ConceptclassCreate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptclassCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptclassCreateFull]
        Decoders.addDecoder(clazz: [ConceptclassCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptclassCreateFull]> in
            return Decoders.decode(clazz: [ConceptclassCreateFull].self, source: source)
        }

        // Decoder for ConceptclassCreateFull
        Decoders.addDecoder(clazz: ConceptclassCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptclassCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptclassCreateFull", actual: "\(nameSource)"))
                }
                let _result = ConceptclassCreateFull(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptclassCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptclassGet]
        Decoders.addDecoder(clazz: [ConceptclassGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptclassGet]> in
            return Decoders.decode(clazz: [ConceptclassGet].self, source: source)
        }

        // Decoder for ConceptclassGet
        Decoders.addDecoder(clazz: ConceptclassGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptclassGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptclassGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptclassGet", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptclassGetFull]
        Decoders.addDecoder(clazz: [ConceptclassGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptclassGetFull]> in
            return Decoders.decode(clazz: [ConceptclassGetFull].self, source: source)
        }

        // Decoder for ConceptclassGetFull
        Decoders.addDecoder(clazz: ConceptclassGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptclassGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptclassGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptclassGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptclassGetRef]
        Decoders.addDecoder(clazz: [ConceptclassGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptclassGetRef]> in
            return Decoders.decode(clazz: [ConceptclassGetRef].self, source: source)
        }

        // Decoder for ConceptclassGetRef
        Decoders.addDecoder(clazz: ConceptclassGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptclassGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptclassGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptclassGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptclassUpdate]
        Decoders.addDecoder(clazz: [ConceptclassUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptclassUpdate]> in
            return Decoders.decode(clazz: [ConceptclassUpdate].self, source: source)
        }

        // Decoder for ConceptclassUpdate
        Decoders.addDecoder(clazz: ConceptclassUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptclassUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptclassUpdate", actual: "\(nameSource)"))
                }
                let _result = ConceptclassUpdate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptclassUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptdatatypeGet]
        Decoders.addDecoder(clazz: [ConceptdatatypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptdatatypeGet]> in
            return Decoders.decode(clazz: [ConceptdatatypeGet].self, source: source)
        }

        // Decoder for ConceptdatatypeGet
        Decoders.addDecoder(clazz: ConceptdatatypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptdatatypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptdatatypeGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hl7Abbreviation"] as AnyObject?) {
                case let .success(value): _result.hl7Abbreviation = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptdatatypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptdatatypeGetFull]
        Decoders.addDecoder(clazz: [ConceptdatatypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptdatatypeGetFull]> in
            return Decoders.decode(clazz: [ConceptdatatypeGetFull].self, source: source)
        }

        // Decoder for ConceptdatatypeGetFull
        Decoders.addDecoder(clazz: ConceptdatatypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptdatatypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptdatatypeGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hl7Abbreviation"] as AnyObject?) {
                case let .success(value): _result.hl7Abbreviation = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptdatatypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptdatatypeGetRef]
        Decoders.addDecoder(clazz: [ConceptdatatypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptdatatypeGetRef]> in
            return Decoders.decode(clazz: [ConceptdatatypeGetRef].self, source: source)
        }

        // Decoder for ConceptdatatypeGetRef
        Decoders.addDecoder(clazz: ConceptdatatypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptdatatypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptdatatypeGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptdatatypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptmaptypeCreate]
        Decoders.addDecoder(clazz: [ConceptmaptypeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptmaptypeCreate]> in
            return Decoders.decode(clazz: [ConceptmaptypeCreate].self, source: source)
        }

        // Decoder for ConceptmaptypeCreate
        Decoders.addDecoder(clazz: ConceptmaptypeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptmaptypeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptmaptypeCreate", actual: "\(nameSource)"))
                }
                let _result = ConceptmaptypeCreate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["isHidden"] as AnyObject?) {
                case let .success(value): _result.isHidden = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptmaptypeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptmaptypeCreateFull]
        Decoders.addDecoder(clazz: [ConceptmaptypeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptmaptypeCreateFull]> in
            return Decoders.decode(clazz: [ConceptmaptypeCreateFull].self, source: source)
        }

        // Decoder for ConceptmaptypeCreateFull
        Decoders.addDecoder(clazz: ConceptmaptypeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptmaptypeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptmaptypeCreateFull", actual: "\(nameSource)"))
                }
                let _result = ConceptmaptypeCreateFull(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["isHidden"] as AnyObject?) {
                case let .success(value): _result.isHidden = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptmaptypeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptmaptypeGet]
        Decoders.addDecoder(clazz: [ConceptmaptypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptmaptypeGet]> in
            return Decoders.decode(clazz: [ConceptmaptypeGet].self, source: source)
        }

        // Decoder for ConceptmaptypeGet
        Decoders.addDecoder(clazz: ConceptmaptypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptmaptypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptmaptypeGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["isHidden"] as AnyObject?) {
                case let .success(value): _result.isHidden = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptmaptypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptmaptypeGetFull]
        Decoders.addDecoder(clazz: [ConceptmaptypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptmaptypeGetFull]> in
            return Decoders.decode(clazz: [ConceptmaptypeGetFull].self, source: source)
        }

        // Decoder for ConceptmaptypeGetFull
        Decoders.addDecoder(clazz: ConceptmaptypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptmaptypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptmaptypeGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["isHidden"] as AnyObject?) {
                case let .success(value): _result.isHidden = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptmaptypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptmaptypeGetRef]
        Decoders.addDecoder(clazz: [ConceptmaptypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptmaptypeGetRef]> in
            return Decoders.decode(clazz: [ConceptmaptypeGetRef].self, source: source)
        }

        // Decoder for ConceptmaptypeGetRef
        Decoders.addDecoder(clazz: ConceptmaptypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptmaptypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptmaptypeGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptmaptypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptmaptypeUpdate]
        Decoders.addDecoder(clazz: [ConceptmaptypeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptmaptypeUpdate]> in
            return Decoders.decode(clazz: [ConceptmaptypeUpdate].self, source: source)
        }

        // Decoder for ConceptmaptypeUpdate
        Decoders.addDecoder(clazz: ConceptmaptypeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptmaptypeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptmaptypeUpdate", actual: "\(nameSource)"))
                }
                let _result = ConceptmaptypeUpdate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["isHidden"] as AnyObject?) {
                case let .success(value): _result.isHidden = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptmaptypeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptreferencetermCreate]
        Decoders.addDecoder(clazz: [ConceptreferencetermCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptreferencetermCreate]> in
            return Decoders.decode(clazz: [ConceptreferencetermCreate].self, source: source)
        }

        // Decoder for ConceptreferencetermCreate
        Decoders.addDecoder(clazz: ConceptreferencetermCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptreferencetermCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptreferencetermCreate", actual: "\(nameSource)"))
                }
                guard let codeSource = sourceDictionary["code"] as AnyObject? else {
                    return .failure(.missingKey(key: "code"))
                }
                guard let code = Decoders.decode(clazz: String.self.self, source: codeSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptreferencetermCreate", actual: "\(codeSource)"))
                }
                guard let conceptSourceSource = sourceDictionary["conceptSource"] as AnyObject? else {
                    return .failure(.missingKey(key: "conceptSource"))
                }
                guard let conceptSource = Decoders.decode(clazz: String.self.self, source: conceptSourceSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptreferencetermCreate", actual: "\(conceptSourceSource)"))
                }
                let _result = ConceptreferencetermCreate(name: name, code: code, conceptSource: conceptSource)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["version"] as AnyObject?) {
                case let .success(value): _result.version = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptreferencetermCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptreferencetermCreateFull]
        Decoders.addDecoder(clazz: [ConceptreferencetermCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptreferencetermCreateFull]> in
            return Decoders.decode(clazz: [ConceptreferencetermCreateFull].self, source: source)
        }

        // Decoder for ConceptreferencetermCreateFull
        Decoders.addDecoder(clazz: ConceptreferencetermCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptreferencetermCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptreferencetermCreateFull", actual: "\(nameSource)"))
                }
                guard let codeSource = sourceDictionary["code"] as AnyObject? else {
                    return .failure(.missingKey(key: "code"))
                }
                guard let code = Decoders.decode(clazz: String.self.self, source: codeSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptreferencetermCreateFull", actual: "\(codeSource)"))
                }
                guard let conceptSourceSource = sourceDictionary["conceptSource"] as AnyObject? else {
                    return .failure(.missingKey(key: "conceptSource"))
                }
                guard let conceptSource = Decoders.decode(clazz: String.self.self, source: conceptSourceSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptreferencetermCreateFull", actual: "\(conceptSourceSource)"))
                }
                let _result = ConceptreferencetermCreateFull(name: name, code: code, conceptSource: conceptSource)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["version"] as AnyObject?) {
                case let .success(value): _result.version = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptreferencetermCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptreferencetermGet]
        Decoders.addDecoder(clazz: [ConceptreferencetermGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptreferencetermGet]> in
            return Decoders.decode(clazz: [ConceptreferencetermGet].self, source: source)
        }

        // Decoder for ConceptreferencetermGet
        Decoders.addDecoder(clazz: ConceptreferencetermGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptreferencetermGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptreferencetermGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["code"] as AnyObject?) {
                case let .success(value): _result.code = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["version"] as AnyObject?) {
                case let .success(value): _result.version = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptsourceGetRef.self, source: sourceDictionary["conceptSource"] as AnyObject?) {
                case let .success(value): _result.conceptSource = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptreferencetermGet", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptreferencetermGetFull]
        Decoders.addDecoder(clazz: [ConceptreferencetermGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptreferencetermGetFull]> in
            return Decoders.decode(clazz: [ConceptreferencetermGetFull].self, source: source)
        }

        // Decoder for ConceptreferencetermGetFull
        Decoders.addDecoder(clazz: ConceptreferencetermGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptreferencetermGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptreferencetermGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["code"] as AnyObject?) {
                case let .success(value): _result.code = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["version"] as AnyObject?) {
                case let .success(value): _result.version = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptsourceGet.self, source: sourceDictionary["conceptSource"] as AnyObject?) {
                case let .success(value): _result.conceptSource = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptreferencetermGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptreferencetermGetRef]
        Decoders.addDecoder(clazz: [ConceptreferencetermGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptreferencetermGetRef]> in
            return Decoders.decode(clazz: [ConceptreferencetermGetRef].self, source: source)
        }

        // Decoder for ConceptreferencetermGetRef
        Decoders.addDecoder(clazz: ConceptreferencetermGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptreferencetermGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptreferencetermGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptreferencetermGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptreferencetermUpdate]
        Decoders.addDecoder(clazz: [ConceptreferencetermUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptreferencetermUpdate]> in
            return Decoders.decode(clazz: [ConceptreferencetermUpdate].self, source: source)
        }

        // Decoder for ConceptreferencetermUpdate
        Decoders.addDecoder(clazz: ConceptreferencetermUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptreferencetermUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptreferencetermUpdate()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptreferencetermUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptreferencetermmapCreate]
        Decoders.addDecoder(clazz: [ConceptreferencetermmapCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptreferencetermmapCreate]> in
            return Decoders.decode(clazz: [ConceptreferencetermmapCreate].self, source: source)
        }

        // Decoder for ConceptreferencetermmapCreate
        Decoders.addDecoder(clazz: ConceptreferencetermmapCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptreferencetermmapCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let termASource = sourceDictionary["termA"] as AnyObject? else {
                    return .failure(.missingKey(key: "termA"))
                }
                guard let termA = Decoders.decode(clazz: ConceptreferencetermCreate.self.self, source: termASource).value else {
                    return .failure(.typeMismatch(expected: "ConceptreferencetermmapCreate", actual: "\(termASource)"))
                }
                guard let termBSource = sourceDictionary["termB"] as AnyObject? else {
                    return .failure(.missingKey(key: "termB"))
                }
                guard let termB = Decoders.decode(clazz: ConceptreferencetermCreate.self.self, source: termBSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptreferencetermmapCreate", actual: "\(termBSource)"))
                }
                guard let conceptMapTypeSource = sourceDictionary["conceptMapType"] as AnyObject? else {
                    return .failure(.missingKey(key: "conceptMapType"))
                }
                guard let conceptMapType = Decoders.decode(clazz: ConceptmaptypeCreate.self.self, source: conceptMapTypeSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptreferencetermmapCreate", actual: "\(conceptMapTypeSource)"))
                }
                let _result = ConceptreferencetermmapCreate(termA: termA, termB: termB, conceptMapType: conceptMapType)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptreferencetermmapCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptreferencetermmapCreateFull]
        Decoders.addDecoder(clazz: [ConceptreferencetermmapCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptreferencetermmapCreateFull]> in
            return Decoders.decode(clazz: [ConceptreferencetermmapCreateFull].self, source: source)
        }

        // Decoder for ConceptreferencetermmapCreateFull
        Decoders.addDecoder(clazz: ConceptreferencetermmapCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptreferencetermmapCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let termASource = sourceDictionary["termA"] as AnyObject? else {
                    return .failure(.missingKey(key: "termA"))
                }
                guard let termA = Decoders.decode(clazz: ConceptreferencetermCreate.self.self, source: termASource).value else {
                    return .failure(.typeMismatch(expected: "ConceptreferencetermmapCreateFull", actual: "\(termASource)"))
                }
                guard let termBSource = sourceDictionary["termB"] as AnyObject? else {
                    return .failure(.missingKey(key: "termB"))
                }
                guard let termB = Decoders.decode(clazz: ConceptreferencetermCreate.self.self, source: termBSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptreferencetermmapCreateFull", actual: "\(termBSource)"))
                }
                guard let conceptMapTypeSource = sourceDictionary["conceptMapType"] as AnyObject? else {
                    return .failure(.missingKey(key: "conceptMapType"))
                }
                guard let conceptMapType = Decoders.decode(clazz: ConceptmaptypeCreate.self.self, source: conceptMapTypeSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptreferencetermmapCreateFull", actual: "\(conceptMapTypeSource)"))
                }
                let _result = ConceptreferencetermmapCreateFull(termA: termA, termB: termB, conceptMapType: conceptMapType)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptreferencetermmapCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptreferencetermmapGet]
        Decoders.addDecoder(clazz: [ConceptreferencetermmapGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptreferencetermmapGet]> in
            return Decoders.decode(clazz: [ConceptreferencetermmapGet].self, source: source)
        }

        // Decoder for ConceptreferencetermmapGet
        Decoders.addDecoder(clazz: ConceptreferencetermmapGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptreferencetermmapGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptreferencetermmapGet()
                switch Decoders.decodeOptional(clazz: ConceptreferencetermGetRef.self, source: sourceDictionary["termA"] as AnyObject?) {
                case let .success(value): _result.termA = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptreferencetermGetRef.self, source: sourceDictionary["termB"] as AnyObject?) {
                case let .success(value): _result.termB = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptmaptypeGetRef.self, source: sourceDictionary["conceptMapType"] as AnyObject?) {
                case let .success(value): _result.conceptMapType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptreferencetermmapGet", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptreferencetermmapGetFull]
        Decoders.addDecoder(clazz: [ConceptreferencetermmapGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptreferencetermmapGetFull]> in
            return Decoders.decode(clazz: [ConceptreferencetermmapGetFull].self, source: source)
        }

        // Decoder for ConceptreferencetermmapGetFull
        Decoders.addDecoder(clazz: ConceptreferencetermmapGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptreferencetermmapGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptreferencetermmapGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptreferencetermGet.self, source: sourceDictionary["termA"] as AnyObject?) {
                case let .success(value): _result.termA = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptreferencetermGet.self, source: sourceDictionary["termB"] as AnyObject?) {
                case let .success(value): _result.termB = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptmaptypeGet.self, source: sourceDictionary["conceptMapType"] as AnyObject?) {
                case let .success(value): _result.conceptMapType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptreferencetermmapGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptreferencetermmapGetRef]
        Decoders.addDecoder(clazz: [ConceptreferencetermmapGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptreferencetermmapGetRef]> in
            return Decoders.decode(clazz: [ConceptreferencetermmapGetRef].self, source: source)
        }

        // Decoder for ConceptreferencetermmapGetRef
        Decoders.addDecoder(clazz: ConceptreferencetermmapGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptreferencetermmapGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptreferencetermmapGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptreferencetermmapGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptreferencetermmapUpdate]
        Decoders.addDecoder(clazz: [ConceptreferencetermmapUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptreferencetermmapUpdate]> in
            return Decoders.decode(clazz: [ConceptreferencetermmapUpdate].self, source: source)
        }

        // Decoder for ConceptreferencetermmapUpdate
        Decoders.addDecoder(clazz: ConceptreferencetermmapUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptreferencetermmapUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptreferencetermmapUpdate()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptreferencetermmapUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptsourceCreate]
        Decoders.addDecoder(clazz: [ConceptsourceCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptsourceCreate]> in
            return Decoders.decode(clazz: [ConceptsourceCreate].self, source: source)
        }

        // Decoder for ConceptsourceCreate
        Decoders.addDecoder(clazz: ConceptsourceCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptsourceCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptsourceCreate", actual: "\(nameSource)"))
                }
                guard let descriptionSource = sourceDictionary["description"] as AnyObject? else {
                    return .failure(.missingKey(key: "description"))
                }
                guard let description = Decoders.decode(clazz: String.self.self, source: descriptionSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptsourceCreate", actual: "\(descriptionSource)"))
                }
                let _result = ConceptsourceCreate(name: name, description: description)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hl7Code"] as AnyObject?) {
                case let .success(value): _result.hl7Code = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uniqueId"] as AnyObject?) {
                case let .success(value): _result.uniqueId = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptsourceCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptsourceCreateFull]
        Decoders.addDecoder(clazz: [ConceptsourceCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptsourceCreateFull]> in
            return Decoders.decode(clazz: [ConceptsourceCreateFull].self, source: source)
        }

        // Decoder for ConceptsourceCreateFull
        Decoders.addDecoder(clazz: ConceptsourceCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptsourceCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptsourceCreateFull", actual: "\(nameSource)"))
                }
                guard let descriptionSource = sourceDictionary["description"] as AnyObject? else {
                    return .failure(.missingKey(key: "description"))
                }
                guard let description = Decoders.decode(clazz: String.self.self, source: descriptionSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptsourceCreateFull", actual: "\(descriptionSource)"))
                }
                let _result = ConceptsourceCreateFull(name: name, description: description)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hl7Code"] as AnyObject?) {
                case let .success(value): _result.hl7Code = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uniqueId"] as AnyObject?) {
                case let .success(value): _result.uniqueId = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptsourceCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptsourceGet]
        Decoders.addDecoder(clazz: [ConceptsourceGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptsourceGet]> in
            return Decoders.decode(clazz: [ConceptsourceGet].self, source: source)
        }

        // Decoder for ConceptsourceGet
        Decoders.addDecoder(clazz: ConceptsourceGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptsourceGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptsourceGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hl7Code"] as AnyObject?) {
                case let .success(value): _result.hl7Code = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uniqueId"] as AnyObject?) {
                case let .success(value): _result.uniqueId = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptsourceGet", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptsourceGetFull]
        Decoders.addDecoder(clazz: [ConceptsourceGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptsourceGetFull]> in
            return Decoders.decode(clazz: [ConceptsourceGetFull].self, source: source)
        }

        // Decoder for ConceptsourceGetFull
        Decoders.addDecoder(clazz: ConceptsourceGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptsourceGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptsourceGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hl7Code"] as AnyObject?) {
                case let .success(value): _result.hl7Code = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uniqueId"] as AnyObject?) {
                case let .success(value): _result.uniqueId = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptsourceGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptsourceGetRef]
        Decoders.addDecoder(clazz: [ConceptsourceGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptsourceGetRef]> in
            return Decoders.decode(clazz: [ConceptsourceGetRef].self, source: source)
        }

        // Decoder for ConceptsourceGetRef
        Decoders.addDecoder(clazz: ConceptsourceGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptsourceGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptsourceGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hl7Code"] as AnyObject?) {
                case let .success(value): _result.hl7Code = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptsourceGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptsourceUpdate]
        Decoders.addDecoder(clazz: [ConceptsourceUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptsourceUpdate]> in
            return Decoders.decode(clazz: [ConceptsourceUpdate].self, source: source)
        }

        // Decoder for ConceptsourceUpdate
        Decoders.addDecoder(clazz: ConceptsourceUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptsourceUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptsourceUpdate", actual: "\(nameSource)"))
                }
                guard let descriptionSource = sourceDictionary["description"] as AnyObject? else {
                    return .failure(.missingKey(key: "description"))
                }
                guard let description = Decoders.decode(clazz: String.self.self, source: descriptionSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptsourceUpdate", actual: "\(descriptionSource)"))
                }
                let _result = ConceptsourceUpdate(name: name, description: description)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hl7Code"] as AnyObject?) {
                case let .success(value): _result.hl7Code = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uniqueId"] as AnyObject?) {
                case let .success(value): _result.uniqueId = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptsourceUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptstopwordCreate]
        Decoders.addDecoder(clazz: [ConceptstopwordCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptstopwordCreate]> in
            return Decoders.decode(clazz: [ConceptstopwordCreate].self, source: source)
        }

        // Decoder for ConceptstopwordCreate
        Decoders.addDecoder(clazz: ConceptstopwordCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptstopwordCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let valueSource = sourceDictionary["value"] as AnyObject? else {
                    return .failure(.missingKey(key: "value"))
                }
                guard let value = Decoders.decode(clazz: String.self.self, source: valueSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptstopwordCreate", actual: "\(valueSource)"))
                }
                let _result = ConceptstopwordCreate(value: value)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["locale"] as AnyObject?) {
                case let .success(value): _result.locale = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptstopwordCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptstopwordCreateFull]
        Decoders.addDecoder(clazz: [ConceptstopwordCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptstopwordCreateFull]> in
            return Decoders.decode(clazz: [ConceptstopwordCreateFull].self, source: source)
        }

        // Decoder for ConceptstopwordCreateFull
        Decoders.addDecoder(clazz: ConceptstopwordCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptstopwordCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let valueSource = sourceDictionary["value"] as AnyObject? else {
                    return .failure(.missingKey(key: "value"))
                }
                guard let value = Decoders.decode(clazz: String.self.self, source: valueSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptstopwordCreateFull", actual: "\(valueSource)"))
                }
                let _result = ConceptstopwordCreateFull(value: value)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["locale"] as AnyObject?) {
                case let .success(value): _result.locale = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptstopwordCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptstopwordGet]
        Decoders.addDecoder(clazz: [ConceptstopwordGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptstopwordGet]> in
            return Decoders.decode(clazz: [ConceptstopwordGet].self, source: source)
        }

        // Decoder for ConceptstopwordGet
        Decoders.addDecoder(clazz: ConceptstopwordGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptstopwordGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptstopwordGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["locale"] as AnyObject?) {
                case let .success(value): _result.locale = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptstopwordGet", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptstopwordGetFull]
        Decoders.addDecoder(clazz: [ConceptstopwordGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptstopwordGetFull]> in
            return Decoders.decode(clazz: [ConceptstopwordGetFull].self, source: source)
        }

        // Decoder for ConceptstopwordGetFull
        Decoders.addDecoder(clazz: ConceptstopwordGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptstopwordGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptstopwordGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["locale"] as AnyObject?) {
                case let .success(value): _result.locale = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptstopwordGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptstopwordGetRef]
        Decoders.addDecoder(clazz: [ConceptstopwordGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptstopwordGetRef]> in
            return Decoders.decode(clazz: [ConceptstopwordGetRef].self, source: source)
        }

        // Decoder for ConceptstopwordGetRef
        Decoders.addDecoder(clazz: ConceptstopwordGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptstopwordGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ConceptstopwordGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptstopwordGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptstopwordUpdate]
        Decoders.addDecoder(clazz: [ConceptstopwordUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptstopwordUpdate]> in
            return Decoders.decode(clazz: [ConceptstopwordUpdate].self, source: source)
        }

        // Decoder for ConceptstopwordUpdate
        Decoders.addDecoder(clazz: ConceptstopwordUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptstopwordUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let valueSource = sourceDictionary["value"] as AnyObject? else {
                    return .failure(.missingKey(key: "value"))
                }
                guard let value = Decoders.decode(clazz: String.self.self, source: valueSource).value else {
                    return .failure(.typeMismatch(expected: "ConceptstopwordUpdate", actual: "\(valueSource)"))
                }
                let _result = ConceptstopwordUpdate(value: value)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["locale"] as AnyObject?) {
                case let .success(value): _result.locale = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptstopwordUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [CustomdatatypeGet]
        Decoders.addDecoder(clazz: [CustomdatatypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomdatatypeGet]> in
            return Decoders.decode(clazz: [CustomdatatypeGet].self, source: source)
        }

        // Decoder for CustomdatatypeGet
        Decoders.addDecoder(clazz: CustomdatatypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomdatatypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = CustomdatatypeGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [CustomdatatypeHandlersGetRef].self, source: sourceDictionary["handlers"] as AnyObject?) {
                case let .success(value): _result.handlers = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomdatatypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [CustomdatatypeGetFull]
        Decoders.addDecoder(clazz: [CustomdatatypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomdatatypeGetFull]> in
            return Decoders.decode(clazz: [CustomdatatypeGetFull].self, source: source)
        }

        // Decoder for CustomdatatypeGetFull
        Decoders.addDecoder(clazz: CustomdatatypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomdatatypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = CustomdatatypeGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [CustomdatatypeHandlersGet].self, source: sourceDictionary["handlers"] as AnyObject?) {
                case let .success(value): _result.handlers = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomdatatypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [CustomdatatypeGetRef]
        Decoders.addDecoder(clazz: [CustomdatatypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomdatatypeGetRef]> in
            return Decoders.decode(clazz: [CustomdatatypeGetRef].self, source: source)
        }

        // Decoder for CustomdatatypeGetRef
        Decoders.addDecoder(clazz: CustomdatatypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomdatatypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = CustomdatatypeGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomdatatypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [CustomdatatypeHandlersGet]
        Decoders.addDecoder(clazz: [CustomdatatypeHandlersGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomdatatypeHandlersGet]> in
            return Decoders.decode(clazz: [CustomdatatypeHandlersGet].self, source: source)
        }

        // Decoder for CustomdatatypeHandlersGet
        Decoders.addDecoder(clazz: CustomdatatypeHandlersGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomdatatypeHandlersGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = CustomdatatypeHandlersGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerClassname"] as AnyObject?) {
                case let .success(value): _result.handlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomdatatypeHandlersGet", actual: "\(source)"))
            }
        }
        // Decoder for [CustomdatatypeHandlersGetFull]
        Decoders.addDecoder(clazz: [CustomdatatypeHandlersGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomdatatypeHandlersGetFull]> in
            return Decoders.decode(clazz: [CustomdatatypeHandlersGetFull].self, source: source)
        }

        // Decoder for CustomdatatypeHandlersGetFull
        Decoders.addDecoder(clazz: CustomdatatypeHandlersGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomdatatypeHandlersGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = CustomdatatypeHandlersGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerClassname"] as AnyObject?) {
                case let .success(value): _result.handlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomdatatypeHandlersGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [CustomdatatypeHandlersGetRef]
        Decoders.addDecoder(clazz: [CustomdatatypeHandlersGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomdatatypeHandlersGetRef]> in
            return Decoders.decode(clazz: [CustomdatatypeHandlersGetRef].self, source: source)
        }

        // Decoder for CustomdatatypeHandlersGetRef
        Decoders.addDecoder(clazz: CustomdatatypeHandlersGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomdatatypeHandlersGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = CustomdatatypeHandlersGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomdatatypeHandlersGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [DrugCreate]
        Decoders.addDecoder(clazz: [DrugCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DrugCreate]> in
            return Decoders.decode(clazz: [DrugCreate].self, source: source)
        }

        // Decoder for DrugCreate
        Decoders.addDecoder(clazz: DrugCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DrugCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "DrugCreate", actual: "\(nameSource)"))
                }
                guard let combinationSource = sourceDictionary["combination"] as AnyObject? else {
                    return .failure(.missingKey(key: "combination"))
                }
                guard let combination = Decoders.decode(clazz: Bool.self.self, source: combinationSource).value else {
                    return .failure(.typeMismatch(expected: "DrugCreate", actual: "\(combinationSource)"))
                }
                guard let conceptSource = sourceDictionary["concept"] as AnyObject? else {
                    return .failure(.missingKey(key: "concept"))
                }
                guard let concept = Decoders.decode(clazz: String.self.self, source: conceptSource).value else {
                    return .failure(.typeMismatch(expected: "DrugCreate", actual: "\(conceptSource)"))
                }
                let _result = DrugCreate(name: name, combination: combination, concept: concept)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["doseStrength"] as AnyObject?) {
                case let .success(value): _result.doseStrength = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["maximumDailyDose"] as AnyObject?) {
                case let .success(value): _result.maximumDailyDose = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["minimumDailyDose"] as AnyObject?) {
                case let .success(value): _result.minimumDailyDose = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["units"] as AnyObject?) {
                case let .success(value): _result.units = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["dosageForm"] as AnyObject?) {
                case let .success(value): _result.dosageForm = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["route"] as AnyObject?) {
                case let .success(value): _result.route = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DrugCreate", actual: "\(source)"))
            }
        }
        // Decoder for [DrugCreateFull]
        Decoders.addDecoder(clazz: [DrugCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DrugCreateFull]> in
            return Decoders.decode(clazz: [DrugCreateFull].self, source: source)
        }

        // Decoder for DrugCreateFull
        Decoders.addDecoder(clazz: DrugCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DrugCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "DrugCreateFull", actual: "\(nameSource)"))
                }
                guard let combinationSource = sourceDictionary["combination"] as AnyObject? else {
                    return .failure(.missingKey(key: "combination"))
                }
                guard let combination = Decoders.decode(clazz: Bool.self.self, source: combinationSource).value else {
                    return .failure(.typeMismatch(expected: "DrugCreateFull", actual: "\(combinationSource)"))
                }
                guard let conceptSource = sourceDictionary["concept"] as AnyObject? else {
                    return .failure(.missingKey(key: "concept"))
                }
                guard let concept = Decoders.decode(clazz: ConceptCreate.self.self, source: conceptSource).value else {
                    return .failure(.typeMismatch(expected: "DrugCreateFull", actual: "\(conceptSource)"))
                }
                let _result = DrugCreateFull(name: name, combination: combination, concept: concept)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["doseStrength"] as AnyObject?) {
                case let .success(value): _result.doseStrength = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["maximumDailyDose"] as AnyObject?) {
                case let .success(value): _result.maximumDailyDose = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["minimumDailyDose"] as AnyObject?) {
                case let .success(value): _result.minimumDailyDose = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["units"] as AnyObject?) {
                case let .success(value): _result.units = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptCreate.self, source: sourceDictionary["dosageForm"] as AnyObject?) {
                case let .success(value): _result.dosageForm = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptCreate.self, source: sourceDictionary["route"] as AnyObject?) {
                case let .success(value): _result.route = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DrugCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [DrugGet]
        Decoders.addDecoder(clazz: [DrugGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DrugGet]> in
            return Decoders.decode(clazz: [DrugGet].self, source: source)
        }

        // Decoder for DrugGet
        Decoders.addDecoder(clazz: DrugGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DrugGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = DrugGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["doseStrength"] as AnyObject?) {
                case let .success(value): _result.doseStrength = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["maximumDailyDose"] as AnyObject?) {
                case let .success(value): _result.maximumDailyDose = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["minimumDailyDose"] as AnyObject?) {
                case let .success(value): _result.minimumDailyDose = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["units"] as AnyObject?) {
                case let .success(value): _result.units = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["combination"] as AnyObject?) {
                case let .success(value): _result.combination = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["dosageForm"] as AnyObject?) {
                case let .success(value): _result.dosageForm = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["route"] as AnyObject?) {
                case let .success(value): _result.route = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DrugGet", actual: "\(source)"))
            }
        }
        // Decoder for [DrugGetFull]
        Decoders.addDecoder(clazz: [DrugGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DrugGetFull]> in
            return Decoders.decode(clazz: [DrugGetFull].self, source: source)
        }

        // Decoder for DrugGetFull
        Decoders.addDecoder(clazz: DrugGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DrugGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = DrugGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["doseStrength"] as AnyObject?) {
                case let .success(value): _result.doseStrength = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["maximumDailyDose"] as AnyObject?) {
                case let .success(value): _result.maximumDailyDose = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["minimumDailyDose"] as AnyObject?) {
                case let .success(value): _result.minimumDailyDose = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["units"] as AnyObject?) {
                case let .success(value): _result.units = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["combination"] as AnyObject?) {
                case let .success(value): _result.combination = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["dosageForm"] as AnyObject?) {
                case let .success(value): _result.dosageForm = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["route"] as AnyObject?) {
                case let .success(value): _result.route = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DrugGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [DrugGetRef]
        Decoders.addDecoder(clazz: [DrugGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DrugGetRef]> in
            return Decoders.decode(clazz: [DrugGetRef].self, source: source)
        }

        // Decoder for DrugGetRef
        Decoders.addDecoder(clazz: DrugGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DrugGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = DrugGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DrugGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [DrugIngredientCreate]
        Decoders.addDecoder(clazz: [DrugIngredientCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DrugIngredientCreate]> in
            return Decoders.decode(clazz: [DrugIngredientCreate].self, source: source)
        }

        // Decoder for DrugIngredientCreate
        Decoders.addDecoder(clazz: DrugIngredientCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DrugIngredientCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let ingredientSource = sourceDictionary["ingredient"] as AnyObject? else {
                    return .failure(.missingKey(key: "ingredient"))
                }
                guard let ingredient = Decoders.decode(clazz: String.self.self, source: ingredientSource).value else {
                    return .failure(.typeMismatch(expected: "DrugIngredientCreate", actual: "\(ingredientSource)"))
                }
                let _result = DrugIngredientCreate(ingredient: ingredient)
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["strength"] as AnyObject?) {
                case let .success(value): _result.strength = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["units"] as AnyObject?) {
                case let .success(value): _result.units = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DrugIngredientCreate", actual: "\(source)"))
            }
        }
        // Decoder for [DrugIngredientCreateFull]
        Decoders.addDecoder(clazz: [DrugIngredientCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DrugIngredientCreateFull]> in
            return Decoders.decode(clazz: [DrugIngredientCreateFull].self, source: source)
        }

        // Decoder for DrugIngredientCreateFull
        Decoders.addDecoder(clazz: DrugIngredientCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DrugIngredientCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let ingredientSource = sourceDictionary["ingredient"] as AnyObject? else {
                    return .failure(.missingKey(key: "ingredient"))
                }
                guard let ingredient = Decoders.decode(clazz: String.self.self, source: ingredientSource).value else {
                    return .failure(.typeMismatch(expected: "DrugIngredientCreateFull", actual: "\(ingredientSource)"))
                }
                let _result = DrugIngredientCreateFull(ingredient: ingredient)
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["strength"] as AnyObject?) {
                case let .success(value): _result.strength = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["units"] as AnyObject?) {
                case let .success(value): _result.units = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DrugIngredientCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [DrugIngredientGet]
        Decoders.addDecoder(clazz: [DrugIngredientGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DrugIngredientGet]> in
            return Decoders.decode(clazz: [DrugIngredientGet].self, source: source)
        }

        // Decoder for DrugIngredientGet
        Decoders.addDecoder(clazz: DrugIngredientGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DrugIngredientGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = DrugIngredientGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["strength"] as AnyObject?) {
                case let .success(value): _result.strength = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["ingredient"] as AnyObject?) {
                case let .success(value): _result.ingredient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["units"] as AnyObject?) {
                case let .success(value): _result.units = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DrugIngredientGet", actual: "\(source)"))
            }
        }
        // Decoder for [DrugIngredientGetFull]
        Decoders.addDecoder(clazz: [DrugIngredientGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DrugIngredientGetFull]> in
            return Decoders.decode(clazz: [DrugIngredientGetFull].self, source: source)
        }

        // Decoder for DrugIngredientGetFull
        Decoders.addDecoder(clazz: DrugIngredientGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DrugIngredientGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = DrugIngredientGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["strength"] as AnyObject?) {
                case let .success(value): _result.strength = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["ingredient"] as AnyObject?) {
                case let .success(value): _result.ingredient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["units"] as AnyObject?) {
                case let .success(value): _result.units = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DrugIngredientGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [DrugIngredientGetRef]
        Decoders.addDecoder(clazz: [DrugIngredientGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DrugIngredientGetRef]> in
            return Decoders.decode(clazz: [DrugIngredientGetRef].self, source: source)
        }

        // Decoder for DrugIngredientGetRef
        Decoders.addDecoder(clazz: DrugIngredientGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DrugIngredientGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = DrugIngredientGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DrugIngredientGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [DrugIngredientUpdate]
        Decoders.addDecoder(clazz: [DrugIngredientUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DrugIngredientUpdate]> in
            return Decoders.decode(clazz: [DrugIngredientUpdate].self, source: source)
        }

        // Decoder for DrugIngredientUpdate
        Decoders.addDecoder(clazz: DrugIngredientUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DrugIngredientUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let ingredientSource = sourceDictionary["ingredient"] as AnyObject? else {
                    return .failure(.missingKey(key: "ingredient"))
                }
                guard let ingredient = Decoders.decode(clazz: String.self.self, source: ingredientSource).value else {
                    return .failure(.typeMismatch(expected: "DrugIngredientUpdate", actual: "\(ingredientSource)"))
                }
                let _result = DrugIngredientUpdate(ingredient: ingredient)
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["strength"] as AnyObject?) {
                case let .success(value): _result.strength = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["units"] as AnyObject?) {
                case let .success(value): _result.units = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DrugIngredientUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [DrugUpdate]
        Decoders.addDecoder(clazz: [DrugUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DrugUpdate]> in
            return Decoders.decode(clazz: [DrugUpdate].self, source: source)
        }

        // Decoder for DrugUpdate
        Decoders.addDecoder(clazz: DrugUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DrugUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "DrugUpdate", actual: "\(nameSource)"))
                }
                guard let combinationSource = sourceDictionary["combination"] as AnyObject? else {
                    return .failure(.missingKey(key: "combination"))
                }
                guard let combination = Decoders.decode(clazz: Bool.self.self, source: combinationSource).value else {
                    return .failure(.typeMismatch(expected: "DrugUpdate", actual: "\(combinationSource)"))
                }
                guard let conceptSource = sourceDictionary["concept"] as AnyObject? else {
                    return .failure(.missingKey(key: "concept"))
                }
                guard let concept = Decoders.decode(clazz: String.self.self, source: conceptSource).value else {
                    return .failure(.typeMismatch(expected: "DrugUpdate", actual: "\(conceptSource)"))
                }
                let _result = DrugUpdate(name: name, combination: combination, concept: concept)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["doseStrength"] as AnyObject?) {
                case let .success(value): _result.doseStrength = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["maximumDailyDose"] as AnyObject?) {
                case let .success(value): _result.maximumDailyDose = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["minimumDailyDose"] as AnyObject?) {
                case let .success(value): _result.minimumDailyDose = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["units"] as AnyObject?) {
                case let .success(value): _result.units = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["dosageForm"] as AnyObject?) {
                case let .success(value): _result.dosageForm = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["route"] as AnyObject?) {
                case let .success(value): _result.route = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DrugUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterCreate]
        Decoders.addDecoder(clazz: [EncounterCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterCreate]> in
            return Decoders.decode(clazz: [EncounterCreate].self, source: source)
        }

        // Decoder for EncounterCreate
        Decoders.addDecoder(clazz: EncounterCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let patientSource = sourceDictionary["patient"] as AnyObject? else {
                    return .failure(.missingKey(key: "patient"))
                }
                guard let patient = Decoders.decode(clazz: PatientCreate.self.self, source: patientSource).value else {
                    return .failure(.typeMismatch(expected: "EncounterCreate", actual: "\(patientSource)"))
                }
                guard let encounterTypeSource = sourceDictionary["encounterType"] as AnyObject? else {
                    return .failure(.missingKey(key: "encounterType"))
                }
                guard let encounterType = Decoders.decode(clazz: EncountertypeCreate.self.self, source: encounterTypeSource).value else {
                    return .failure(.typeMismatch(expected: "EncounterCreate", actual: "\(encounterTypeSource)"))
                }
                let _result = EncounterCreate(patient: patient, encounterType: encounterType)
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["encounterDatetime"] as AnyObject?) {
                case let .success(value): _result.encounterDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationCreate.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FormCreate.self, source: sourceDictionary["form"] as AnyObject?) {
                case let .success(value): _result.form = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["provider"] as AnyObject?) {
                case let .success(value): _result.provider = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [OrderCreate].self, source: sourceDictionary["orders"] as AnyObject?) {
                case let .success(value): _result.orders = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ObsCreate].self, source: sourceDictionary["obs"] as AnyObject?) {
                case let .success(value): _result.obs = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterCreate", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterCreateFull]
        Decoders.addDecoder(clazz: [EncounterCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterCreateFull]> in
            return Decoders.decode(clazz: [EncounterCreateFull].self, source: source)
        }

        // Decoder for EncounterCreateFull
        Decoders.addDecoder(clazz: EncounterCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let patientSource = sourceDictionary["patient"] as AnyObject? else {
                    return .failure(.missingKey(key: "patient"))
                }
                guard let patient = Decoders.decode(clazz: PatientCreate.self.self, source: patientSource).value else {
                    return .failure(.typeMismatch(expected: "EncounterCreateFull", actual: "\(patientSource)"))
                }
                guard let encounterTypeSource = sourceDictionary["encounterType"] as AnyObject? else {
                    return .failure(.missingKey(key: "encounterType"))
                }
                guard let encounterType = Decoders.decode(clazz: EncountertypeCreate.self.self, source: encounterTypeSource).value else {
                    return .failure(.typeMismatch(expected: "EncounterCreateFull", actual: "\(encounterTypeSource)"))
                }
                let _result = EncounterCreateFull(patient: patient, encounterType: encounterType)
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["encounterDatetime"] as AnyObject?) {
                case let .success(value): _result.encounterDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationCreate.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FormCreate.self, source: sourceDictionary["form"] as AnyObject?) {
                case let .success(value): _result.form = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["provider"] as AnyObject?) {
                case let .success(value): _result.provider = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [OrderCreate].self, source: sourceDictionary["orders"] as AnyObject?) {
                case let .success(value): _result.orders = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ObsCreate].self, source: sourceDictionary["obs"] as AnyObject?) {
                case let .success(value): _result.obs = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterEncounterproviderCreate]
        Decoders.addDecoder(clazz: [EncounterEncounterproviderCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterEncounterproviderCreate]> in
            return Decoders.decode(clazz: [EncounterEncounterproviderCreate].self, source: source)
        }

        // Decoder for EncounterEncounterproviderCreate
        Decoders.addDecoder(clazz: EncounterEncounterproviderCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterEncounterproviderCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = EncounterEncounterproviderCreate()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["provider"] as AnyObject?) {
                case let .success(value): _result.provider = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["encounterRole"] as AnyObject?) {
                case let .success(value): _result.encounterRole = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["encounter"] as AnyObject?) {
                case let .success(value): _result.encounter = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterEncounterproviderCreate", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterEncounterproviderCreateFull]
        Decoders.addDecoder(clazz: [EncounterEncounterproviderCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterEncounterproviderCreateFull]> in
            return Decoders.decode(clazz: [EncounterEncounterproviderCreateFull].self, source: source)
        }

        // Decoder for EncounterEncounterproviderCreateFull
        Decoders.addDecoder(clazz: EncounterEncounterproviderCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterEncounterproviderCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = EncounterEncounterproviderCreateFull()
                switch Decoders.decodeOptional(clazz: ProviderCreate.self, source: sourceDictionary["provider"] as AnyObject?) {
                case let .success(value): _result.provider = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: EncounterroleCreate.self, source: sourceDictionary["encounterRole"] as AnyObject?) {
                case let .success(value): _result.encounterRole = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: EncounterCreate.self, source: sourceDictionary["encounter"] as AnyObject?) {
                case let .success(value): _result.encounter = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterEncounterproviderCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterEncounterproviderGet]
        Decoders.addDecoder(clazz: [EncounterEncounterproviderGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterEncounterproviderGet]> in
            return Decoders.decode(clazz: [EncounterEncounterproviderGet].self, source: source)
        }

        // Decoder for EncounterEncounterproviderGet
        Decoders.addDecoder(clazz: EncounterEncounterproviderGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterEncounterproviderGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = EncounterEncounterproviderGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ProviderGetRef.self, source: sourceDictionary["provider"] as AnyObject?) {
                case let .success(value): _result.provider = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: EncounterroleGetRef.self, source: sourceDictionary["encounterRole"] as AnyObject?) {
                case let .success(value): _result.encounterRole = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterEncounterproviderGet", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterEncounterproviderGetFull]
        Decoders.addDecoder(clazz: [EncounterEncounterproviderGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterEncounterproviderGetFull]> in
            return Decoders.decode(clazz: [EncounterEncounterproviderGetFull].self, source: source)
        }

        // Decoder for EncounterEncounterproviderGetFull
        Decoders.addDecoder(clazz: EncounterEncounterproviderGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterEncounterproviderGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = EncounterEncounterproviderGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ProviderGet.self, source: sourceDictionary["provider"] as AnyObject?) {
                case let .success(value): _result.provider = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: EncounterroleGet.self, source: sourceDictionary["encounterRole"] as AnyObject?) {
                case let .success(value): _result.encounterRole = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterEncounterproviderGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterEncounterproviderGetRef]
        Decoders.addDecoder(clazz: [EncounterEncounterproviderGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterEncounterproviderGetRef]> in
            return Decoders.decode(clazz: [EncounterEncounterproviderGetRef].self, source: source)
        }

        // Decoder for EncounterEncounterproviderGetRef
        Decoders.addDecoder(clazz: EncounterEncounterproviderGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterEncounterproviderGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = EncounterEncounterproviderGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterEncounterproviderGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterEncounterproviderUpdate]
        Decoders.addDecoder(clazz: [EncounterEncounterproviderUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterEncounterproviderUpdate]> in
            return Decoders.decode(clazz: [EncounterEncounterproviderUpdate].self, source: source)
        }

        // Decoder for EncounterEncounterproviderUpdate
        Decoders.addDecoder(clazz: EncounterEncounterproviderUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterEncounterproviderUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = EncounterEncounterproviderUpdate()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["encounterRole"] as AnyObject?) {
                case let .success(value): _result.encounterRole = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["voidReason"] as AnyObject?) {
                case let .success(value): _result.voidReason = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterEncounterproviderUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterGet]
        Decoders.addDecoder(clazz: [EncounterGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterGet]> in
            return Decoders.decode(clazz: [EncounterGet].self, source: source)
        }

        // Decoder for EncounterGet
        Decoders.addDecoder(clazz: EncounterGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = EncounterGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["encounterDatetime"] as AnyObject?) {
                case let .success(value): _result.encounterDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["provider"] as AnyObject?) {
                case let .success(value): _result.provider = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientGetRef.self, source: sourceDictionary["patient"] as AnyObject?) {
                case let .success(value): _result.patient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationGetRef.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FormGetRef.self, source: sourceDictionary["form"] as AnyObject?) {
                case let .success(value): _result.form = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: EncountertypeGetRef.self, source: sourceDictionary["encounterType"] as AnyObject?) {
                case let .success(value): _result.encounterType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ObsGetRef].self, source: sourceDictionary["obs"] as AnyObject?) {
                case let .success(value): _result.obs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [OrderGetRef].self, source: sourceDictionary["orders"] as AnyObject?) {
                case let .success(value): _result.orders = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterGet", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterGetFull]
        Decoders.addDecoder(clazz: [EncounterGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterGetFull]> in
            return Decoders.decode(clazz: [EncounterGetFull].self, source: source)
        }

        // Decoder for EncounterGetFull
        Decoders.addDecoder(clazz: EncounterGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = EncounterGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["encounterDatetime"] as AnyObject?) {
                case let .success(value): _result.encounterDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["provider"] as AnyObject?) {
                case let .success(value): _result.provider = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientGet.self, source: sourceDictionary["patient"] as AnyObject?) {
                case let .success(value): _result.patient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationGet.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FormGet.self, source: sourceDictionary["form"] as AnyObject?) {
                case let .success(value): _result.form = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: EncountertypeGet.self, source: sourceDictionary["encounterType"] as AnyObject?) {
                case let .success(value): _result.encounterType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ObsGet].self, source: sourceDictionary["obs"] as AnyObject?) {
                case let .success(value): _result.obs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [OrderGet].self, source: sourceDictionary["orders"] as AnyObject?) {
                case let .success(value): _result.orders = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterGetRef]
        Decoders.addDecoder(clazz: [EncounterGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterGetRef]> in
            return Decoders.decode(clazz: [EncounterGetRef].self, source: source)
        }

        // Decoder for EncounterGetRef
        Decoders.addDecoder(clazz: EncounterGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = EncounterGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterUpdate]
        Decoders.addDecoder(clazz: [EncounterUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterUpdate]> in
            return Decoders.decode(clazz: [EncounterUpdate].self, source: source)
        }

        // Decoder for EncounterUpdate
        Decoders.addDecoder(clazz: EncounterUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let patientSource = sourceDictionary["patient"] as AnyObject? else {
                    return .failure(.missingKey(key: "patient"))
                }
                guard let patient = Decoders.decode(clazz: PatientCreate.self.self, source: patientSource).value else {
                    return .failure(.typeMismatch(expected: "EncounterUpdate", actual: "\(patientSource)"))
                }
                guard let encounterTypeSource = sourceDictionary["encounterType"] as AnyObject? else {
                    return .failure(.missingKey(key: "encounterType"))
                }
                guard let encounterType = Decoders.decode(clazz: EncountertypeCreate.self.self, source: encounterTypeSource).value else {
                    return .failure(.typeMismatch(expected: "EncounterUpdate", actual: "\(encounterTypeSource)"))
                }
                let _result = EncounterUpdate(patient: patient, encounterType: encounterType)
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["encounterDatetime"] as AnyObject?) {
                case let .success(value): _result.encounterDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationCreate.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FormCreate.self, source: sourceDictionary["form"] as AnyObject?) {
                case let .success(value): _result.form = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["provider"] as AnyObject?) {
                case let .success(value): _result.provider = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [OrderCreate].self, source: sourceDictionary["orders"] as AnyObject?) {
                case let .success(value): _result.orders = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ObsCreate].self, source: sourceDictionary["obs"] as AnyObject?) {
                case let .success(value): _result.obs = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterroleCreate]
        Decoders.addDecoder(clazz: [EncounterroleCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterroleCreate]> in
            return Decoders.decode(clazz: [EncounterroleCreate].self, source: source)
        }

        // Decoder for EncounterroleCreate
        Decoders.addDecoder(clazz: EncounterroleCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterroleCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "EncounterroleCreate", actual: "\(nameSource)"))
                }
                let _result = EncounterroleCreate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterroleCreate", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterroleCreateFull]
        Decoders.addDecoder(clazz: [EncounterroleCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterroleCreateFull]> in
            return Decoders.decode(clazz: [EncounterroleCreateFull].self, source: source)
        }

        // Decoder for EncounterroleCreateFull
        Decoders.addDecoder(clazz: EncounterroleCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterroleCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "EncounterroleCreateFull", actual: "\(nameSource)"))
                }
                let _result = EncounterroleCreateFull(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterroleCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterroleGet]
        Decoders.addDecoder(clazz: [EncounterroleGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterroleGet]> in
            return Decoders.decode(clazz: [EncounterroleGet].self, source: source)
        }

        // Decoder for EncounterroleGet
        Decoders.addDecoder(clazz: EncounterroleGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterroleGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = EncounterroleGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterroleGet", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterroleGetFull]
        Decoders.addDecoder(clazz: [EncounterroleGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterroleGetFull]> in
            return Decoders.decode(clazz: [EncounterroleGetFull].self, source: source)
        }

        // Decoder for EncounterroleGetFull
        Decoders.addDecoder(clazz: EncounterroleGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterroleGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = EncounterroleGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterroleGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterroleGetRef]
        Decoders.addDecoder(clazz: [EncounterroleGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterroleGetRef]> in
            return Decoders.decode(clazz: [EncounterroleGetRef].self, source: source)
        }

        // Decoder for EncounterroleGetRef
        Decoders.addDecoder(clazz: EncounterroleGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterroleGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = EncounterroleGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterroleGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterroleUpdate]
        Decoders.addDecoder(clazz: [EncounterroleUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterroleUpdate]> in
            return Decoders.decode(clazz: [EncounterroleUpdate].self, source: source)
        }

        // Decoder for EncounterroleUpdate
        Decoders.addDecoder(clazz: EncounterroleUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterroleUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "EncounterroleUpdate", actual: "\(nameSource)"))
                }
                let _result = EncounterroleUpdate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterroleUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [EncountertypeCreate]
        Decoders.addDecoder(clazz: [EncountertypeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncountertypeCreate]> in
            return Decoders.decode(clazz: [EncountertypeCreate].self, source: source)
        }

        // Decoder for EncountertypeCreate
        Decoders.addDecoder(clazz: EncountertypeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncountertypeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "EncountertypeCreate", actual: "\(nameSource)"))
                }
                guard let descriptionSource = sourceDictionary["description"] as AnyObject? else {
                    return .failure(.missingKey(key: "description"))
                }
                guard let description = Decoders.decode(clazz: String.self.self, source: descriptionSource).value else {
                    return .failure(.typeMismatch(expected: "EncountertypeCreate", actual: "\(descriptionSource)"))
                }
                let _result = EncountertypeCreate(name: name, description: description)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncountertypeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [EncountertypeCreateFull]
        Decoders.addDecoder(clazz: [EncountertypeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncountertypeCreateFull]> in
            return Decoders.decode(clazz: [EncountertypeCreateFull].self, source: source)
        }

        // Decoder for EncountertypeCreateFull
        Decoders.addDecoder(clazz: EncountertypeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncountertypeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "EncountertypeCreateFull", actual: "\(nameSource)"))
                }
                guard let descriptionSource = sourceDictionary["description"] as AnyObject? else {
                    return .failure(.missingKey(key: "description"))
                }
                guard let description = Decoders.decode(clazz: String.self.self, source: descriptionSource).value else {
                    return .failure(.typeMismatch(expected: "EncountertypeCreateFull", actual: "\(descriptionSource)"))
                }
                let _result = EncountertypeCreateFull(name: name, description: description)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncountertypeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [EncountertypeGet]
        Decoders.addDecoder(clazz: [EncountertypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncountertypeGet]> in
            return Decoders.decode(clazz: [EncountertypeGet].self, source: source)
        }

        // Decoder for EncountertypeGet
        Decoders.addDecoder(clazz: EncountertypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncountertypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = EncountertypeGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncountertypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [EncountertypeGetFull]
        Decoders.addDecoder(clazz: [EncountertypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncountertypeGetFull]> in
            return Decoders.decode(clazz: [EncountertypeGetFull].self, source: source)
        }

        // Decoder for EncountertypeGetFull
        Decoders.addDecoder(clazz: EncountertypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncountertypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = EncountertypeGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncountertypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [EncountertypeGetRef]
        Decoders.addDecoder(clazz: [EncountertypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncountertypeGetRef]> in
            return Decoders.decode(clazz: [EncountertypeGetRef].self, source: source)
        }

        // Decoder for EncountertypeGetRef
        Decoders.addDecoder(clazz: EncountertypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncountertypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = EncountertypeGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncountertypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [EncountertypeUpdate]
        Decoders.addDecoder(clazz: [EncountertypeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncountertypeUpdate]> in
            return Decoders.decode(clazz: [EncountertypeUpdate].self, source: source)
        }

        // Decoder for EncountertypeUpdate
        Decoders.addDecoder(clazz: EncountertypeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncountertypeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "EncountertypeUpdate", actual: "\(nameSource)"))
                }
                guard let descriptionSource = sourceDictionary["description"] as AnyObject? else {
                    return .failure(.missingKey(key: "description"))
                }
                guard let description = Decoders.decode(clazz: String.self.self, source: descriptionSource).value else {
                    return .failure(.typeMismatch(expected: "EncountertypeUpdate", actual: "\(descriptionSource)"))
                }
                let _result = EncountertypeUpdate(name: name, description: description)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncountertypeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ExtensionGet]
        Decoders.addDecoder(clazz: [ExtensionGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ExtensionGet]> in
            return Decoders.decode(clazz: [ExtensionGet].self, source: source)
        }

        // Decoder for ExtensionGet
        Decoders.addDecoder(clazz: ExtensionGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ExtensionGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ExtensionGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["appId"] as AnyObject?) {
                case let .success(value): _result.appId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["extensionPointId"] as AnyObject?) {
                case let .success(value): _result.extensionPointId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                case let .success(value): _result.type = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["label"] as AnyObject?) {
                case let .success(value): _result.label = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["url"] as AnyObject?) {
                case let .success(value): _result.url = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["icon"] as AnyObject?) {
                case let .success(value): _result.icon = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["order"] as AnyObject?) {
                case let .success(value): _result.order = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["requiredPrivilege"] as AnyObject?) {
                case let .success(value): _result.requiredPrivilege = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["featureToggle"] as AnyObject?) {
                case let .success(value): _result.featureToggle = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["require"] as AnyObject?) {
                case let .success(value): _result.require = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["script"] as AnyObject?) {
                case let .success(value): _result.script = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String:String].self, source: sourceDictionary["extensionParams"] as AnyObject?) {
                case let .success(value): _result.extensionParams = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: AppGetRef.self, source: sourceDictionary["belongsTo"] as AnyObject?) {
                case let .success(value): _result.belongsTo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ExtensionGet", actual: "\(source)"))
            }
        }
        // Decoder for [ExtensionGetFull]
        Decoders.addDecoder(clazz: [ExtensionGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ExtensionGetFull]> in
            return Decoders.decode(clazz: [ExtensionGetFull].self, source: source)
        }

        // Decoder for ExtensionGetFull
        Decoders.addDecoder(clazz: ExtensionGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ExtensionGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ExtensionGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ExtensionGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ExtensionGetRef]
        Decoders.addDecoder(clazz: [ExtensionGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ExtensionGetRef]> in
            return Decoders.decode(clazz: [ExtensionGetRef].self, source: source)
        }

        // Decoder for ExtensionGetRef
        Decoders.addDecoder(clazz: ExtensionGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ExtensionGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ExtensionGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ExtensionGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [FetchAll]
        Decoders.addDecoder(clazz: [FetchAll].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FetchAll]> in
            return Decoders.decode(clazz: [FetchAll].self, source: source)
        }

        // Decoder for FetchAll
        Decoders.addDecoder(clazz: FetchAll.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FetchAll> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = FetchAll()
                switch Decoders.decodeOptional(clazz: [Any].self, source: sourceDictionary["results"] as AnyObject?) {
                case let .success(value): _result.results = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FetchAll", actual: "\(source)"))
            }
        }
        // Decoder for [FieldAnswerCreate]
        Decoders.addDecoder(clazz: [FieldAnswerCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldAnswerCreate]> in
            return Decoders.decode(clazz: [FieldAnswerCreate].self, source: source)
        }

        // Decoder for FieldAnswerCreate
        Decoders.addDecoder(clazz: FieldAnswerCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldAnswerCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let conceptSource = sourceDictionary["concept"] as AnyObject? else {
                    return .failure(.missingKey(key: "concept"))
                }
                guard let concept = Decoders.decode(clazz: String.self.self, source: conceptSource).value else {
                    return .failure(.typeMismatch(expected: "FieldAnswerCreate", actual: "\(conceptSource)"))
                }
                guard let fieldSource = sourceDictionary["field"] as AnyObject? else {
                    return .failure(.missingKey(key: "field"))
                }
                guard let field = Decoders.decode(clazz: String.self.self, source: fieldSource).value else {
                    return .failure(.typeMismatch(expected: "FieldAnswerCreate", actual: "\(fieldSource)"))
                }
                let _result = FieldAnswerCreate(concept: concept, field: field)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldAnswerCreate", actual: "\(source)"))
            }
        }
        // Decoder for [FieldAnswerCreateFull]
        Decoders.addDecoder(clazz: [FieldAnswerCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldAnswerCreateFull]> in
            return Decoders.decode(clazz: [FieldAnswerCreateFull].self, source: source)
        }

        // Decoder for FieldAnswerCreateFull
        Decoders.addDecoder(clazz: FieldAnswerCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldAnswerCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let conceptSource = sourceDictionary["concept"] as AnyObject? else {
                    return .failure(.missingKey(key: "concept"))
                }
                guard let concept = Decoders.decode(clazz: ConceptCreate.self.self, source: conceptSource).value else {
                    return .failure(.typeMismatch(expected: "FieldAnswerCreateFull", actual: "\(conceptSource)"))
                }
                guard let fieldSource = sourceDictionary["field"] as AnyObject? else {
                    return .failure(.missingKey(key: "field"))
                }
                guard let field = Decoders.decode(clazz: FieldCreate.self.self, source: fieldSource).value else {
                    return .failure(.typeMismatch(expected: "FieldAnswerCreateFull", actual: "\(fieldSource)"))
                }
                let _result = FieldAnswerCreateFull(concept: concept, field: field)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldAnswerCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [FieldAnswerGet]
        Decoders.addDecoder(clazz: [FieldAnswerGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldAnswerGet]> in
            return Decoders.decode(clazz: [FieldAnswerGet].self, source: source)
        }

        // Decoder for FieldAnswerGet
        Decoders.addDecoder(clazz: FieldAnswerGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldAnswerGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = FieldAnswerGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FieldGetRef.self, source: sourceDictionary["field"] as AnyObject?) {
                case let .success(value): _result.field = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldAnswerGet", actual: "\(source)"))
            }
        }
        // Decoder for [FieldAnswerGetFull]
        Decoders.addDecoder(clazz: [FieldAnswerGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldAnswerGetFull]> in
            return Decoders.decode(clazz: [FieldAnswerGetFull].self, source: source)
        }

        // Decoder for FieldAnswerGetFull
        Decoders.addDecoder(clazz: FieldAnswerGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldAnswerGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = FieldAnswerGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FieldGet.self, source: sourceDictionary["field"] as AnyObject?) {
                case let .success(value): _result.field = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldAnswerGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [FieldAnswerGetRef]
        Decoders.addDecoder(clazz: [FieldAnswerGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldAnswerGetRef]> in
            return Decoders.decode(clazz: [FieldAnswerGetRef].self, source: source)
        }

        // Decoder for FieldAnswerGetRef
        Decoders.addDecoder(clazz: FieldAnswerGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldAnswerGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = FieldAnswerGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldAnswerGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [FieldAnswerUpdate]
        Decoders.addDecoder(clazz: [FieldAnswerUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldAnswerUpdate]> in
            return Decoders.decode(clazz: [FieldAnswerUpdate].self, source: source)
        }

        // Decoder for FieldAnswerUpdate
        Decoders.addDecoder(clazz: FieldAnswerUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldAnswerUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let conceptSource = sourceDictionary["concept"] as AnyObject? else {
                    return .failure(.missingKey(key: "concept"))
                }
                guard let concept = Decoders.decode(clazz: String.self.self, source: conceptSource).value else {
                    return .failure(.typeMismatch(expected: "FieldAnswerUpdate", actual: "\(conceptSource)"))
                }
                guard let fieldSource = sourceDictionary["field"] as AnyObject? else {
                    return .failure(.missingKey(key: "field"))
                }
                guard let field = Decoders.decode(clazz: String.self.self, source: fieldSource).value else {
                    return .failure(.typeMismatch(expected: "FieldAnswerUpdate", actual: "\(fieldSource)"))
                }
                let _result = FieldAnswerUpdate(concept: concept, field: field)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldAnswerUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [FieldCreate]
        Decoders.addDecoder(clazz: [FieldCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldCreate]> in
            return Decoders.decode(clazz: [FieldCreate].self, source: source)
        }

        // Decoder for FieldCreate
        Decoders.addDecoder(clazz: FieldCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "FieldCreate", actual: "\(nameSource)"))
                }
                guard let fieldTypeSource = sourceDictionary["fieldType"] as AnyObject? else {
                    return .failure(.missingKey(key: "fieldType"))
                }
                guard let fieldType = Decoders.decode(clazz: FieldtypeCreate.self.self, source: fieldTypeSource).value else {
                    return .failure(.typeMismatch(expected: "FieldCreate", actual: "\(fieldTypeSource)"))
                }
                guard let selectMultipleSource = sourceDictionary["selectMultiple"] as AnyObject? else {
                    return .failure(.missingKey(key: "selectMultiple"))
                }
                guard let selectMultiple = Decoders.decode(clazz: Bool.self.self, source: selectMultipleSource).value else {
                    return .failure(.typeMismatch(expected: "FieldCreate", actual: "\(selectMultipleSource)"))
                }
                let _result = FieldCreate(name: name, fieldType: fieldType, selectMultiple: selectMultiple)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptCreate.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["tableName"] as AnyObject?) {
                case let .success(value): _result.tableName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeName"] as AnyObject?) {
                case let .success(value): _result.attributeName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["defaultValue"] as AnyObject?) {
                case let .success(value): _result.defaultValue = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldCreate", actual: "\(source)"))
            }
        }
        // Decoder for [FieldCreateFull]
        Decoders.addDecoder(clazz: [FieldCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldCreateFull]> in
            return Decoders.decode(clazz: [FieldCreateFull].self, source: source)
        }

        // Decoder for FieldCreateFull
        Decoders.addDecoder(clazz: FieldCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "FieldCreateFull", actual: "\(nameSource)"))
                }
                guard let fieldTypeSource = sourceDictionary["fieldType"] as AnyObject? else {
                    return .failure(.missingKey(key: "fieldType"))
                }
                guard let fieldType = Decoders.decode(clazz: FieldtypeCreate.self.self, source: fieldTypeSource).value else {
                    return .failure(.typeMismatch(expected: "FieldCreateFull", actual: "\(fieldTypeSource)"))
                }
                guard let selectMultipleSource = sourceDictionary["selectMultiple"] as AnyObject? else {
                    return .failure(.missingKey(key: "selectMultiple"))
                }
                guard let selectMultiple = Decoders.decode(clazz: Bool.self.self, source: selectMultipleSource).value else {
                    return .failure(.typeMismatch(expected: "FieldCreateFull", actual: "\(selectMultipleSource)"))
                }
                let _result = FieldCreateFull(name: name, fieldType: fieldType, selectMultiple: selectMultiple)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptCreate.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["tableName"] as AnyObject?) {
                case let .success(value): _result.tableName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeName"] as AnyObject?) {
                case let .success(value): _result.attributeName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["defaultValue"] as AnyObject?) {
                case let .success(value): _result.defaultValue = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [FieldGet]
        Decoders.addDecoder(clazz: [FieldGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldGet]> in
            return Decoders.decode(clazz: [FieldGet].self, source: source)
        }

        // Decoder for FieldGet
        Decoders.addDecoder(clazz: FieldGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = FieldGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["tableName"] as AnyObject?) {
                case let .success(value): _result.tableName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeName"] as AnyObject?) {
                case let .success(value): _result.attributeName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["defaultValue"] as AnyObject?) {
                case let .success(value): _result.defaultValue = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["selectMultiple"] as AnyObject?) {
                case let .success(value): _result.selectMultiple = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FieldtypeGetRef.self, source: sourceDictionary["fieldType"] as AnyObject?) {
                case let .success(value): _result.fieldType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldGet", actual: "\(source)"))
            }
        }
        // Decoder for [FieldGetFull]
        Decoders.addDecoder(clazz: [FieldGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldGetFull]> in
            return Decoders.decode(clazz: [FieldGetFull].self, source: source)
        }

        // Decoder for FieldGetFull
        Decoders.addDecoder(clazz: FieldGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = FieldGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["tableName"] as AnyObject?) {
                case let .success(value): _result.tableName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeName"] as AnyObject?) {
                case let .success(value): _result.attributeName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["defaultValue"] as AnyObject?) {
                case let .success(value): _result.defaultValue = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["selectMultiple"] as AnyObject?) {
                case let .success(value): _result.selectMultiple = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FieldtypeGet.self, source: sourceDictionary["fieldType"] as AnyObject?) {
                case let .success(value): _result.fieldType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [FieldGetRef]
        Decoders.addDecoder(clazz: [FieldGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldGetRef]> in
            return Decoders.decode(clazz: [FieldGetRef].self, source: source)
        }

        // Decoder for FieldGetRef
        Decoders.addDecoder(clazz: FieldGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = FieldGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [FieldUpdate]
        Decoders.addDecoder(clazz: [FieldUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldUpdate]> in
            return Decoders.decode(clazz: [FieldUpdate].self, source: source)
        }

        // Decoder for FieldUpdate
        Decoders.addDecoder(clazz: FieldUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = FieldUpdate()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [FieldtypeCreate]
        Decoders.addDecoder(clazz: [FieldtypeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldtypeCreate]> in
            return Decoders.decode(clazz: [FieldtypeCreate].self, source: source)
        }

        // Decoder for FieldtypeCreate
        Decoders.addDecoder(clazz: FieldtypeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldtypeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "FieldtypeCreate", actual: "\(nameSource)"))
                }
                let _result = FieldtypeCreate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldtypeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [FieldtypeCreateFull]
        Decoders.addDecoder(clazz: [FieldtypeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldtypeCreateFull]> in
            return Decoders.decode(clazz: [FieldtypeCreateFull].self, source: source)
        }

        // Decoder for FieldtypeCreateFull
        Decoders.addDecoder(clazz: FieldtypeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldtypeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "FieldtypeCreateFull", actual: "\(nameSource)"))
                }
                let _result = FieldtypeCreateFull(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldtypeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [FieldtypeGet]
        Decoders.addDecoder(clazz: [FieldtypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldtypeGet]> in
            return Decoders.decode(clazz: [FieldtypeGet].self, source: source)
        }

        // Decoder for FieldtypeGet
        Decoders.addDecoder(clazz: FieldtypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldtypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = FieldtypeGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["isSet"] as AnyObject?) {
                case let .success(value): _result.isSet = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldtypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [FieldtypeGetFull]
        Decoders.addDecoder(clazz: [FieldtypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldtypeGetFull]> in
            return Decoders.decode(clazz: [FieldtypeGetFull].self, source: source)
        }

        // Decoder for FieldtypeGetFull
        Decoders.addDecoder(clazz: FieldtypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldtypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = FieldtypeGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["isSet"] as AnyObject?) {
                case let .success(value): _result.isSet = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldtypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [FieldtypeGetRef]
        Decoders.addDecoder(clazz: [FieldtypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldtypeGetRef]> in
            return Decoders.decode(clazz: [FieldtypeGetRef].self, source: source)
        }

        // Decoder for FieldtypeGetRef
        Decoders.addDecoder(clazz: FieldtypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldtypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = FieldtypeGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldtypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [FieldtypeUpdate]
        Decoders.addDecoder(clazz: [FieldtypeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldtypeUpdate]> in
            return Decoders.decode(clazz: [FieldtypeUpdate].self, source: source)
        }

        // Decoder for FieldtypeUpdate
        Decoders.addDecoder(clazz: FieldtypeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldtypeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = FieldtypeUpdate()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldtypeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [FormCreate]
        Decoders.addDecoder(clazz: [FormCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormCreate]> in
            return Decoders.decode(clazz: [FormCreate].self, source: source)
        }

        // Decoder for FormCreate
        Decoders.addDecoder(clazz: FormCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "FormCreate", actual: "\(nameSource)"))
                }
                guard let versionSource = sourceDictionary["version"] as AnyObject? else {
                    return .failure(.missingKey(key: "version"))
                }
                guard let version = Decoders.decode(clazz: String.self.self, source: versionSource).value else {
                    return .failure(.typeMismatch(expected: "FormCreate", actual: "\(versionSource)"))
                }
                let _result = FormCreate(name: name, version: version)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["encounterType"] as AnyObject?) {
                case let .success(value): _result.encounterType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["build"] as AnyObject?) {
                case let .success(value): _result.build = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["published"] as AnyObject?) {
                case let .success(value): _result.published = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["formFields"] as AnyObject?) {
                case let .success(value): _result.formFields = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["xslt"] as AnyObject?) {
                case let .success(value): _result.xslt = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["template"] as AnyObject?) {
                case let .success(value): _result.template = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormCreate", actual: "\(source)"))
            }
        }
        // Decoder for [FormCreateFull]
        Decoders.addDecoder(clazz: [FormCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormCreateFull]> in
            return Decoders.decode(clazz: [FormCreateFull].self, source: source)
        }

        // Decoder for FormCreateFull
        Decoders.addDecoder(clazz: FormCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "FormCreateFull", actual: "\(nameSource)"))
                }
                guard let versionSource = sourceDictionary["version"] as AnyObject? else {
                    return .failure(.missingKey(key: "version"))
                }
                guard let version = Decoders.decode(clazz: String.self.self, source: versionSource).value else {
                    return .failure(.typeMismatch(expected: "FormCreateFull", actual: "\(versionSource)"))
                }
                let _result = FormCreateFull(name: name, version: version)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: EncountertypeCreate.self, source: sourceDictionary["encounterType"] as AnyObject?) {
                case let .success(value): _result.encounterType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["build"] as AnyObject?) {
                case let .success(value): _result.build = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["published"] as AnyObject?) {
                case let .success(value): _result.published = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [FormFormfieldCreate].self, source: sourceDictionary["formFields"] as AnyObject?) {
                case let .success(value): _result.formFields = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["xslt"] as AnyObject?) {
                case let .success(value): _result.xslt = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["template"] as AnyObject?) {
                case let .success(value): _result.template = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [FormFormfieldCreate]
        Decoders.addDecoder(clazz: [FormFormfieldCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormFormfieldCreate]> in
            return Decoders.decode(clazz: [FormFormfieldCreate].self, source: source)
        }

        // Decoder for FormFormfieldCreate
        Decoders.addDecoder(clazz: FormFormfieldCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormFormfieldCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let formSource = sourceDictionary["form"] as AnyObject? else {
                    return .failure(.missingKey(key: "form"))
                }
                guard let form = Decoders.decode(clazz: String.self.self, source: formSource).value else {
                    return .failure(.typeMismatch(expected: "FormFormfieldCreate", actual: "\(formSource)"))
                }
                guard let fieldSource = sourceDictionary["field"] as AnyObject? else {
                    return .failure(.missingKey(key: "field"))
                }
                guard let field = Decoders.decode(clazz: String.self.self, source: fieldSource).value else {
                    return .failure(.typeMismatch(expected: "FormFormfieldCreate", actual: "\(fieldSource)"))
                }
                guard let _requiredSource = sourceDictionary["required"] as AnyObject? else {
                    return .failure(.missingKey(key: "required"))
                }
                guard let _required = Decoders.decode(clazz: Bool.self.self, source: _requiredSource).value else {
                    return .failure(.typeMismatch(expected: "FormFormfieldCreate", actual: "\(_requiredSource)"))
                }
                let _result = FormFormfieldCreate(form: form, field: field, _required: _required)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["parent"] as AnyObject?) {
                case let .success(value): _result.parent = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["fieldNumber"] as AnyObject?) {
                case let .success(value): _result.fieldNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fieldPart"] as AnyObject?) {
                case let .success(value): _result.fieldPart = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pageNumber"] as AnyObject?) {
                case let .success(value): _result.pageNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["sortWeight"] as AnyObject?) {
                case let .success(value): _result.sortWeight = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormFormfieldCreate", actual: "\(source)"))
            }
        }
        // Decoder for [FormFormfieldCreateFull]
        Decoders.addDecoder(clazz: [FormFormfieldCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormFormfieldCreateFull]> in
            return Decoders.decode(clazz: [FormFormfieldCreateFull].self, source: source)
        }

        // Decoder for FormFormfieldCreateFull
        Decoders.addDecoder(clazz: FormFormfieldCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormFormfieldCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let formSource = sourceDictionary["form"] as AnyObject? else {
                    return .failure(.missingKey(key: "form"))
                }
                guard let form = Decoders.decode(clazz: FormCreate.self.self, source: formSource).value else {
                    return .failure(.typeMismatch(expected: "FormFormfieldCreateFull", actual: "\(formSource)"))
                }
                guard let fieldSource = sourceDictionary["field"] as AnyObject? else {
                    return .failure(.missingKey(key: "field"))
                }
                guard let field = Decoders.decode(clazz: FieldCreate.self.self, source: fieldSource).value else {
                    return .failure(.typeMismatch(expected: "FormFormfieldCreateFull", actual: "\(fieldSource)"))
                }
                guard let _requiredSource = sourceDictionary["required"] as AnyObject? else {
                    return .failure(.missingKey(key: "required"))
                }
                guard let _required = Decoders.decode(clazz: Bool.self.self, source: _requiredSource).value else {
                    return .failure(.typeMismatch(expected: "FormFormfieldCreateFull", actual: "\(_requiredSource)"))
                }
                let _result = FormFormfieldCreateFull(form: form, field: field, _required: _required)
                switch Decoders.decodeOptional(clazz: FormFormfieldCreate.self, source: sourceDictionary["parent"] as AnyObject?) {
                case let .success(value): _result.parent = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["fieldNumber"] as AnyObject?) {
                case let .success(value): _result.fieldNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fieldPart"] as AnyObject?) {
                case let .success(value): _result.fieldPart = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pageNumber"] as AnyObject?) {
                case let .success(value): _result.pageNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["sortWeight"] as AnyObject?) {
                case let .success(value): _result.sortWeight = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormFormfieldCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [FormFormfieldGet]
        Decoders.addDecoder(clazz: [FormFormfieldGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormFormfieldGet]> in
            return Decoders.decode(clazz: [FormFormfieldGet].self, source: source)
        }

        // Decoder for FormFormfieldGet
        Decoders.addDecoder(clazz: FormFormfieldGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormFormfieldGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = FormFormfieldGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["fieldNumber"] as AnyObject?) {
                case let .success(value): _result.fieldNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fieldPart"] as AnyObject?) {
                case let .success(value): _result.fieldPart = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pageNumber"] as AnyObject?) {
                case let .success(value): _result.pageNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                case let .success(value): _result._required = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["sortWeight"] as AnyObject?) {
                case let .success(value): _result.sortWeight = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FormFormfieldGetRef.self, source: sourceDictionary["parent"] as AnyObject?) {
                case let .success(value): _result.parent = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FormGetRef.self, source: sourceDictionary["form"] as AnyObject?) {
                case let .success(value): _result.form = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FieldGetRef.self, source: sourceDictionary["field"] as AnyObject?) {
                case let .success(value): _result.field = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormFormfieldGet", actual: "\(source)"))
            }
        }
        // Decoder for [FormFormfieldGetFull]
        Decoders.addDecoder(clazz: [FormFormfieldGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormFormfieldGetFull]> in
            return Decoders.decode(clazz: [FormFormfieldGetFull].self, source: source)
        }

        // Decoder for FormFormfieldGetFull
        Decoders.addDecoder(clazz: FormFormfieldGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormFormfieldGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = FormFormfieldGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["fieldNumber"] as AnyObject?) {
                case let .success(value): _result.fieldNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fieldPart"] as AnyObject?) {
                case let .success(value): _result.fieldPart = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pageNumber"] as AnyObject?) {
                case let .success(value): _result.pageNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                case let .success(value): _result._required = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["sortWeight"] as AnyObject?) {
                case let .success(value): _result.sortWeight = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FormFormfieldGet.self, source: sourceDictionary["parent"] as AnyObject?) {
                case let .success(value): _result.parent = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FormGet.self, source: sourceDictionary["form"] as AnyObject?) {
                case let .success(value): _result.form = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FieldGet.self, source: sourceDictionary["field"] as AnyObject?) {
                case let .success(value): _result.field = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormFormfieldGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [FormFormfieldGetRef]
        Decoders.addDecoder(clazz: [FormFormfieldGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormFormfieldGetRef]> in
            return Decoders.decode(clazz: [FormFormfieldGetRef].self, source: source)
        }

        // Decoder for FormFormfieldGetRef
        Decoders.addDecoder(clazz: FormFormfieldGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormFormfieldGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = FormFormfieldGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormFormfieldGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [FormFormfieldUpdate]
        Decoders.addDecoder(clazz: [FormFormfieldUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormFormfieldUpdate]> in
            return Decoders.decode(clazz: [FormFormfieldUpdate].self, source: source)
        }

        // Decoder for FormFormfieldUpdate
        Decoders.addDecoder(clazz: FormFormfieldUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormFormfieldUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = FormFormfieldUpdate()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormFormfieldUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [FormGet]
        Decoders.addDecoder(clazz: [FormGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormGet]> in
            return Decoders.decode(clazz: [FormGet].self, source: source)
        }

        // Decoder for FormGet
        Decoders.addDecoder(clazz: FormGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = FormGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["version"] as AnyObject?) {
                case let .success(value): _result.version = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["build"] as AnyObject?) {
                case let .success(value): _result.build = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["published"] as AnyObject?) {
                case let .success(value): _result.published = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: EncountertypeGetRef.self, source: sourceDictionary["encounterType"] as AnyObject?) {
                case let .success(value): _result.encounterType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [FormFormfieldGetRef].self, source: sourceDictionary["formFields"] as AnyObject?) {
                case let .success(value): _result.formFields = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormGet", actual: "\(source)"))
            }
        }
        // Decoder for [FormGetFull]
        Decoders.addDecoder(clazz: [FormGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormGetFull]> in
            return Decoders.decode(clazz: [FormGetFull].self, source: source)
        }

        // Decoder for FormGetFull
        Decoders.addDecoder(clazz: FormGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = FormGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["version"] as AnyObject?) {
                case let .success(value): _result.version = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["build"] as AnyObject?) {
                case let .success(value): _result.build = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["published"] as AnyObject?) {
                case let .success(value): _result.published = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: EncountertypeGet.self, source: sourceDictionary["encounterType"] as AnyObject?) {
                case let .success(value): _result.encounterType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [FormFormfieldGet].self, source: sourceDictionary["formFields"] as AnyObject?) {
                case let .success(value): _result.formFields = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [FormGetRef]
        Decoders.addDecoder(clazz: [FormGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormGetRef]> in
            return Decoders.decode(clazz: [FormGetRef].self, source: source)
        }

        // Decoder for FormGetRef
        Decoders.addDecoder(clazz: FormGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = FormGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [FormResourceCreate]
        Decoders.addDecoder(clazz: [FormResourceCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormResourceCreate]> in
            return Decoders.decode(clazz: [FormResourceCreate].self, source: source)
        }

        // Decoder for FormResourceCreate
        Decoders.addDecoder(clazz: FormResourceCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormResourceCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = FormResourceCreate()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["form"] as AnyObject?) {
                case let .success(value): _result.form = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["dataType"] as AnyObject?) {
                case let .success(value): _result.dataType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handler"] as AnyObject?) {
                case let .success(value): _result.handler = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["valueReference"] as AnyObject?) {
                case let .success(value): _result.valueReference = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormResourceCreate", actual: "\(source)"))
            }
        }
        // Decoder for [FormResourceCreateFull]
        Decoders.addDecoder(clazz: [FormResourceCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormResourceCreateFull]> in
            return Decoders.decode(clazz: [FormResourceCreateFull].self, source: source)
        }

        // Decoder for FormResourceCreateFull
        Decoders.addDecoder(clazz: FormResourceCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormResourceCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = FormResourceCreateFull()
                switch Decoders.decodeOptional(clazz: FormCreate.self, source: sourceDictionary["form"] as AnyObject?) {
                case let .success(value): _result.form = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["dataType"] as AnyObject?) {
                case let .success(value): _result.dataType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handler"] as AnyObject?) {
                case let .success(value): _result.handler = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["valueReference"] as AnyObject?) {
                case let .success(value): _result.valueReference = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormResourceCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [FormResourceGet]
        Decoders.addDecoder(clazz: [FormResourceGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormResourceGet]> in
            return Decoders.decode(clazz: [FormResourceGet].self, source: source)
        }

        // Decoder for FormResourceGet
        Decoders.addDecoder(clazz: FormResourceGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormResourceGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = FormResourceGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["valueReference"] as AnyObject?) {
                case let .success(value): _result.valueReference = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormResourceGet", actual: "\(source)"))
            }
        }
        // Decoder for [FormResourceGetFull]
        Decoders.addDecoder(clazz: [FormResourceGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormResourceGetFull]> in
            return Decoders.decode(clazz: [FormResourceGetFull].self, source: source)
        }

        // Decoder for FormResourceGetFull
        Decoders.addDecoder(clazz: FormResourceGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormResourceGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = FormResourceGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["valueReference"] as AnyObject?) {
                case let .success(value): _result.valueReference = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["dataType"] as AnyObject?) {
                case let .success(value): _result.dataType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handler"] as AnyObject?) {
                case let .success(value): _result.handler = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormResourceGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [FormResourceGetRef]
        Decoders.addDecoder(clazz: [FormResourceGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormResourceGetRef]> in
            return Decoders.decode(clazz: [FormResourceGetRef].self, source: source)
        }

        // Decoder for FormResourceGetRef
        Decoders.addDecoder(clazz: FormResourceGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormResourceGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = FormResourceGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormResourceGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [FormResourceUpdate]
        Decoders.addDecoder(clazz: [FormResourceUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormResourceUpdate]> in
            return Decoders.decode(clazz: [FormResourceUpdate].self, source: source)
        }

        // Decoder for FormResourceUpdate
        Decoders.addDecoder(clazz: FormResourceUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormResourceUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = FormResourceUpdate()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["form"] as AnyObject?) {
                case let .success(value): _result.form = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["dataType"] as AnyObject?) {
                case let .success(value): _result.dataType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handler"] as AnyObject?) {
                case let .success(value): _result.handler = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["valueReference"] as AnyObject?) {
                case let .success(value): _result.valueReference = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormResourceUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [FormUpdate]
        Decoders.addDecoder(clazz: [FormUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormUpdate]> in
            return Decoders.decode(clazz: [FormUpdate].self, source: source)
        }

        // Decoder for FormUpdate
        Decoders.addDecoder(clazz: FormUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "FormUpdate", actual: "\(nameSource)"))
                }
                guard let versionSource = sourceDictionary["version"] as AnyObject? else {
                    return .failure(.missingKey(key: "version"))
                }
                guard let version = Decoders.decode(clazz: String.self.self, source: versionSource).value else {
                    return .failure(.typeMismatch(expected: "FormUpdate", actual: "\(versionSource)"))
                }
                let _result = FormUpdate(name: name, version: version)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["encounterType"] as AnyObject?) {
                case let .success(value): _result.encounterType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["build"] as AnyObject?) {
                case let .success(value): _result.build = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["published"] as AnyObject?) {
                case let .success(value): _result.published = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["formFields"] as AnyObject?) {
                case let .success(value): _result.formFields = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["xslt"] as AnyObject?) {
                case let .success(value): _result.xslt = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["template"] as AnyObject?) {
                case let .success(value): _result.template = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [Hl7Create]
        Decoders.addDecoder(clazz: [Hl7Create].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Hl7Create]> in
            return Decoders.decode(clazz: [Hl7Create].self, source: source)
        }

        // Decoder for Hl7Create
        Decoders.addDecoder(clazz: Hl7Create.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Hl7Create> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let hl7Source = sourceDictionary["hl7"] as AnyObject? else {
                    return .failure(.missingKey(key: "hl7"))
                }
                guard let hl7 = Decoders.decode(clazz: String.self.self, source: hl7Source).value else {
                    return .failure(.typeMismatch(expected: "Hl7Create", actual: "\(hl7Source)"))
                }
                let _result = Hl7Create(hl7: hl7)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Hl7Create", actual: "\(source)"))
            }
        }
        // Decoder for [Hl7CreateFull]
        Decoders.addDecoder(clazz: [Hl7CreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Hl7CreateFull]> in
            return Decoders.decode(clazz: [Hl7CreateFull].self, source: source)
        }

        // Decoder for Hl7CreateFull
        Decoders.addDecoder(clazz: Hl7CreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Hl7CreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let hl7Source = sourceDictionary["hl7"] as AnyObject? else {
                    return .failure(.missingKey(key: "hl7"))
                }
                guard let hl7 = Decoders.decode(clazz: String.self.self, source: hl7Source).value else {
                    return .failure(.typeMismatch(expected: "Hl7CreateFull", actual: "\(hl7Source)"))
                }
                let _result = Hl7CreateFull(hl7: hl7)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Hl7CreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [Hl7sourceCreate]
        Decoders.addDecoder(clazz: [Hl7sourceCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Hl7sourceCreate]> in
            return Decoders.decode(clazz: [Hl7sourceCreate].self, source: source)
        }

        // Decoder for Hl7sourceCreate
        Decoders.addDecoder(clazz: Hl7sourceCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Hl7sourceCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "Hl7sourceCreate", actual: "\(nameSource)"))
                }
                guard let descriptionSource = sourceDictionary["description"] as AnyObject? else {
                    return .failure(.missingKey(key: "description"))
                }
                guard let description = Decoders.decode(clazz: String.self.self, source: descriptionSource).value else {
                    return .failure(.typeMismatch(expected: "Hl7sourceCreate", actual: "\(descriptionSource)"))
                }
                let _result = Hl7sourceCreate(name: name, description: description)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Hl7sourceCreate", actual: "\(source)"))
            }
        }
        // Decoder for [Hl7sourceCreateFull]
        Decoders.addDecoder(clazz: [Hl7sourceCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Hl7sourceCreateFull]> in
            return Decoders.decode(clazz: [Hl7sourceCreateFull].self, source: source)
        }

        // Decoder for Hl7sourceCreateFull
        Decoders.addDecoder(clazz: Hl7sourceCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Hl7sourceCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "Hl7sourceCreateFull", actual: "\(nameSource)"))
                }
                guard let descriptionSource = sourceDictionary["description"] as AnyObject? else {
                    return .failure(.missingKey(key: "description"))
                }
                guard let description = Decoders.decode(clazz: String.self.self, source: descriptionSource).value else {
                    return .failure(.typeMismatch(expected: "Hl7sourceCreateFull", actual: "\(descriptionSource)"))
                }
                let _result = Hl7sourceCreateFull(name: name, description: description)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Hl7sourceCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [Hl7sourceGet]
        Decoders.addDecoder(clazz: [Hl7sourceGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Hl7sourceGet]> in
            return Decoders.decode(clazz: [Hl7sourceGet].self, source: source)
        }

        // Decoder for Hl7sourceGet
        Decoders.addDecoder(clazz: Hl7sourceGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Hl7sourceGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = Hl7sourceGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Hl7sourceGet", actual: "\(source)"))
            }
        }
        // Decoder for [Hl7sourceGetFull]
        Decoders.addDecoder(clazz: [Hl7sourceGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Hl7sourceGetFull]> in
            return Decoders.decode(clazz: [Hl7sourceGetFull].self, source: source)
        }

        // Decoder for Hl7sourceGetFull
        Decoders.addDecoder(clazz: Hl7sourceGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Hl7sourceGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = Hl7sourceGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Hl7sourceGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [Hl7sourceGetRef]
        Decoders.addDecoder(clazz: [Hl7sourceGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Hl7sourceGetRef]> in
            return Decoders.decode(clazz: [Hl7sourceGetRef].self, source: source)
        }

        // Decoder for Hl7sourceGetRef
        Decoders.addDecoder(clazz: Hl7sourceGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Hl7sourceGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = Hl7sourceGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Hl7sourceGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [Hl7sourceUpdate]
        Decoders.addDecoder(clazz: [Hl7sourceUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Hl7sourceUpdate]> in
            return Decoders.decode(clazz: [Hl7sourceUpdate].self, source: source)
        }

        // Decoder for Hl7sourceUpdate
        Decoders.addDecoder(clazz: Hl7sourceUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Hl7sourceUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "Hl7sourceUpdate", actual: "\(nameSource)"))
                }
                guard let descriptionSource = sourceDictionary["description"] as AnyObject? else {
                    return .failure(.missingKey(key: "description"))
                }
                guard let description = Decoders.decode(clazz: String.self.self, source: descriptionSource).value else {
                    return .failure(.typeMismatch(expected: "Hl7sourceUpdate", actual: "\(descriptionSource)"))
                }
                let _result = Hl7sourceUpdate(name: name, description: description)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Hl7sourceUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [IdgenAutogenerationoptionGet]
        Decoders.addDecoder(clazz: [IdgenAutogenerationoptionGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[IdgenAutogenerationoptionGet]> in
            return Decoders.decode(clazz: [IdgenAutogenerationoptionGet].self, source: source)
        }

        // Decoder for IdgenAutogenerationoptionGet
        Decoders.addDecoder(clazz: IdgenAutogenerationoptionGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IdgenAutogenerationoptionGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = IdgenAutogenerationoptionGet()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "IdgenAutogenerationoptionGet", actual: "\(source)"))
            }
        }
        // Decoder for [IdgenAutogenerationoptionGetFull]
        Decoders.addDecoder(clazz: [IdgenAutogenerationoptionGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[IdgenAutogenerationoptionGetFull]> in
            return Decoders.decode(clazz: [IdgenAutogenerationoptionGetFull].self, source: source)
        }

        // Decoder for IdgenAutogenerationoptionGetFull
        Decoders.addDecoder(clazz: IdgenAutogenerationoptionGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IdgenAutogenerationoptionGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = IdgenAutogenerationoptionGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "IdgenAutogenerationoptionGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [IdgenAutogenerationoptionGetRef]
        Decoders.addDecoder(clazz: [IdgenAutogenerationoptionGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[IdgenAutogenerationoptionGetRef]> in
            return Decoders.decode(clazz: [IdgenAutogenerationoptionGetRef].self, source: source)
        }

        // Decoder for IdgenAutogenerationoptionGetRef
        Decoders.addDecoder(clazz: IdgenAutogenerationoptionGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IdgenAutogenerationoptionGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = IdgenAutogenerationoptionGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "IdgenAutogenerationoptionGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [IdgenIdentifiersourceGet]
        Decoders.addDecoder(clazz: [IdgenIdentifiersourceGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[IdgenIdentifiersourceGet]> in
            return Decoders.decode(clazz: [IdgenIdentifiersourceGet].self, source: source)
        }

        // Decoder for IdgenIdentifiersourceGet
        Decoders.addDecoder(clazz: IdgenIdentifiersourceGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IdgenIdentifiersourceGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = IdgenIdentifiersourceGet()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "IdgenIdentifiersourceGet", actual: "\(source)"))
            }
        }
        // Decoder for [IdgenIdentifiersourceGetFull]
        Decoders.addDecoder(clazz: [IdgenIdentifiersourceGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[IdgenIdentifiersourceGetFull]> in
            return Decoders.decode(clazz: [IdgenIdentifiersourceGetFull].self, source: source)
        }

        // Decoder for IdgenIdentifiersourceGetFull
        Decoders.addDecoder(clazz: IdgenIdentifiersourceGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IdgenIdentifiersourceGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = IdgenIdentifiersourceGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "IdgenIdentifiersourceGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [IdgenIdentifiersourceGetRef]
        Decoders.addDecoder(clazz: [IdgenIdentifiersourceGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[IdgenIdentifiersourceGetRef]> in
            return Decoders.decode(clazz: [IdgenIdentifiersourceGetRef].self, source: source)
        }

        // Decoder for IdgenIdentifiersourceGetRef
        Decoders.addDecoder(clazz: IdgenIdentifiersourceGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IdgenIdentifiersourceGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = IdgenIdentifiersourceGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "IdgenIdentifiersourceGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [IdgenLogentryGet]
        Decoders.addDecoder(clazz: [IdgenLogentryGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[IdgenLogentryGet]> in
            return Decoders.decode(clazz: [IdgenLogentryGet].self, source: source)
        }

        // Decoder for IdgenLogentryGet
        Decoders.addDecoder(clazz: IdgenLogentryGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IdgenLogentryGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = IdgenLogentryGet()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "IdgenLogentryGet", actual: "\(source)"))
            }
        }
        // Decoder for [IdgenLogentryGetFull]
        Decoders.addDecoder(clazz: [IdgenLogentryGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[IdgenLogentryGetFull]> in
            return Decoders.decode(clazz: [IdgenLogentryGetFull].self, source: source)
        }

        // Decoder for IdgenLogentryGetFull
        Decoders.addDecoder(clazz: IdgenLogentryGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IdgenLogentryGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = IdgenLogentryGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "IdgenLogentryGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [IdgenLogentryGetRef]
        Decoders.addDecoder(clazz: [IdgenLogentryGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[IdgenLogentryGetRef]> in
            return Decoders.decode(clazz: [IdgenLogentryGetRef].self, source: source)
        }

        // Decoder for IdgenLogentryGetRef
        Decoders.addDecoder(clazz: IdgenLogentryGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IdgenLogentryGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = IdgenLogentryGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "IdgenLogentryGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [LocationAttributeCreate]
        Decoders.addDecoder(clazz: [LocationAttributeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationAttributeCreate]> in
            return Decoders.decode(clazz: [LocationAttributeCreate].self, source: source)
        }

        // Decoder for LocationAttributeCreate
        Decoders.addDecoder(clazz: LocationAttributeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationAttributeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let attributeTypeSource = sourceDictionary["attributeType"] as AnyObject? else {
                    return .failure(.missingKey(key: "attributeType"))
                }
                guard let attributeType = Decoders.decode(clazz: String.self.self, source: attributeTypeSource).value else {
                    return .failure(.typeMismatch(expected: "LocationAttributeCreate", actual: "\(attributeTypeSource)"))
                }
                guard let valueSource = sourceDictionary["value"] as AnyObject? else {
                    return .failure(.missingKey(key: "value"))
                }
                guard let value = Decoders.decode(clazz: String.self.self, source: valueSource).value else {
                    return .failure(.typeMismatch(expected: "LocationAttributeCreate", actual: "\(valueSource)"))
                }
                let _result = LocationAttributeCreate(attributeType: attributeType, value: value)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationAttributeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [LocationAttributeCreateFull]
        Decoders.addDecoder(clazz: [LocationAttributeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationAttributeCreateFull]> in
            return Decoders.decode(clazz: [LocationAttributeCreateFull].self, source: source)
        }

        // Decoder for LocationAttributeCreateFull
        Decoders.addDecoder(clazz: LocationAttributeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationAttributeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let attributeTypeSource = sourceDictionary["attributeType"] as AnyObject? else {
                    return .failure(.missingKey(key: "attributeType"))
                }
                guard let attributeType = Decoders.decode(clazz: String.self.self, source: attributeTypeSource).value else {
                    return .failure(.typeMismatch(expected: "LocationAttributeCreateFull", actual: "\(attributeTypeSource)"))
                }
                guard let valueSource = sourceDictionary["value"] as AnyObject? else {
                    return .failure(.missingKey(key: "value"))
                }
                guard let value = Decoders.decode(clazz: String.self.self, source: valueSource).value else {
                    return .failure(.typeMismatch(expected: "LocationAttributeCreateFull", actual: "\(valueSource)"))
                }
                let _result = LocationAttributeCreateFull(attributeType: attributeType, value: value)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationAttributeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [LocationAttributeGet]
        Decoders.addDecoder(clazz: [LocationAttributeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationAttributeGet]> in
            return Decoders.decode(clazz: [LocationAttributeGet].self, source: source)
        }

        // Decoder for LocationAttributeGet
        Decoders.addDecoder(clazz: LocationAttributeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationAttributeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = LocationAttributeGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationAttributeGet", actual: "\(source)"))
            }
        }
        // Decoder for [LocationAttributeGetFull]
        Decoders.addDecoder(clazz: [LocationAttributeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationAttributeGetFull]> in
            return Decoders.decode(clazz: [LocationAttributeGetFull].self, source: source)
        }

        // Decoder for LocationAttributeGetFull
        Decoders.addDecoder(clazz: LocationAttributeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationAttributeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = LocationAttributeGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationAttributeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [LocationAttributeGetRef]
        Decoders.addDecoder(clazz: [LocationAttributeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationAttributeGetRef]> in
            return Decoders.decode(clazz: [LocationAttributeGetRef].self, source: source)
        }

        // Decoder for LocationAttributeGetRef
        Decoders.addDecoder(clazz: LocationAttributeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationAttributeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = LocationAttributeGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationAttributeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [LocationAttributeUpdate]
        Decoders.addDecoder(clazz: [LocationAttributeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationAttributeUpdate]> in
            return Decoders.decode(clazz: [LocationAttributeUpdate].self, source: source)
        }

        // Decoder for LocationAttributeUpdate
        Decoders.addDecoder(clazz: LocationAttributeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationAttributeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let attributeTypeSource = sourceDictionary["attributeType"] as AnyObject? else {
                    return .failure(.missingKey(key: "attributeType"))
                }
                guard let attributeType = Decoders.decode(clazz: String.self.self, source: attributeTypeSource).value else {
                    return .failure(.typeMismatch(expected: "LocationAttributeUpdate", actual: "\(attributeTypeSource)"))
                }
                guard let valueSource = sourceDictionary["value"] as AnyObject? else {
                    return .failure(.missingKey(key: "value"))
                }
                guard let value = Decoders.decode(clazz: String.self.self, source: valueSource).value else {
                    return .failure(.typeMismatch(expected: "LocationAttributeUpdate", actual: "\(valueSource)"))
                }
                let _result = LocationAttributeUpdate(attributeType: attributeType, value: value)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationAttributeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [LocationCreate]
        Decoders.addDecoder(clazz: [LocationCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationCreate]> in
            return Decoders.decode(clazz: [LocationCreate].self, source: source)
        }

        // Decoder for LocationCreate
        Decoders.addDecoder(clazz: LocationCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "LocationCreate", actual: "\(nameSource)"))
                }
                let _result = LocationCreate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address1"] as AnyObject?) {
                case let .success(value): _result.address1 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address2"] as AnyObject?) {
                case let .success(value): _result.address2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["cityVillage"] as AnyObject?) {
                case let .success(value): _result.cityVillage = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stateProvince"] as AnyObject?) {
                case let .success(value): _result.stateProvince = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country"] as AnyObject?) {
                case let .success(value): _result.country = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["postalCode"] as AnyObject?) {
                case let .success(value): _result.postalCode = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["latitude"] as AnyObject?) {
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["longitude"] as AnyObject?) {
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["countyDistrict"] as AnyObject?) {
                case let .success(value): _result.countyDistrict = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address3"] as AnyObject?) {
                case let .success(value): _result.address3 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address4"] as AnyObject?) {
                case let .success(value): _result.address4 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address5"] as AnyObject?) {
                case let .success(value): _result.address5 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address6"] as AnyObject?) {
                case let .success(value): _result.address6 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["tags"] as AnyObject?) {
                case let .success(value): _result.tags = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["parentLocation"] as AnyObject?) {
                case let .success(value): _result.parentLocation = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["childLocations"] as AnyObject?) {
                case let .success(value): _result.childLocations = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationCreate", actual: "\(source)"))
            }
        }
        // Decoder for [LocationCreateFull]
        Decoders.addDecoder(clazz: [LocationCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationCreateFull]> in
            return Decoders.decode(clazz: [LocationCreateFull].self, source: source)
        }

        // Decoder for LocationCreateFull
        Decoders.addDecoder(clazz: LocationCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "LocationCreateFull", actual: "\(nameSource)"))
                }
                let _result = LocationCreateFull(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address1"] as AnyObject?) {
                case let .success(value): _result.address1 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address2"] as AnyObject?) {
                case let .success(value): _result.address2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["cityVillage"] as AnyObject?) {
                case let .success(value): _result.cityVillage = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stateProvince"] as AnyObject?) {
                case let .success(value): _result.stateProvince = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country"] as AnyObject?) {
                case let .success(value): _result.country = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["postalCode"] as AnyObject?) {
                case let .success(value): _result.postalCode = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["latitude"] as AnyObject?) {
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["longitude"] as AnyObject?) {
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["countyDistrict"] as AnyObject?) {
                case let .success(value): _result.countyDistrict = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address3"] as AnyObject?) {
                case let .success(value): _result.address3 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address4"] as AnyObject?) {
                case let .success(value): _result.address4 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address5"] as AnyObject?) {
                case let .success(value): _result.address5 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address6"] as AnyObject?) {
                case let .success(value): _result.address6 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["tags"] as AnyObject?) {
                case let .success(value): _result.tags = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["parentLocation"] as AnyObject?) {
                case let .success(value): _result.parentLocation = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["childLocations"] as AnyObject?) {
                case let .success(value): _result.childLocations = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [LocationGet]
        Decoders.addDecoder(clazz: [LocationGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationGet]> in
            return Decoders.decode(clazz: [LocationGet].self, source: source)
        }

        // Decoder for LocationGet
        Decoders.addDecoder(clazz: LocationGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = LocationGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address1"] as AnyObject?) {
                case let .success(value): _result.address1 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address2"] as AnyObject?) {
                case let .success(value): _result.address2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["cityVillage"] as AnyObject?) {
                case let .success(value): _result.cityVillage = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stateProvince"] as AnyObject?) {
                case let .success(value): _result.stateProvince = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country"] as AnyObject?) {
                case let .success(value): _result.country = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["postalCode"] as AnyObject?) {
                case let .success(value): _result.postalCode = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["latitude"] as AnyObject?) {
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["longitude"] as AnyObject?) {
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["countyDistrict"] as AnyObject?) {
                case let .success(value): _result.countyDistrict = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address3"] as AnyObject?) {
                case let .success(value): _result.address3 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address4"] as AnyObject?) {
                case let .success(value): _result.address4 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address5"] as AnyObject?) {
                case let .success(value): _result.address5 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address6"] as AnyObject?) {
                case let .success(value): _result.address6 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [LocationtagGetRef].self, source: sourceDictionary["tags"] as AnyObject?) {
                case let .success(value): _result.tags = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationGetRef.self, source: sourceDictionary["parentLocation"] as AnyObject?) {
                case let .success(value): _result.parentLocation = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [LocationGetRef].self, source: sourceDictionary["childLocations"] as AnyObject?) {
                case let .success(value): _result.childLocations = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationGet", actual: "\(source)"))
            }
        }
        // Decoder for [LocationGetFull]
        Decoders.addDecoder(clazz: [LocationGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationGetFull]> in
            return Decoders.decode(clazz: [LocationGetFull].self, source: source)
        }

        // Decoder for LocationGetFull
        Decoders.addDecoder(clazz: LocationGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = LocationGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address1"] as AnyObject?) {
                case let .success(value): _result.address1 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address2"] as AnyObject?) {
                case let .success(value): _result.address2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["cityVillage"] as AnyObject?) {
                case let .success(value): _result.cityVillage = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stateProvince"] as AnyObject?) {
                case let .success(value): _result.stateProvince = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country"] as AnyObject?) {
                case let .success(value): _result.country = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["postalCode"] as AnyObject?) {
                case let .success(value): _result.postalCode = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["latitude"] as AnyObject?) {
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["longitude"] as AnyObject?) {
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["countyDistrict"] as AnyObject?) {
                case let .success(value): _result.countyDistrict = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address3"] as AnyObject?) {
                case let .success(value): _result.address3 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address4"] as AnyObject?) {
                case let .success(value): _result.address4 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address5"] as AnyObject?) {
                case let .success(value): _result.address5 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address6"] as AnyObject?) {
                case let .success(value): _result.address6 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [LocationtagGet].self, source: sourceDictionary["tags"] as AnyObject?) {
                case let .success(value): _result.tags = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationGet.self, source: sourceDictionary["parentLocation"] as AnyObject?) {
                case let .success(value): _result.parentLocation = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [LocationGet].self, source: sourceDictionary["childLocations"] as AnyObject?) {
                case let .success(value): _result.childLocations = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [LocationGetRef]
        Decoders.addDecoder(clazz: [LocationGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationGetRef]> in
            return Decoders.decode(clazz: [LocationGetRef].self, source: source)
        }

        // Decoder for LocationGetRef
        Decoders.addDecoder(clazz: LocationGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = LocationGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [LocationUpdate]
        Decoders.addDecoder(clazz: [LocationUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationUpdate]> in
            return Decoders.decode(clazz: [LocationUpdate].self, source: source)
        }

        // Decoder for LocationUpdate
        Decoders.addDecoder(clazz: LocationUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "LocationUpdate", actual: "\(nameSource)"))
                }
                let _result = LocationUpdate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address1"] as AnyObject?) {
                case let .success(value): _result.address1 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address2"] as AnyObject?) {
                case let .success(value): _result.address2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["cityVillage"] as AnyObject?) {
                case let .success(value): _result.cityVillage = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stateProvince"] as AnyObject?) {
                case let .success(value): _result.stateProvince = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country"] as AnyObject?) {
                case let .success(value): _result.country = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["postalCode"] as AnyObject?) {
                case let .success(value): _result.postalCode = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["latitude"] as AnyObject?) {
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["longitude"] as AnyObject?) {
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["countyDistrict"] as AnyObject?) {
                case let .success(value): _result.countyDistrict = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address3"] as AnyObject?) {
                case let .success(value): _result.address3 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address4"] as AnyObject?) {
                case let .success(value): _result.address4 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address5"] as AnyObject?) {
                case let .success(value): _result.address5 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address6"] as AnyObject?) {
                case let .success(value): _result.address6 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["tags"] as AnyObject?) {
                case let .success(value): _result.tags = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["parentLocation"] as AnyObject?) {
                case let .success(value): _result.parentLocation = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["childLocations"] as AnyObject?) {
                case let .success(value): _result.childLocations = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [LocationattributetypeCreate]
        Decoders.addDecoder(clazz: [LocationattributetypeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationattributetypeCreate]> in
            return Decoders.decode(clazz: [LocationattributetypeCreate].self, source: source)
        }

        // Decoder for LocationattributetypeCreate
        Decoders.addDecoder(clazz: LocationattributetypeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationattributetypeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "LocationattributetypeCreate", actual: "\(nameSource)"))
                }
                guard let datatypeClassnameSource = sourceDictionary["datatypeClassname"] as AnyObject? else {
                    return .failure(.missingKey(key: "datatypeClassname"))
                }
                guard let datatypeClassname = Decoders.decode(clazz: String.self.self, source: datatypeClassnameSource).value else {
                    return .failure(.typeMismatch(expected: "LocationattributetypeCreate", actual: "\(datatypeClassnameSource)"))
                }
                let _result = LocationattributetypeCreate(name: name, datatypeClassname: datatypeClassname)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationattributetypeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [LocationattributetypeCreateFull]
        Decoders.addDecoder(clazz: [LocationattributetypeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationattributetypeCreateFull]> in
            return Decoders.decode(clazz: [LocationattributetypeCreateFull].self, source: source)
        }

        // Decoder for LocationattributetypeCreateFull
        Decoders.addDecoder(clazz: LocationattributetypeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationattributetypeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "LocationattributetypeCreateFull", actual: "\(nameSource)"))
                }
                guard let datatypeClassnameSource = sourceDictionary["datatypeClassname"] as AnyObject? else {
                    return .failure(.missingKey(key: "datatypeClassname"))
                }
                guard let datatypeClassname = Decoders.decode(clazz: String.self.self, source: datatypeClassnameSource).value else {
                    return .failure(.typeMismatch(expected: "LocationattributetypeCreateFull", actual: "\(datatypeClassnameSource)"))
                }
                let _result = LocationattributetypeCreateFull(name: name, datatypeClassname: datatypeClassname)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationattributetypeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [LocationattributetypeGet]
        Decoders.addDecoder(clazz: [LocationattributetypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationattributetypeGet]> in
            return Decoders.decode(clazz: [LocationattributetypeGet].self, source: source)
        }

        // Decoder for LocationattributetypeGet
        Decoders.addDecoder(clazz: LocationattributetypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationattributetypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = LocationattributetypeGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationattributetypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [LocationattributetypeGetFull]
        Decoders.addDecoder(clazz: [LocationattributetypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationattributetypeGetFull]> in
            return Decoders.decode(clazz: [LocationattributetypeGetFull].self, source: source)
        }

        // Decoder for LocationattributetypeGetFull
        Decoders.addDecoder(clazz: LocationattributetypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationattributetypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = LocationattributetypeGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationattributetypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [LocationattributetypeGetRef]
        Decoders.addDecoder(clazz: [LocationattributetypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationattributetypeGetRef]> in
            return Decoders.decode(clazz: [LocationattributetypeGetRef].self, source: source)
        }

        // Decoder for LocationattributetypeGetRef
        Decoders.addDecoder(clazz: LocationattributetypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationattributetypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = LocationattributetypeGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationattributetypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [LocationattributetypeUpdate]
        Decoders.addDecoder(clazz: [LocationattributetypeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationattributetypeUpdate]> in
            return Decoders.decode(clazz: [LocationattributetypeUpdate].self, source: source)
        }

        // Decoder for LocationattributetypeUpdate
        Decoders.addDecoder(clazz: LocationattributetypeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationattributetypeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "LocationattributetypeUpdate", actual: "\(nameSource)"))
                }
                guard let datatypeClassnameSource = sourceDictionary["datatypeClassname"] as AnyObject? else {
                    return .failure(.missingKey(key: "datatypeClassname"))
                }
                guard let datatypeClassname = Decoders.decode(clazz: String.self.self, source: datatypeClassnameSource).value else {
                    return .failure(.typeMismatch(expected: "LocationattributetypeUpdate", actual: "\(datatypeClassnameSource)"))
                }
                let _result = LocationattributetypeUpdate(name: name, datatypeClassname: datatypeClassname)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationattributetypeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [LocationtagCreate]
        Decoders.addDecoder(clazz: [LocationtagCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationtagCreate]> in
            return Decoders.decode(clazz: [LocationtagCreate].self, source: source)
        }

        // Decoder for LocationtagCreate
        Decoders.addDecoder(clazz: LocationtagCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationtagCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "LocationtagCreate", actual: "\(nameSource)"))
                }
                let _result = LocationtagCreate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["retiredReason"] as AnyObject?) {
                case let .success(value): _result.retiredReason = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationtagCreate", actual: "\(source)"))
            }
        }
        // Decoder for [LocationtagCreateFull]
        Decoders.addDecoder(clazz: [LocationtagCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationtagCreateFull]> in
            return Decoders.decode(clazz: [LocationtagCreateFull].self, source: source)
        }

        // Decoder for LocationtagCreateFull
        Decoders.addDecoder(clazz: LocationtagCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationtagCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "LocationtagCreateFull", actual: "\(nameSource)"))
                }
                let _result = LocationtagCreateFull(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["retiredReason"] as AnyObject?) {
                case let .success(value): _result.retiredReason = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationtagCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [LocationtagGet]
        Decoders.addDecoder(clazz: [LocationtagGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationtagGet]> in
            return Decoders.decode(clazz: [LocationtagGet].self, source: source)
        }

        // Decoder for LocationtagGet
        Decoders.addDecoder(clazz: LocationtagGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationtagGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = LocationtagGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationtagGet", actual: "\(source)"))
            }
        }
        // Decoder for [LocationtagGetFull]
        Decoders.addDecoder(clazz: [LocationtagGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationtagGetFull]> in
            return Decoders.decode(clazz: [LocationtagGetFull].self, source: source)
        }

        // Decoder for LocationtagGetFull
        Decoders.addDecoder(clazz: LocationtagGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationtagGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = LocationtagGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationtagGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [LocationtagGetRef]
        Decoders.addDecoder(clazz: [LocationtagGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationtagGetRef]> in
            return Decoders.decode(clazz: [LocationtagGetRef].self, source: source)
        }

        // Decoder for LocationtagGetRef
        Decoders.addDecoder(clazz: LocationtagGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationtagGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = LocationtagGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationtagGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [LocationtagUpdate]
        Decoders.addDecoder(clazz: [LocationtagUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationtagUpdate]> in
            return Decoders.decode(clazz: [LocationtagUpdate].self, source: source)
        }

        // Decoder for LocationtagUpdate
        Decoders.addDecoder(clazz: LocationtagUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationtagUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "LocationtagUpdate", actual: "\(nameSource)"))
                }
                let _result = LocationtagUpdate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["retiredReason"] as AnyObject?) {
                case let .success(value): _result.retiredReason = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationtagUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ModuleGet]
        Decoders.addDecoder(clazz: [ModuleGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ModuleGet]> in
            return Decoders.decode(clazz: [ModuleGet].self, source: source)
        }

        // Decoder for ModuleGet
        Decoders.addDecoder(clazz: ModuleGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ModuleGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ModuleGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["started"] as AnyObject?) {
                case let .success(value): _result.started = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["startupErrorMessage"] as AnyObject?) {
                case let .success(value): _result.startupErrorMessage = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ModuleGet", actual: "\(source)"))
            }
        }
        // Decoder for [ModuleGetFull]
        Decoders.addDecoder(clazz: [ModuleGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ModuleGetFull]> in
            return Decoders.decode(clazz: [ModuleGetFull].self, source: source)
        }

        // Decoder for ModuleGetFull
        Decoders.addDecoder(clazz: ModuleGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ModuleGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ModuleGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["started"] as AnyObject?) {
                case let .success(value): _result.started = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["startupErrorMessage"] as AnyObject?) {
                case let .success(value): _result.startupErrorMessage = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["packageName"] as AnyObject?) {
                case let .success(value): _result.packageName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["author"] as AnyObject?) {
                case let .success(value): _result.author = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["version"] as AnyObject?) {
                case let .success(value): _result.version = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["requireOpenmrsVersion"] as AnyObject?) {
                case let .success(value): _result.requireOpenmrsVersion = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["awareOfModules"] as AnyObject?) {
                case let .success(value): _result.awareOfModules = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["requiredModules"] as AnyObject?) {
                case let .success(value): _result.requiredModules = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ModuleGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ModuleGetRef]
        Decoders.addDecoder(clazz: [ModuleGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ModuleGetRef]> in
            return Decoders.decode(clazz: [ModuleGetRef].self, source: source)
        }

        // Decoder for ModuleGetRef
        Decoders.addDecoder(clazz: ModuleGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ModuleGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ModuleGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ModuleGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ModuleactionCreate]
        Decoders.addDecoder(clazz: [ModuleactionCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ModuleactionCreate]> in
            return Decoders.decode(clazz: [ModuleactionCreate].self, source: source)
        }

        // Decoder for ModuleactionCreate
        Decoders.addDecoder(clazz: ModuleactionCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ModuleactionCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let actionSource = sourceDictionary["action"] as AnyObject? else {
                    return .failure(.missingKey(key: "action"))
                }
                guard let action = Decoders.decode(clazz: ModuleactionCreate.Action.self.self, source: actionSource).value else {
                    return .failure(.typeMismatch(expected: "ModuleactionCreate", actual: "\(actionSource)"))
                }
                let _result = ModuleactionCreate(action: action)
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["modules"] as AnyObject?) {
                case let .success(value): _result.modules = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["allModules"] as AnyObject?) {
                case let .success(value): _result.allModules = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["installUri"] as AnyObject?) {
                case let .success(value): _result.installUri = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ModuleactionCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ModuleactionCreateFull]
        Decoders.addDecoder(clazz: [ModuleactionCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ModuleactionCreateFull]> in
            return Decoders.decode(clazz: [ModuleactionCreateFull].self, source: source)
        }

        // Decoder for ModuleactionCreateFull
        Decoders.addDecoder(clazz: ModuleactionCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ModuleactionCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let actionSource = sourceDictionary["action"] as AnyObject? else {
                    return .failure(.missingKey(key: "action"))
                }
                guard let action = Decoders.decode(clazz: ModuleactionCreateFull.Action.self.self, source: actionSource).value else {
                    return .failure(.typeMismatch(expected: "ModuleactionCreateFull", actual: "\(actionSource)"))
                }
                let _result = ModuleactionCreateFull(action: action)
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["modules"] as AnyObject?) {
                case let .success(value): _result.modules = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["allModules"] as AnyObject?) {
                case let .success(value): _result.allModules = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["installUri"] as AnyObject?) {
                case let .success(value): _result.installUri = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ModuleactionCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ObsCreate]
        Decoders.addDecoder(clazz: [ObsCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ObsCreate]> in
            return Decoders.decode(clazz: [ObsCreate].self, source: source)
        }

        // Decoder for ObsCreate
        Decoders.addDecoder(clazz: ObsCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ObsCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let personSource = sourceDictionary["person"] as AnyObject? else {
                    return .failure(.missingKey(key: "person"))
                }
                guard let person = Decoders.decode(clazz: String.self.self, source: personSource).value else {
                    return .failure(.typeMismatch(expected: "ObsCreate", actual: "\(personSource)"))
                }
                guard let obsDatetimeSource = sourceDictionary["obsDatetime"] as AnyObject? else {
                    return .failure(.missingKey(key: "obsDatetime"))
                }
                guard let obsDatetime = Decoders.decode(clazz: Date.self.self, source: obsDatetimeSource).value else {
                    return .failure(.typeMismatch(expected: "ObsCreate", actual: "\(obsDatetimeSource)"))
                }
                guard let conceptSource = sourceDictionary["concept"] as AnyObject? else {
                    return .failure(.missingKey(key: "concept"))
                }
                guard let concept = Decoders.decode(clazz: String.self.self, source: conceptSource).value else {
                    return .failure(.typeMismatch(expected: "ObsCreate", actual: "\(conceptSource)"))
                }
                let _result = ObsCreate(person: person, obsDatetime: obsDatetime, concept: concept)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["order"] as AnyObject?) {
                case let .success(value): _result.order = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["encounter"] as AnyObject?) {
                case let .success(value): _result.encounter = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["accessionNumber"] as AnyObject?) {
                case let .success(value): _result.accessionNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["groupMembers"] as AnyObject?) {
                case let .success(value): _result.groupMembers = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["valueCodedName"] as AnyObject?) {
                case let .success(value): _result.valueCodedName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["comment"] as AnyObject?) {
                case let .success(value): _result.comment = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["valueModifier"] as AnyObject?) {
                case let .success(value): _result.valueModifier = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formFieldPath"] as AnyObject?) {
                case let .success(value): _result.formFieldPath = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formFieldNamespace"] as AnyObject?) {
                case let .success(value): _result.formFieldNamespace = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ObsCreate.Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ObsCreate.Interpretation.self, source: sourceDictionary["interpretation"] as AnyObject?) {
                case let .success(value): _result.interpretation = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ObsCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ObsCreateFull]
        Decoders.addDecoder(clazz: [ObsCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ObsCreateFull]> in
            return Decoders.decode(clazz: [ObsCreateFull].self, source: source)
        }

        // Decoder for ObsCreateFull
        Decoders.addDecoder(clazz: ObsCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ObsCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let personSource = sourceDictionary["person"] as AnyObject? else {
                    return .failure(.missingKey(key: "person"))
                }
                guard let person = Decoders.decode(clazz: String.self.self, source: personSource).value else {
                    return .failure(.typeMismatch(expected: "ObsCreateFull", actual: "\(personSource)"))
                }
                guard let obsDatetimeSource = sourceDictionary["obsDatetime"] as AnyObject? else {
                    return .failure(.missingKey(key: "obsDatetime"))
                }
                guard let obsDatetime = Decoders.decode(clazz: Date.self.self, source: obsDatetimeSource).value else {
                    return .failure(.typeMismatch(expected: "ObsCreateFull", actual: "\(obsDatetimeSource)"))
                }
                guard let conceptSource = sourceDictionary["concept"] as AnyObject? else {
                    return .failure(.missingKey(key: "concept"))
                }
                guard let concept = Decoders.decode(clazz: String.self.self, source: conceptSource).value else {
                    return .failure(.typeMismatch(expected: "ObsCreateFull", actual: "\(conceptSource)"))
                }
                let _result = ObsCreateFull(person: person, obsDatetime: obsDatetime, concept: concept)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["order"] as AnyObject?) {
                case let .success(value): _result.order = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["encounter"] as AnyObject?) {
                case let .success(value): _result.encounter = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["accessionNumber"] as AnyObject?) {
                case let .success(value): _result.accessionNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["groupMembers"] as AnyObject?) {
                case let .success(value): _result.groupMembers = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["valueCodedName"] as AnyObject?) {
                case let .success(value): _result.valueCodedName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["comment"] as AnyObject?) {
                case let .success(value): _result.comment = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["valueModifier"] as AnyObject?) {
                case let .success(value): _result.valueModifier = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formFieldPath"] as AnyObject?) {
                case let .success(value): _result.formFieldPath = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formFieldNamespace"] as AnyObject?) {
                case let .success(value): _result.formFieldNamespace = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ObsCreateFull.Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ObsCreateFull.Interpretation.self, source: sourceDictionary["interpretation"] as AnyObject?) {
                case let .success(value): _result.interpretation = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ObsCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ObsGet]
        Decoders.addDecoder(clazz: [ObsGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ObsGet]> in
            return Decoders.decode(clazz: [ObsGet].self, source: source)
        }

        // Decoder for ObsGet
        Decoders.addDecoder(clazz: ObsGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ObsGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ObsGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["obsDatetime"] as AnyObject?) {
                case let .success(value): _result.obsDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["accessionNumber"] as AnyObject?) {
                case let .success(value): _result.accessionNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["comment"] as AnyObject?) {
                case let .success(value): _result.comment = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["valueModifier"] as AnyObject?) {
                case let .success(value): _result.valueModifier = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonGetRef.self, source: sourceDictionary["person"] as AnyObject?) {
                case let .success(value): _result.person = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ObsGetRef.self, source: sourceDictionary["obsGroup"] as AnyObject?) {
                case let .success(value): _result.obsGroup = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ObsGetRef].self, source: sourceDictionary["groupMembers"] as AnyObject?) {
                case let .success(value): _result.groupMembers = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptNameGetRef.self, source: sourceDictionary["valueCodedName"] as AnyObject?) {
                case let .success(value): _result.valueCodedName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationGetRef.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrderGetRef.self, source: sourceDictionary["order"] as AnyObject?) {
                case let .success(value): _result.order = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: EncounterGetRef.self, source: sourceDictionary["encounter"] as AnyObject?) {
                case let .success(value): _result.encounter = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formFieldPath"] as AnyObject?) {
                case let .success(value): _result.formFieldPath = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formFieldNamespace"] as AnyObject?) {
                case let .success(value): _result.formFieldNamespace = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ObsGet.Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ObsGet.Interpretation.self, source: sourceDictionary["interpretation"] as AnyObject?) {
                case let .success(value): _result.interpretation = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ObsGet", actual: "\(source)"))
            }
        }
        // Decoder for [ObsGetFull]
        Decoders.addDecoder(clazz: [ObsGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ObsGetFull]> in
            return Decoders.decode(clazz: [ObsGetFull].self, source: source)
        }

        // Decoder for ObsGetFull
        Decoders.addDecoder(clazz: ObsGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ObsGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ObsGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["obsDatetime"] as AnyObject?) {
                case let .success(value): _result.obsDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["accessionNumber"] as AnyObject?) {
                case let .success(value): _result.accessionNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["comment"] as AnyObject?) {
                case let .success(value): _result.comment = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["valueModifier"] as AnyObject?) {
                case let .success(value): _result.valueModifier = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonGet.self, source: sourceDictionary["person"] as AnyObject?) {
                case let .success(value): _result.person = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ObsGet.self, source: sourceDictionary["obsGroup"] as AnyObject?) {
                case let .success(value): _result.obsGroup = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ObsGet].self, source: sourceDictionary["groupMembers"] as AnyObject?) {
                case let .success(value): _result.groupMembers = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptNameGet.self, source: sourceDictionary["valueCodedName"] as AnyObject?) {
                case let .success(value): _result.valueCodedName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationGet.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrderGet.self, source: sourceDictionary["order"] as AnyObject?) {
                case let .success(value): _result.order = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: EncounterGet.self, source: sourceDictionary["encounter"] as AnyObject?) {
                case let .success(value): _result.encounter = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formFieldPath"] as AnyObject?) {
                case let .success(value): _result.formFieldPath = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formFieldNamespace"] as AnyObject?) {
                case let .success(value): _result.formFieldNamespace = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ObsGetFull.Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ObsGetFull.Interpretation.self, source: sourceDictionary["interpretation"] as AnyObject?) {
                case let .success(value): _result.interpretation = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ObsGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ObsGetRef]
        Decoders.addDecoder(clazz: [ObsGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ObsGetRef]> in
            return Decoders.decode(clazz: [ObsGetRef].self, source: source)
        }

        // Decoder for ObsGetRef
        Decoders.addDecoder(clazz: ObsGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ObsGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ObsGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formFieldPath"] as AnyObject?) {
                case let .success(value): _result.formFieldPath = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formFieldNamespace"] as AnyObject?) {
                case let .success(value): _result.formFieldNamespace = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ObsGetRef.Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ObsGetRef.Interpretation.self, source: sourceDictionary["interpretation"] as AnyObject?) {
                case let .success(value): _result.interpretation = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ObsGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ObsUpdate]
        Decoders.addDecoder(clazz: [ObsUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ObsUpdate]> in
            return Decoders.decode(clazz: [ObsUpdate].self, source: source)
        }

        // Decoder for ObsUpdate
        Decoders.addDecoder(clazz: ObsUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ObsUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ObsUpdate()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ObsUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [OrderCreate]
        Decoders.addDecoder(clazz: [OrderCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrderCreate]> in
            return Decoders.decode(clazz: [OrderCreate].self, source: source)
        }

        // Decoder for OrderCreate
        Decoders.addDecoder(clazz: OrderCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrderCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let orderTypeSource = sourceDictionary["orderType"] as AnyObject? else {
                    return .failure(.missingKey(key: "orderType"))
                }
                guard let orderType = Decoders.decode(clazz: String.self.self, source: orderTypeSource).value else {
                    return .failure(.typeMismatch(expected: "OrderCreate", actual: "\(orderTypeSource)"))
                }
                guard let patientSource = sourceDictionary["patient"] as AnyObject? else {
                    return .failure(.missingKey(key: "patient"))
                }
                guard let patient = Decoders.decode(clazz: String.self.self, source: patientSource).value else {
                    return .failure(.typeMismatch(expected: "OrderCreate", actual: "\(patientSource)"))
                }
                guard let conceptSource = sourceDictionary["concept"] as AnyObject? else {
                    return .failure(.missingKey(key: "concept"))
                }
                guard let concept = Decoders.decode(clazz: String.self.self, source: conceptSource).value else {
                    return .failure(.typeMismatch(expected: "OrderCreate", actual: "\(conceptSource)"))
                }
                let _result = OrderCreate(orderType: orderType, patient: patient, concept: concept)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["encounter"] as AnyObject?) {
                case let .success(value): _result.encounter = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrderCreate.Action.self, source: sourceDictionary["action"] as AnyObject?) {
                case let .success(value): _result.action = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["accessionNumber"] as AnyObject?) {
                case let .success(value): _result.accessionNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["dateActivated"] as AnyObject?) {
                case let .success(value): _result.dateActivated = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["scheduledDate"] as AnyObject?) {
                case let .success(value): _result.scheduledDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["careSetting"] as AnyObject?) {
                case let .success(value): _result.careSetting = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["dateStopped"] as AnyObject?) {
                case let .success(value): _result.dateStopped = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["autoExpireDate"] as AnyObject?) {
                case let .success(value): _result.autoExpireDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["orderer"] as AnyObject?) {
                case let .success(value): _result.orderer = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["previousOrder"] as AnyObject?) {
                case let .success(value): _result.previousOrder = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrderCreate.Urgency.self, source: sourceDictionary["urgency"] as AnyObject?) {
                case let .success(value): _result.urgency = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["orderReason"] as AnyObject?) {
                case let .success(value): _result.orderReason = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["orderReasonNonCoded"] as AnyObject?) {
                case let .success(value): _result.orderReasonNonCoded = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["instructions"] as AnyObject?) {
                case let .success(value): _result.instructions = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["commentToFulfiller"] as AnyObject?) {
                case let .success(value): _result.commentToFulfiller = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrderCreate", actual: "\(source)"))
            }
        }
        // Decoder for [OrderCreateFull]
        Decoders.addDecoder(clazz: [OrderCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrderCreateFull]> in
            return Decoders.decode(clazz: [OrderCreateFull].self, source: source)
        }

        // Decoder for OrderCreateFull
        Decoders.addDecoder(clazz: OrderCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrderCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let orderTypeSource = sourceDictionary["orderType"] as AnyObject? else {
                    return .failure(.missingKey(key: "orderType"))
                }
                guard let orderType = Decoders.decode(clazz: String.self.self, source: orderTypeSource).value else {
                    return .failure(.typeMismatch(expected: "OrderCreateFull", actual: "\(orderTypeSource)"))
                }
                guard let patientSource = sourceDictionary["patient"] as AnyObject? else {
                    return .failure(.missingKey(key: "patient"))
                }
                guard let patient = Decoders.decode(clazz: PatientCreate.self.self, source: patientSource).value else {
                    return .failure(.typeMismatch(expected: "OrderCreateFull", actual: "\(patientSource)"))
                }
                guard let conceptSource = sourceDictionary["concept"] as AnyObject? else {
                    return .failure(.missingKey(key: "concept"))
                }
                guard let concept = Decoders.decode(clazz: ConceptCreate.self.self, source: conceptSource).value else {
                    return .failure(.typeMismatch(expected: "OrderCreateFull", actual: "\(conceptSource)"))
                }
                let _result = OrderCreateFull(orderType: orderType, patient: patient, concept: concept)
                switch Decoders.decodeOptional(clazz: EncounterCreate.self, source: sourceDictionary["encounter"] as AnyObject?) {
                case let .success(value): _result.encounter = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrderCreateFull.Action.self, source: sourceDictionary["action"] as AnyObject?) {
                case let .success(value): _result.action = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["accessionNumber"] as AnyObject?) {
                case let .success(value): _result.accessionNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["dateActivated"] as AnyObject?) {
                case let .success(value): _result.dateActivated = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["scheduledDate"] as AnyObject?) {
                case let .success(value): _result.scheduledDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["careSetting"] as AnyObject?) {
                case let .success(value): _result.careSetting = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["dateStopped"] as AnyObject?) {
                case let .success(value): _result.dateStopped = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["autoExpireDate"] as AnyObject?) {
                case let .success(value): _result.autoExpireDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: UserCreate.self, source: sourceDictionary["orderer"] as AnyObject?) {
                case let .success(value): _result.orderer = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrderCreate.self, source: sourceDictionary["previousOrder"] as AnyObject?) {
                case let .success(value): _result.previousOrder = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrderCreateFull.Urgency.self, source: sourceDictionary["urgency"] as AnyObject?) {
                case let .success(value): _result.urgency = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptCreate.self, source: sourceDictionary["orderReason"] as AnyObject?) {
                case let .success(value): _result.orderReason = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["orderReasonNonCoded"] as AnyObject?) {
                case let .success(value): _result.orderReasonNonCoded = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["instructions"] as AnyObject?) {
                case let .success(value): _result.instructions = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["commentToFulfiller"] as AnyObject?) {
                case let .success(value): _result.commentToFulfiller = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrderCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [OrderGet]
        Decoders.addDecoder(clazz: [OrderGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrderGet]> in
            return Decoders.decode(clazz: [OrderGet].self, source: source)
        }

        // Decoder for OrderGet
        Decoders.addDecoder(clazz: OrderGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrderGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = OrderGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["instructions"] as AnyObject?) {
                case let .success(value): _result.instructions = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["autoExpireDate"] as AnyObject?) {
                case let .success(value): _result.autoExpireDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["accessionNumber"] as AnyObject?) {
                case let .success(value): _result.accessionNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["discontinuedDate"] as AnyObject?) {
                case let .success(value): _result.discontinuedDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["discontinuedReasonNonCoded"] as AnyObject?) {
                case let .success(value): _result.discontinuedReasonNonCoded = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrdertypeGetRef.self, source: sourceDictionary["orderType"] as AnyObject?) {
                case let .success(value): _result.orderType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientGetRef.self, source: sourceDictionary["patient"] as AnyObject?) {
                case let .success(value): _result.patient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: EncounterGetRef.self, source: sourceDictionary["encounter"] as AnyObject?) {
                case let .success(value): _result.encounter = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: UserGetRef.self, source: sourceDictionary["orderer"] as AnyObject?) {
                case let .success(value): _result.orderer = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: UserGetRef.self, source: sourceDictionary["discontinuedBy"] as AnyObject?) {
                case let .success(value): _result.discontinuedBy = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["discontinuedReason"] as AnyObject?) {
                case let .success(value): _result.discontinuedReason = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrderGet", actual: "\(source)"))
            }
        }
        // Decoder for [OrderGetFull]
        Decoders.addDecoder(clazz: [OrderGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrderGetFull]> in
            return Decoders.decode(clazz: [OrderGetFull].self, source: source)
        }

        // Decoder for OrderGetFull
        Decoders.addDecoder(clazz: OrderGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrderGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = OrderGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["instructions"] as AnyObject?) {
                case let .success(value): _result.instructions = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["autoExpireDate"] as AnyObject?) {
                case let .success(value): _result.autoExpireDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["accessionNumber"] as AnyObject?) {
                case let .success(value): _result.accessionNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["discontinuedDate"] as AnyObject?) {
                case let .success(value): _result.discontinuedDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["discontinuedReasonNonCoded"] as AnyObject?) {
                case let .success(value): _result.discontinuedReasonNonCoded = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrdertypeGet.self, source: sourceDictionary["orderType"] as AnyObject?) {
                case let .success(value): _result.orderType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientGet.self, source: sourceDictionary["patient"] as AnyObject?) {
                case let .success(value): _result.patient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: EncounterGet.self, source: sourceDictionary["encounter"] as AnyObject?) {
                case let .success(value): _result.encounter = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: UserGet.self, source: sourceDictionary["orderer"] as AnyObject?) {
                case let .success(value): _result.orderer = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: UserGet.self, source: sourceDictionary["discontinuedBy"] as AnyObject?) {
                case let .success(value): _result.discontinuedBy = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["discontinuedReason"] as AnyObject?) {
                case let .success(value): _result.discontinuedReason = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrderGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [OrderGetRef]
        Decoders.addDecoder(clazz: [OrderGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrderGetRef]> in
            return Decoders.decode(clazz: [OrderGetRef].self, source: source)
        }

        // Decoder for OrderGetRef
        Decoders.addDecoder(clazz: OrderGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrderGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = OrderGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrderGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [OrderfrequencyGet]
        Decoders.addDecoder(clazz: [OrderfrequencyGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrderfrequencyGet]> in
            return Decoders.decode(clazz: [OrderfrequencyGet].self, source: source)
        }

        // Decoder for OrderfrequencyGet
        Decoders.addDecoder(clazz: OrderfrequencyGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrderfrequencyGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = OrderfrequencyGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrderfrequencyGet", actual: "\(source)"))
            }
        }
        // Decoder for [OrderfrequencyGetFull]
        Decoders.addDecoder(clazz: [OrderfrequencyGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrderfrequencyGetFull]> in
            return Decoders.decode(clazz: [OrderfrequencyGetFull].self, source: source)
        }

        // Decoder for OrderfrequencyGetFull
        Decoders.addDecoder(clazz: OrderfrequencyGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrderfrequencyGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = OrderfrequencyGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrderfrequencyGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [OrderfrequencyGetRef]
        Decoders.addDecoder(clazz: [OrderfrequencyGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrderfrequencyGetRef]> in
            return Decoders.decode(clazz: [OrderfrequencyGetRef].self, source: source)
        }

        // Decoder for OrderfrequencyGetRef
        Decoders.addDecoder(clazz: OrderfrequencyGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrderfrequencyGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = OrderfrequencyGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrderfrequencyGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [OrderfrequencyUpdate]
        Decoders.addDecoder(clazz: [OrderfrequencyUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrderfrequencyUpdate]> in
            return Decoders.decode(clazz: [OrderfrequencyUpdate].self, source: source)
        }

        // Decoder for OrderfrequencyUpdate
        Decoders.addDecoder(clazz: OrderfrequencyUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrderfrequencyUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "OrderfrequencyUpdate", actual: "\(nameSource)"))
                }
                let _result = OrderfrequencyUpdate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrderfrequencyUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [OrdersetCreate]
        Decoders.addDecoder(clazz: [OrdersetCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdersetCreate]> in
            return Decoders.decode(clazz: [OrdersetCreate].self, source: source)
        }

        // Decoder for OrdersetCreate
        Decoders.addDecoder(clazz: OrdersetCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdersetCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = OrdersetCreate()
                switch Decoders.decodeOptional(clazz: OrdersetCreate.Operator.self, source: sourceDictionary["operator"] as AnyObject?) {
                case let .success(value): _result._operator = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [OrdersetOrdersetmemberCreate].self, source: sourceDictionary["orderSetMembers"] as AnyObject?) {
                case let .success(value): _result.orderSetMembers = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdersetCreate", actual: "\(source)"))
            }
        }
        // Decoder for [OrdersetCreateFull]
        Decoders.addDecoder(clazz: [OrdersetCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdersetCreateFull]> in
            return Decoders.decode(clazz: [OrdersetCreateFull].self, source: source)
        }

        // Decoder for OrdersetCreateFull
        Decoders.addDecoder(clazz: OrdersetCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdersetCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = OrdersetCreateFull()
                switch Decoders.decodeOptional(clazz: OrdersetCreateFull.Operator.self, source: sourceDictionary["operator"] as AnyObject?) {
                case let .success(value): _result._operator = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [OrdersetOrdersetmemberCreate].self, source: sourceDictionary["orderSetMembers"] as AnyObject?) {
                case let .success(value): _result.orderSetMembers = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdersetCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [OrdersetGet]
        Decoders.addDecoder(clazz: [OrdersetGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdersetGet]> in
            return Decoders.decode(clazz: [OrdersetGet].self, source: source)
        }

        // Decoder for OrdersetGet
        Decoders.addDecoder(clazz: OrdersetGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdersetGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = OrdersetGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrdersetGet.Operator.self, source: sourceDictionary["operator"] as AnyObject?) {
                case let .success(value): _result._operator = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [OrdersetOrdersetmemberGetRef].self, source: sourceDictionary["orderSetMembers"] as AnyObject?) {
                case let .success(value): _result.orderSetMembers = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdersetGet", actual: "\(source)"))
            }
        }
        // Decoder for [OrdersetGetFull]
        Decoders.addDecoder(clazz: [OrdersetGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdersetGetFull]> in
            return Decoders.decode(clazz: [OrdersetGetFull].self, source: source)
        }

        // Decoder for OrdersetGetFull
        Decoders.addDecoder(clazz: OrdersetGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdersetGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = OrdersetGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrdersetGetFull.Operator.self, source: sourceDictionary["operator"] as AnyObject?) {
                case let .success(value): _result._operator = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [OrdersetOrdersetmemberGet].self, source: sourceDictionary["orderSetMembers"] as AnyObject?) {
                case let .success(value): _result.orderSetMembers = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdersetGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [OrdersetGetRef]
        Decoders.addDecoder(clazz: [OrdersetGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdersetGetRef]> in
            return Decoders.decode(clazz: [OrdersetGetRef].self, source: source)
        }

        // Decoder for OrdersetGetRef
        Decoders.addDecoder(clazz: OrdersetGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdersetGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = OrdersetGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdersetGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [OrdersetOrdersetmemberCreate]
        Decoders.addDecoder(clazz: [OrdersetOrdersetmemberCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdersetOrdersetmemberCreate]> in
            return Decoders.decode(clazz: [OrdersetOrdersetmemberCreate].self, source: source)
        }

        // Decoder for OrdersetOrdersetmemberCreate
        Decoders.addDecoder(clazz: OrdersetOrdersetmemberCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdersetOrdersetmemberCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = OrdersetOrdersetmemberCreate()
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["orderType"] as AnyObject?) {
                case let .success(value): _result.orderType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["orderTemplate"] as AnyObject?) {
                case let .success(value): _result.orderTemplate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdersetOrdersetmemberCreate", actual: "\(source)"))
            }
        }
        // Decoder for [OrdersetOrdersetmemberCreateFull]
        Decoders.addDecoder(clazz: [OrdersetOrdersetmemberCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdersetOrdersetmemberCreateFull]> in
            return Decoders.decode(clazz: [OrdersetOrdersetmemberCreateFull].self, source: source)
        }

        // Decoder for OrdersetOrdersetmemberCreateFull
        Decoders.addDecoder(clazz: OrdersetOrdersetmemberCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdersetOrdersetmemberCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = OrdersetOrdersetmemberCreateFull()
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["orderType"] as AnyObject?) {
                case let .success(value): _result.orderType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["orderTemplate"] as AnyObject?) {
                case let .success(value): _result.orderTemplate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdersetOrdersetmemberCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [OrdersetOrdersetmemberGet]
        Decoders.addDecoder(clazz: [OrdersetOrdersetmemberGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdersetOrdersetmemberGet]> in
            return Decoders.decode(clazz: [OrdersetOrdersetmemberGet].self, source: source)
        }

        // Decoder for OrdersetOrdersetmemberGet
        Decoders.addDecoder(clazz: OrdersetOrdersetmemberGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdersetOrdersetmemberGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = OrdersetOrdersetmemberGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["orderTemplate"] as AnyObject?) {
                case let .success(value): _result.orderTemplate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["orderTemplateType"] as AnyObject?) {
                case let .success(value): _result.orderTemplateType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrdertypeGetRef.self, source: sourceDictionary["orderType"] as AnyObject?) {
                case let .success(value): _result.orderType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdersetOrdersetmemberGet", actual: "\(source)"))
            }
        }
        // Decoder for [OrdersetOrdersetmemberGetFull]
        Decoders.addDecoder(clazz: [OrdersetOrdersetmemberGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdersetOrdersetmemberGetFull]> in
            return Decoders.decode(clazz: [OrdersetOrdersetmemberGetFull].self, source: source)
        }

        // Decoder for OrdersetOrdersetmemberGetFull
        Decoders.addDecoder(clazz: OrdersetOrdersetmemberGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdersetOrdersetmemberGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = OrdersetOrdersetmemberGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["orderTemplate"] as AnyObject?) {
                case let .success(value): _result.orderTemplate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["orderTemplateType"] as AnyObject?) {
                case let .success(value): _result.orderTemplateType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrdertypeGet.self, source: sourceDictionary["orderType"] as AnyObject?) {
                case let .success(value): _result.orderType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdersetOrdersetmemberGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [OrdersetOrdersetmemberGetRef]
        Decoders.addDecoder(clazz: [OrdersetOrdersetmemberGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdersetOrdersetmemberGetRef]> in
            return Decoders.decode(clazz: [OrdersetOrdersetmemberGetRef].self, source: source)
        }

        // Decoder for OrdersetOrdersetmemberGetRef
        Decoders.addDecoder(clazz: OrdersetOrdersetmemberGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdersetOrdersetmemberGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = OrdersetOrdersetmemberGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdersetOrdersetmemberGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [OrdersetOrdersetmemberUpdate]
        Decoders.addDecoder(clazz: [OrdersetOrdersetmemberUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdersetOrdersetmemberUpdate]> in
            return Decoders.decode(clazz: [OrdersetOrdersetmemberUpdate].self, source: source)
        }

        // Decoder for OrdersetOrdersetmemberUpdate
        Decoders.addDecoder(clazz: OrdersetOrdersetmemberUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdersetOrdersetmemberUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = OrdersetOrdersetmemberUpdate()
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["orderType"] as AnyObject?) {
                case let .success(value): _result.orderType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["orderTemplate"] as AnyObject?) {
                case let .success(value): _result.orderTemplate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdersetOrdersetmemberUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [OrdersetUpdate]
        Decoders.addDecoder(clazz: [OrdersetUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdersetUpdate]> in
            return Decoders.decode(clazz: [OrdersetUpdate].self, source: source)
        }

        // Decoder for OrdersetUpdate
        Decoders.addDecoder(clazz: OrdersetUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdersetUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = OrdersetUpdate()
                switch Decoders.decodeOptional(clazz: OrdersetUpdate.Operator.self, source: sourceDictionary["operator"] as AnyObject?) {
                case let .success(value): _result._operator = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [OrdersetOrdersetmemberCreate].self, source: sourceDictionary["orderSetMembers"] as AnyObject?) {
                case let .success(value): _result.orderSetMembers = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdersetUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [OrdertypeCreate]
        Decoders.addDecoder(clazz: [OrdertypeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdertypeCreate]> in
            return Decoders.decode(clazz: [OrdertypeCreate].self, source: source)
        }

        // Decoder for OrdertypeCreate
        Decoders.addDecoder(clazz: OrdertypeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdertypeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "OrdertypeCreate", actual: "\(nameSource)"))
                }
                guard let javaClassNameSource = sourceDictionary["javaClassName"] as AnyObject? else {
                    return .failure(.missingKey(key: "javaClassName"))
                }
                guard let javaClassName = Decoders.decode(clazz: String.self.self, source: javaClassNameSource).value else {
                    return .failure(.typeMismatch(expected: "OrdertypeCreate", actual: "\(javaClassNameSource)"))
                }
                let _result = OrdertypeCreate(name: name, javaClassName: javaClassName)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["parent"] as AnyObject?) {
                case let .success(value): _result.parent = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["conceptClasses"] as AnyObject?) {
                case let .success(value): _result.conceptClasses = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdertypeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [OrdertypeCreateFull]
        Decoders.addDecoder(clazz: [OrdertypeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdertypeCreateFull]> in
            return Decoders.decode(clazz: [OrdertypeCreateFull].self, source: source)
        }

        // Decoder for OrdertypeCreateFull
        Decoders.addDecoder(clazz: OrdertypeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdertypeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "OrdertypeCreateFull", actual: "\(nameSource)"))
                }
                guard let javaClassNameSource = sourceDictionary["javaClassName"] as AnyObject? else {
                    return .failure(.missingKey(key: "javaClassName"))
                }
                guard let javaClassName = Decoders.decode(clazz: String.self.self, source: javaClassNameSource).value else {
                    return .failure(.typeMismatch(expected: "OrdertypeCreateFull", actual: "\(javaClassNameSource)"))
                }
                let _result = OrdertypeCreateFull(name: name, javaClassName: javaClassName)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["parent"] as AnyObject?) {
                case let .success(value): _result.parent = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["conceptClasses"] as AnyObject?) {
                case let .success(value): _result.conceptClasses = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdertypeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [OrdertypeGet]
        Decoders.addDecoder(clazz: [OrdertypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdertypeGet]> in
            return Decoders.decode(clazz: [OrdertypeGet].self, source: source)
        }

        // Decoder for OrdertypeGet
        Decoders.addDecoder(clazz: OrdertypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdertypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = OrdertypeGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["javaClassName"] as AnyObject?) {
                case let .success(value): _result.javaClassName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ConceptclassGetRef].self, source: sourceDictionary["conceptClasses"] as AnyObject?) {
                case let .success(value): _result.conceptClasses = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrdertypeGetRef.self, source: sourceDictionary["parent"] as AnyObject?) {
                case let .success(value): _result.parent = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdertypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [OrdertypeGetFull]
        Decoders.addDecoder(clazz: [OrdertypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdertypeGetFull]> in
            return Decoders.decode(clazz: [OrdertypeGetFull].self, source: source)
        }

        // Decoder for OrdertypeGetFull
        Decoders.addDecoder(clazz: OrdertypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdertypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = OrdertypeGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["javaClassName"] as AnyObject?) {
                case let .success(value): _result.javaClassName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ConceptclassGet].self, source: sourceDictionary["conceptClasses"] as AnyObject?) {
                case let .success(value): _result.conceptClasses = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrdertypeGet.self, source: sourceDictionary["parent"] as AnyObject?) {
                case let .success(value): _result.parent = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdertypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [OrdertypeGetRef]
        Decoders.addDecoder(clazz: [OrdertypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdertypeGetRef]> in
            return Decoders.decode(clazz: [OrdertypeGetRef].self, source: source)
        }

        // Decoder for OrdertypeGetRef
        Decoders.addDecoder(clazz: OrdertypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdertypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = OrdertypeGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdertypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [OrdertypeUpdate]
        Decoders.addDecoder(clazz: [OrdertypeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdertypeUpdate]> in
            return Decoders.decode(clazz: [OrdertypeUpdate].self, source: source)
        }

        // Decoder for OrdertypeUpdate
        Decoders.addDecoder(clazz: OrdertypeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdertypeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "OrdertypeUpdate", actual: "\(nameSource)"))
                }
                guard let javaClassNameSource = sourceDictionary["javaClassName"] as AnyObject? else {
                    return .failure(.missingKey(key: "javaClassName"))
                }
                guard let javaClassName = Decoders.decode(clazz: String.self.self, source: javaClassNameSource).value else {
                    return .failure(.typeMismatch(expected: "OrdertypeUpdate", actual: "\(javaClassNameSource)"))
                }
                let _result = OrdertypeUpdate(name: name, javaClassName: javaClassName)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["parent"] as AnyObject?) {
                case let .success(value): _result.parent = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["conceptClasses"] as AnyObject?) {
                case let .success(value): _result.conceptClasses = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdertypeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [PatientAllergyCreate]
        Decoders.addDecoder(clazz: [PatientAllergyCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientAllergyCreate]> in
            return Decoders.decode(clazz: [PatientAllergyCreate].self, source: source)
        }

        // Decoder for PatientAllergyCreate
        Decoders.addDecoder(clazz: PatientAllergyCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientAllergyCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let allergenSource = sourceDictionary["allergen"] as AnyObject? else {
                    return .failure(.missingKey(key: "allergen"))
                }
                guard let allergen = Decoders.decode(clazz: Any.self.self, source: allergenSource).value else {
                    return .failure(.typeMismatch(expected: "PatientAllergyCreate", actual: "\(allergenSource)"))
                }
                let _result = PatientAllergyCreate(allergen: allergen)
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["severity"] as AnyObject?) {
                case let .success(value): _result.severity = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["comment"] as AnyObject?) {
                case let .success(value): _result.comment = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Any].self, source: sourceDictionary["reactions"] as AnyObject?) {
                case let .success(value): _result.reactions = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientAllergyCreate", actual: "\(source)"))
            }
        }
        // Decoder for [PatientAllergyCreateFull]
        Decoders.addDecoder(clazz: [PatientAllergyCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientAllergyCreateFull]> in
            return Decoders.decode(clazz: [PatientAllergyCreateFull].self, source: source)
        }

        // Decoder for PatientAllergyCreateFull
        Decoders.addDecoder(clazz: PatientAllergyCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientAllergyCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let allergenSource = sourceDictionary["allergen"] as AnyObject? else {
                    return .failure(.missingKey(key: "allergen"))
                }
                guard let allergen = Decoders.decode(clazz: Any.self.self, source: allergenSource).value else {
                    return .failure(.typeMismatch(expected: "PatientAllergyCreateFull", actual: "\(allergenSource)"))
                }
                let _result = PatientAllergyCreateFull(allergen: allergen)
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["severity"] as AnyObject?) {
                case let .success(value): _result.severity = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["comment"] as AnyObject?) {
                case let .success(value): _result.comment = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Any].self, source: sourceDictionary["reactions"] as AnyObject?) {
                case let .success(value): _result.reactions = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientAllergyCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [PatientAllergyGet]
        Decoders.addDecoder(clazz: [PatientAllergyGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientAllergyGet]> in
            return Decoders.decode(clazz: [PatientAllergyGet].self, source: source)
        }

        // Decoder for PatientAllergyGet
        Decoders.addDecoder(clazz: PatientAllergyGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientAllergyGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PatientAllergyGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["allergen"] as AnyObject?) {
                case let .success(value): _result.allergen = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["severity"] as AnyObject?) {
                case let .success(value): _result.severity = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["comment"] as AnyObject?) {
                case let .success(value): _result.comment = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ConceptGetRef].self, source: sourceDictionary["reactions"] as AnyObject?) {
                case let .success(value): _result.reactions = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientGetRef.self, source: sourceDictionary["patient"] as AnyObject?) {
                case let .success(value): _result.patient = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientAllergyGet", actual: "\(source)"))
            }
        }
        // Decoder for [PatientAllergyGetFull]
        Decoders.addDecoder(clazz: [PatientAllergyGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientAllergyGetFull]> in
            return Decoders.decode(clazz: [PatientAllergyGetFull].self, source: source)
        }

        // Decoder for PatientAllergyGetFull
        Decoders.addDecoder(clazz: PatientAllergyGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientAllergyGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PatientAllergyGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["allergen"] as AnyObject?) {
                case let .success(value): _result.allergen = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["severity"] as AnyObject?) {
                case let .success(value): _result.severity = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["comment"] as AnyObject?) {
                case let .success(value): _result.comment = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ConceptGet].self, source: sourceDictionary["reactions"] as AnyObject?) {
                case let .success(value): _result.reactions = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientGet.self, source: sourceDictionary["patient"] as AnyObject?) {
                case let .success(value): _result.patient = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientAllergyGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [PatientAllergyGetRef]
        Decoders.addDecoder(clazz: [PatientAllergyGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientAllergyGetRef]> in
            return Decoders.decode(clazz: [PatientAllergyGetRef].self, source: source)
        }

        // Decoder for PatientAllergyGetRef
        Decoders.addDecoder(clazz: PatientAllergyGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientAllergyGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PatientAllergyGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientAllergyGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [PatientAllergyUpdate]
        Decoders.addDecoder(clazz: [PatientAllergyUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientAllergyUpdate]> in
            return Decoders.decode(clazz: [PatientAllergyUpdate].self, source: source)
        }

        // Decoder for PatientAllergyUpdate
        Decoders.addDecoder(clazz: PatientAllergyUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientAllergyUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let allergenSource = sourceDictionary["allergen"] as AnyObject? else {
                    return .failure(.missingKey(key: "allergen"))
                }
                guard let allergen = Decoders.decode(clazz: Any.self.self, source: allergenSource).value else {
                    return .failure(.typeMismatch(expected: "PatientAllergyUpdate", actual: "\(allergenSource)"))
                }
                let _result = PatientAllergyUpdate(allergen: allergen)
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["severity"] as AnyObject?) {
                case let .success(value): _result.severity = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["comment"] as AnyObject?) {
                case let .success(value): _result.comment = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Any].self, source: sourceDictionary["reactions"] as AnyObject?) {
                case let .success(value): _result.reactions = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientAllergyUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [PatientCreate]
        Decoders.addDecoder(clazz: [PatientCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientCreate]> in
            return Decoders.decode(clazz: [PatientCreate].self, source: source)
        }

        // Decoder for PatientCreate
        Decoders.addDecoder(clazz: PatientCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let personSource = sourceDictionary["person"] as AnyObject? else {
                    return .failure(.missingKey(key: "person"))
                }
                guard let person = Decoders.decode(clazz: String.self.self, source: personSource).value else {
                    return .failure(.typeMismatch(expected: "PatientCreate", actual: "\(personSource)"))
                }
                guard let identifiersSource = sourceDictionary["identifiers"] as AnyObject? else {
                    return .failure(.missingKey(key: "identifiers"))
                }
                guard let identifiers = Decoders.decode(clazz: [PatientIdentifierCreate].self.self, source: identifiersSource).value else {
                    return .failure(.typeMismatch(expected: "PatientCreate", actual: "\(identifiersSource)"))
                }
                let _result = PatientCreate(person: person, identifiers: identifiers)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientCreate", actual: "\(source)"))
            }
        }
        // Decoder for [PatientCreateFull]
        Decoders.addDecoder(clazz: [PatientCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientCreateFull]> in
            return Decoders.decode(clazz: [PatientCreateFull].self, source: source)
        }

        // Decoder for PatientCreateFull
        Decoders.addDecoder(clazz: PatientCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let personSource = sourceDictionary["person"] as AnyObject? else {
                    return .failure(.missingKey(key: "person"))
                }
                guard let person = Decoders.decode(clazz: PersonCreate.self.self, source: personSource).value else {
                    return .failure(.typeMismatch(expected: "PatientCreateFull", actual: "\(personSource)"))
                }
                guard let identifiersSource = sourceDictionary["identifiers"] as AnyObject? else {
                    return .failure(.missingKey(key: "identifiers"))
                }
                guard let identifiers = Decoders.decode(clazz: [PatientIdentifierCreate].self.self, source: identifiersSource).value else {
                    return .failure(.typeMismatch(expected: "PatientCreateFull", actual: "\(identifiersSource)"))
                }
                let _result = PatientCreateFull(person: person, identifiers: identifiers)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [PatientGet]
        Decoders.addDecoder(clazz: [PatientGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientGet]> in
            return Decoders.decode(clazz: [PatientGet].self, source: source)
        }

        // Decoder for PatientGet
        Decoders.addDecoder(clazz: PatientGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PatientGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PatientIdentifierGetRef].self, source: sourceDictionary["identifiers"] as AnyObject?) {
                case let .success(value): _result.identifiers = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonGetRef.self, source: sourceDictionary["person"] as AnyObject?) {
                case let .success(value): _result.person = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientGet", actual: "\(source)"))
            }
        }
        // Decoder for [PatientGetFull]
        Decoders.addDecoder(clazz: [PatientGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientGetFull]> in
            return Decoders.decode(clazz: [PatientGetFull].self, source: source)
        }

        // Decoder for PatientGetFull
        Decoders.addDecoder(clazz: PatientGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PatientGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PatientIdentifierGetRef].self, source: sourceDictionary["identifiers"] as AnyObject?) {
                case let .success(value): _result.identifiers = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonGet.self, source: sourceDictionary["person"] as AnyObject?) {
                case let .success(value): _result.person = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [PatientGetRef]
        Decoders.addDecoder(clazz: [PatientGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientGetRef]> in
            return Decoders.decode(clazz: [PatientGetRef].self, source: source)
        }

        // Decoder for PatientGetRef
        Decoders.addDecoder(clazz: PatientGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PatientGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [PatientIdentifierCreate]
        Decoders.addDecoder(clazz: [PatientIdentifierCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientIdentifierCreate]> in
            return Decoders.decode(clazz: [PatientIdentifierCreate].self, source: source)
        }

        // Decoder for PatientIdentifierCreate
        Decoders.addDecoder(clazz: PatientIdentifierCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientIdentifierCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let identifierSource = sourceDictionary["identifier"] as AnyObject? else {
                    return .failure(.missingKey(key: "identifier"))
                }
                guard let identifier = Decoders.decode(clazz: String.self.self, source: identifierSource).value else {
                    return .failure(.typeMismatch(expected: "PatientIdentifierCreate", actual: "\(identifierSource)"))
                }
                guard let identifierTypeSource = sourceDictionary["identifierType"] as AnyObject? else {
                    return .failure(.missingKey(key: "identifierType"))
                }
                guard let identifierType = Decoders.decode(clazz: String.self.self, source: identifierTypeSource).value else {
                    return .failure(.typeMismatch(expected: "PatientIdentifierCreate", actual: "\(identifierTypeSource)"))
                }
                let _result = PatientIdentifierCreate(identifier: identifier, identifierType: identifierType)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientIdentifierCreate", actual: "\(source)"))
            }
        }
        // Decoder for [PatientIdentifierCreateFull]
        Decoders.addDecoder(clazz: [PatientIdentifierCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientIdentifierCreateFull]> in
            return Decoders.decode(clazz: [PatientIdentifierCreateFull].self, source: source)
        }

        // Decoder for PatientIdentifierCreateFull
        Decoders.addDecoder(clazz: PatientIdentifierCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientIdentifierCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let identifierSource = sourceDictionary["identifier"] as AnyObject? else {
                    return .failure(.missingKey(key: "identifier"))
                }
                guard let identifier = Decoders.decode(clazz: String.self.self, source: identifierSource).value else {
                    return .failure(.typeMismatch(expected: "PatientIdentifierCreateFull", actual: "\(identifierSource)"))
                }
                guard let identifierTypeSource = sourceDictionary["identifierType"] as AnyObject? else {
                    return .failure(.missingKey(key: "identifierType"))
                }
                guard let identifierType = Decoders.decode(clazz: PatientidentifiertypeCreate.self.self, source: identifierTypeSource).value else {
                    return .failure(.typeMismatch(expected: "PatientIdentifierCreateFull", actual: "\(identifierTypeSource)"))
                }
                let _result = PatientIdentifierCreateFull(identifier: identifier, identifierType: identifierType)
                switch Decoders.decodeOptional(clazz: LocationCreate.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientIdentifierCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [PatientIdentifierGet]
        Decoders.addDecoder(clazz: [PatientIdentifierGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientIdentifierGet]> in
            return Decoders.decode(clazz: [PatientIdentifierGet].self, source: source)
        }

        // Decoder for PatientIdentifierGet
        Decoders.addDecoder(clazz: PatientIdentifierGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientIdentifierGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PatientIdentifierGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["identifier"] as AnyObject?) {
                case let .success(value): _result.identifier = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientidentifiertypeGetRef.self, source: sourceDictionary["identifierType"] as AnyObject?) {
                case let .success(value): _result.identifierType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationGetRef.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientIdentifierGet", actual: "\(source)"))
            }
        }
        // Decoder for [PatientIdentifierGetFull]
        Decoders.addDecoder(clazz: [PatientIdentifierGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientIdentifierGetFull]> in
            return Decoders.decode(clazz: [PatientIdentifierGetFull].self, source: source)
        }

        // Decoder for PatientIdentifierGetFull
        Decoders.addDecoder(clazz: PatientIdentifierGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientIdentifierGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PatientIdentifierGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["identifier"] as AnyObject?) {
                case let .success(value): _result.identifier = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientidentifiertypeGet.self, source: sourceDictionary["identifierType"] as AnyObject?) {
                case let .success(value): _result.identifierType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationGet.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientIdentifierGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [PatientIdentifierGetRef]
        Decoders.addDecoder(clazz: [PatientIdentifierGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientIdentifierGetRef]> in
            return Decoders.decode(clazz: [PatientIdentifierGetRef].self, source: source)
        }

        // Decoder for PatientIdentifierGetRef
        Decoders.addDecoder(clazz: PatientIdentifierGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientIdentifierGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PatientIdentifierGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientIdentifierGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [PatientIdentifierUpdate]
        Decoders.addDecoder(clazz: [PatientIdentifierUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientIdentifierUpdate]> in
            return Decoders.decode(clazz: [PatientIdentifierUpdate].self, source: source)
        }

        // Decoder for PatientIdentifierUpdate
        Decoders.addDecoder(clazz: PatientIdentifierUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientIdentifierUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let identifierSource = sourceDictionary["identifier"] as AnyObject? else {
                    return .failure(.missingKey(key: "identifier"))
                }
                guard let identifier = Decoders.decode(clazz: String.self.self, source: identifierSource).value else {
                    return .failure(.typeMismatch(expected: "PatientIdentifierUpdate", actual: "\(identifierSource)"))
                }
                guard let identifierTypeSource = sourceDictionary["identifierType"] as AnyObject? else {
                    return .failure(.missingKey(key: "identifierType"))
                }
                guard let identifierType = Decoders.decode(clazz: String.self.self, source: identifierTypeSource).value else {
                    return .failure(.typeMismatch(expected: "PatientIdentifierUpdate", actual: "\(identifierTypeSource)"))
                }
                let _result = PatientIdentifierUpdate(identifier: identifier, identifierType: identifierType)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientIdentifierUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [PatientUpdate]
        Decoders.addDecoder(clazz: [PatientUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientUpdate]> in
            return Decoders.decode(clazz: [PatientUpdate].self, source: source)
        }

        // Decoder for PatientUpdate
        Decoders.addDecoder(clazz: PatientUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let personSource = sourceDictionary["person"] as AnyObject? else {
                    return .failure(.missingKey(key: "person"))
                }
                guard let person = Decoders.decode(clazz: PersonGet.self.self, source: personSource).value else {
                    return .failure(.typeMismatch(expected: "PatientUpdate", actual: "\(personSource)"))
                }
                let _result = PatientUpdate(person: person)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [PatientidentifiertypeCreate]
        Decoders.addDecoder(clazz: [PatientidentifiertypeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientidentifiertypeCreate]> in
            return Decoders.decode(clazz: [PatientidentifiertypeCreate].self, source: source)
        }

        // Decoder for PatientidentifiertypeCreate
        Decoders.addDecoder(clazz: PatientidentifiertypeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientidentifiertypeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "PatientidentifiertypeCreate", actual: "\(nameSource)"))
                }
                let _result = PatientidentifiertypeCreate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["format"] as AnyObject?) {
                case let .success(value): _result.format = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formatDescription"] as AnyObject?) {
                case let .success(value): _result.formatDescription = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                case let .success(value): _result._required = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["checkDigit"] as AnyObject?) {
                case let .success(value): _result.checkDigit = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["validator"] as AnyObject?) {
                case let .success(value): _result.validator = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientidentifiertypeCreate.LocationBehavior.self, source: sourceDictionary["locationBehavior"] as AnyObject?) {
                case let .success(value): _result.locationBehavior = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uniquenessBehavior"] as AnyObject?) {
                case let .success(value): _result.uniquenessBehavior = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientidentifiertypeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [PatientidentifiertypeCreateFull]
        Decoders.addDecoder(clazz: [PatientidentifiertypeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientidentifiertypeCreateFull]> in
            return Decoders.decode(clazz: [PatientidentifiertypeCreateFull].self, source: source)
        }

        // Decoder for PatientidentifiertypeCreateFull
        Decoders.addDecoder(clazz: PatientidentifiertypeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientidentifiertypeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "PatientidentifiertypeCreateFull", actual: "\(nameSource)"))
                }
                let _result = PatientidentifiertypeCreateFull(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["format"] as AnyObject?) {
                case let .success(value): _result.format = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formatDescription"] as AnyObject?) {
                case let .success(value): _result.formatDescription = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                case let .success(value): _result._required = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["checkDigit"] as AnyObject?) {
                case let .success(value): _result.checkDigit = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["validator"] as AnyObject?) {
                case let .success(value): _result.validator = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientidentifiertypeCreateFull.LocationBehavior.self, source: sourceDictionary["locationBehavior"] as AnyObject?) {
                case let .success(value): _result.locationBehavior = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uniquenessBehavior"] as AnyObject?) {
                case let .success(value): _result.uniquenessBehavior = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientidentifiertypeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [PatientidentifiertypeGet]
        Decoders.addDecoder(clazz: [PatientidentifiertypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientidentifiertypeGet]> in
            return Decoders.decode(clazz: [PatientidentifiertypeGet].self, source: source)
        }

        // Decoder for PatientidentifiertypeGet
        Decoders.addDecoder(clazz: PatientidentifiertypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientidentifiertypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PatientidentifiertypeGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["format"] as AnyObject?) {
                case let .success(value): _result.format = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formatDescription"] as AnyObject?) {
                case let .success(value): _result.formatDescription = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                case let .success(value): _result._required = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["checkDigit"] as AnyObject?) {
                case let .success(value): _result.checkDigit = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["validator"] as AnyObject?) {
                case let .success(value): _result.validator = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientidentifiertypeGet.LocationBehavior.self, source: sourceDictionary["locationBehavior"] as AnyObject?) {
                case let .success(value): _result.locationBehavior = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uniquenessBehavior"] as AnyObject?) {
                case let .success(value): _result.uniquenessBehavior = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientidentifiertypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [PatientidentifiertypeGetFull]
        Decoders.addDecoder(clazz: [PatientidentifiertypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientidentifiertypeGetFull]> in
            return Decoders.decode(clazz: [PatientidentifiertypeGetFull].self, source: source)
        }

        // Decoder for PatientidentifiertypeGetFull
        Decoders.addDecoder(clazz: PatientidentifiertypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientidentifiertypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PatientidentifiertypeGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["format"] as AnyObject?) {
                case let .success(value): _result.format = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formatDescription"] as AnyObject?) {
                case let .success(value): _result.formatDescription = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                case let .success(value): _result._required = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["checkDigit"] as AnyObject?) {
                case let .success(value): _result.checkDigit = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["validator"] as AnyObject?) {
                case let .success(value): _result.validator = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientidentifiertypeGetFull.LocationBehavior.self, source: sourceDictionary["locationBehavior"] as AnyObject?) {
                case let .success(value): _result.locationBehavior = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uniquenessBehavior"] as AnyObject?) {
                case let .success(value): _result.uniquenessBehavior = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientidentifiertypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [PatientidentifiertypeGetRef]
        Decoders.addDecoder(clazz: [PatientidentifiertypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientidentifiertypeGetRef]> in
            return Decoders.decode(clazz: [PatientidentifiertypeGetRef].self, source: source)
        }

        // Decoder for PatientidentifiertypeGetRef
        Decoders.addDecoder(clazz: PatientidentifiertypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientidentifiertypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PatientidentifiertypeGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientidentifiertypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [PatientidentifiertypeUpdate]
        Decoders.addDecoder(clazz: [PatientidentifiertypeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientidentifiertypeUpdate]> in
            return Decoders.decode(clazz: [PatientidentifiertypeUpdate].self, source: source)
        }

        // Decoder for PatientidentifiertypeUpdate
        Decoders.addDecoder(clazz: PatientidentifiertypeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientidentifiertypeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "PatientidentifiertypeUpdate", actual: "\(nameSource)"))
                }
                let _result = PatientidentifiertypeUpdate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["format"] as AnyObject?) {
                case let .success(value): _result.format = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formatDescription"] as AnyObject?) {
                case let .success(value): _result.formatDescription = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                case let .success(value): _result._required = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["checkDigit"] as AnyObject?) {
                case let .success(value): _result.checkDigit = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["validator"] as AnyObject?) {
                case let .success(value): _result.validator = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientidentifiertypeUpdate.LocationBehavior.self, source: sourceDictionary["locationBehavior"] as AnyObject?) {
                case let .success(value): _result.locationBehavior = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uniquenessBehavior"] as AnyObject?) {
                case let .success(value): _result.uniquenessBehavior = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientidentifiertypeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [PersonAddressCreate]
        Decoders.addDecoder(clazz: [PersonAddressCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonAddressCreate]> in
            return Decoders.decode(clazz: [PersonAddressCreate].self, source: source)
        }

        // Decoder for PersonAddressCreate
        Decoders.addDecoder(clazz: PersonAddressCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonAddressCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PersonAddressCreate()
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address1"] as AnyObject?) {
                case let .success(value): _result.address1 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address2"] as AnyObject?) {
                case let .success(value): _result.address2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["cityVillage"] as AnyObject?) {
                case let .success(value): _result.cityVillage = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stateProvince"] as AnyObject?) {
                case let .success(value): _result.stateProvince = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country"] as AnyObject?) {
                case let .success(value): _result.country = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["postalCode"] as AnyObject?) {
                case let .success(value): _result.postalCode = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["countyDistrict"] as AnyObject?) {
                case let .success(value): _result.countyDistrict = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address3"] as AnyObject?) {
                case let .success(value): _result.address3 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address4"] as AnyObject?) {
                case let .success(value): _result.address4 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address5"] as AnyObject?) {
                case let .success(value): _result.address5 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address6"] as AnyObject?) {
                case let .success(value): _result.address6 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["latitude"] as AnyObject?) {
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["longitude"] as AnyObject?) {
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonAddressCreate", actual: "\(source)"))
            }
        }
        // Decoder for [PersonAddressCreateFull]
        Decoders.addDecoder(clazz: [PersonAddressCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonAddressCreateFull]> in
            return Decoders.decode(clazz: [PersonAddressCreateFull].self, source: source)
        }

        // Decoder for PersonAddressCreateFull
        Decoders.addDecoder(clazz: PersonAddressCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonAddressCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PersonAddressCreateFull()
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address1"] as AnyObject?) {
                case let .success(value): _result.address1 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address2"] as AnyObject?) {
                case let .success(value): _result.address2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["cityVillage"] as AnyObject?) {
                case let .success(value): _result.cityVillage = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stateProvince"] as AnyObject?) {
                case let .success(value): _result.stateProvince = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country"] as AnyObject?) {
                case let .success(value): _result.country = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["postalCode"] as AnyObject?) {
                case let .success(value): _result.postalCode = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["countyDistrict"] as AnyObject?) {
                case let .success(value): _result.countyDistrict = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address3"] as AnyObject?) {
                case let .success(value): _result.address3 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address4"] as AnyObject?) {
                case let .success(value): _result.address4 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address5"] as AnyObject?) {
                case let .success(value): _result.address5 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address6"] as AnyObject?) {
                case let .success(value): _result.address6 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["latitude"] as AnyObject?) {
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["longitude"] as AnyObject?) {
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonAddressCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [PersonAddressGet]
        Decoders.addDecoder(clazz: [PersonAddressGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonAddressGet]> in
            return Decoders.decode(clazz: [PersonAddressGet].self, source: source)
        }

        // Decoder for PersonAddressGet
        Decoders.addDecoder(clazz: PersonAddressGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonAddressGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PersonAddressGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address1"] as AnyObject?) {
                case let .success(value): _result.address1 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address2"] as AnyObject?) {
                case let .success(value): _result.address2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["cityVillage"] as AnyObject?) {
                case let .success(value): _result.cityVillage = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stateProvince"] as AnyObject?) {
                case let .success(value): _result.stateProvince = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country"] as AnyObject?) {
                case let .success(value): _result.country = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["postalCode"] as AnyObject?) {
                case let .success(value): _result.postalCode = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["countyDistrict"] as AnyObject?) {
                case let .success(value): _result.countyDistrict = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address3"] as AnyObject?) {
                case let .success(value): _result.address3 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address4"] as AnyObject?) {
                case let .success(value): _result.address4 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address5"] as AnyObject?) {
                case let .success(value): _result.address5 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address6"] as AnyObject?) {
                case let .success(value): _result.address6 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["latitude"] as AnyObject?) {
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["longitude"] as AnyObject?) {
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonAddressGet", actual: "\(source)"))
            }
        }
        // Decoder for [PersonAddressGetFull]
        Decoders.addDecoder(clazz: [PersonAddressGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonAddressGetFull]> in
            return Decoders.decode(clazz: [PersonAddressGetFull].self, source: source)
        }

        // Decoder for PersonAddressGetFull
        Decoders.addDecoder(clazz: PersonAddressGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonAddressGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PersonAddressGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address1"] as AnyObject?) {
                case let .success(value): _result.address1 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address2"] as AnyObject?) {
                case let .success(value): _result.address2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["cityVillage"] as AnyObject?) {
                case let .success(value): _result.cityVillage = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stateProvince"] as AnyObject?) {
                case let .success(value): _result.stateProvince = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country"] as AnyObject?) {
                case let .success(value): _result.country = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["postalCode"] as AnyObject?) {
                case let .success(value): _result.postalCode = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["countyDistrict"] as AnyObject?) {
                case let .success(value): _result.countyDistrict = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address3"] as AnyObject?) {
                case let .success(value): _result.address3 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address4"] as AnyObject?) {
                case let .success(value): _result.address4 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address5"] as AnyObject?) {
                case let .success(value): _result.address5 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address6"] as AnyObject?) {
                case let .success(value): _result.address6 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["latitude"] as AnyObject?) {
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["longitude"] as AnyObject?) {
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonAddressGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [PersonAddressGetRef]
        Decoders.addDecoder(clazz: [PersonAddressGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonAddressGetRef]> in
            return Decoders.decode(clazz: [PersonAddressGetRef].self, source: source)
        }

        // Decoder for PersonAddressGetRef
        Decoders.addDecoder(clazz: PersonAddressGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonAddressGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PersonAddressGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonAddressGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [PersonAddressUpdate]
        Decoders.addDecoder(clazz: [PersonAddressUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonAddressUpdate]> in
            return Decoders.decode(clazz: [PersonAddressUpdate].self, source: source)
        }

        // Decoder for PersonAddressUpdate
        Decoders.addDecoder(clazz: PersonAddressUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonAddressUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PersonAddressUpdate()
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address1"] as AnyObject?) {
                case let .success(value): _result.address1 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address2"] as AnyObject?) {
                case let .success(value): _result.address2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["cityVillage"] as AnyObject?) {
                case let .success(value): _result.cityVillage = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stateProvince"] as AnyObject?) {
                case let .success(value): _result.stateProvince = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country"] as AnyObject?) {
                case let .success(value): _result.country = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["postalCode"] as AnyObject?) {
                case let .success(value): _result.postalCode = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["countyDistrict"] as AnyObject?) {
                case let .success(value): _result.countyDistrict = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address3"] as AnyObject?) {
                case let .success(value): _result.address3 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address4"] as AnyObject?) {
                case let .success(value): _result.address4 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address5"] as AnyObject?) {
                case let .success(value): _result.address5 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address6"] as AnyObject?) {
                case let .success(value): _result.address6 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["latitude"] as AnyObject?) {
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["longitude"] as AnyObject?) {
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonAddressUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [PersonAttributeCreate]
        Decoders.addDecoder(clazz: [PersonAttributeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonAttributeCreate]> in
            return Decoders.decode(clazz: [PersonAttributeCreate].self, source: source)
        }

        // Decoder for PersonAttributeCreate
        Decoders.addDecoder(clazz: PersonAttributeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonAttributeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let attributeTypeSource = sourceDictionary["attributeType"] as AnyObject? else {
                    return .failure(.missingKey(key: "attributeType"))
                }
                guard let attributeType = Decoders.decode(clazz: String.self.self, source: attributeTypeSource).value else {
                    return .failure(.typeMismatch(expected: "PersonAttributeCreate", actual: "\(attributeTypeSource)"))
                }
                let _result = PersonAttributeCreate(attributeType: attributeType)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hydratedObject"] as AnyObject?) {
                case let .success(value): _result.hydratedObject = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonAttributeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [PersonAttributeCreateFull]
        Decoders.addDecoder(clazz: [PersonAttributeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonAttributeCreateFull]> in
            return Decoders.decode(clazz: [PersonAttributeCreateFull].self, source: source)
        }

        // Decoder for PersonAttributeCreateFull
        Decoders.addDecoder(clazz: PersonAttributeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonAttributeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let attributeTypeSource = sourceDictionary["attributeType"] as AnyObject? else {
                    return .failure(.missingKey(key: "attributeType"))
                }
                guard let attributeType = Decoders.decode(clazz: PersonattributetypeCreate.self.self, source: attributeTypeSource).value else {
                    return .failure(.typeMismatch(expected: "PersonAttributeCreateFull", actual: "\(attributeTypeSource)"))
                }
                let _result = PersonAttributeCreateFull(attributeType: attributeType)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hydratedObject"] as AnyObject?) {
                case let .success(value): _result.hydratedObject = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonAttributeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [PersonAttributeGet]
        Decoders.addDecoder(clazz: [PersonAttributeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonAttributeGet]> in
            return Decoders.decode(clazz: [PersonAttributeGet].self, source: source)
        }

        // Decoder for PersonAttributeGet
        Decoders.addDecoder(clazz: PersonAttributeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonAttributeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PersonAttributeGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonattributetypeGetRef.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonAttributeGet", actual: "\(source)"))
            }
        }
        // Decoder for [PersonAttributeGetFull]
        Decoders.addDecoder(clazz: [PersonAttributeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonAttributeGetFull]> in
            return Decoders.decode(clazz: [PersonAttributeGetFull].self, source: source)
        }

        // Decoder for PersonAttributeGetFull
        Decoders.addDecoder(clazz: PersonAttributeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonAttributeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PersonAttributeGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonattributetypeGetRef.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hydratedObject"] as AnyObject?) {
                case let .success(value): _result.hydratedObject = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonAttributeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [PersonAttributeGetRef]
        Decoders.addDecoder(clazz: [PersonAttributeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonAttributeGetRef]> in
            return Decoders.decode(clazz: [PersonAttributeGetRef].self, source: source)
        }

        // Decoder for PersonAttributeGetRef
        Decoders.addDecoder(clazz: PersonAttributeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonAttributeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PersonAttributeGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonAttributeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [PersonAttributeUpdate]
        Decoders.addDecoder(clazz: [PersonAttributeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonAttributeUpdate]> in
            return Decoders.decode(clazz: [PersonAttributeUpdate].self, source: source)
        }

        // Decoder for PersonAttributeUpdate
        Decoders.addDecoder(clazz: PersonAttributeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonAttributeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let attributeTypeSource = sourceDictionary["attributeType"] as AnyObject? else {
                    return .failure(.missingKey(key: "attributeType"))
                }
                guard let attributeType = Decoders.decode(clazz: String.self.self, source: attributeTypeSource).value else {
                    return .failure(.typeMismatch(expected: "PersonAttributeUpdate", actual: "\(attributeTypeSource)"))
                }
                let _result = PersonAttributeUpdate(attributeType: attributeType)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hydratedObject"] as AnyObject?) {
                case let .success(value): _result.hydratedObject = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonAttributeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [PersonCreate]
        Decoders.addDecoder(clazz: [PersonCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonCreate]> in
            return Decoders.decode(clazz: [PersonCreate].self, source: source)
        }

        // Decoder for PersonCreate
        Decoders.addDecoder(clazz: PersonCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let namesSource = sourceDictionary["names"] as AnyObject? else {
                    return .failure(.missingKey(key: "names"))
                }
                guard let names = Decoders.decode(clazz: [PersonNameCreate].self.self, source: namesSource).value else {
                    return .failure(.typeMismatch(expected: "PersonCreate", actual: "\(namesSource)"))
                }
                guard let genderSource = sourceDictionary["gender"] as AnyObject? else {
                    return .failure(.missingKey(key: "gender"))
                }
                guard let gender = Decoders.decode(clazz: PersonCreate.Gender.self.self, source: genderSource).value else {
                    return .failure(.typeMismatch(expected: "PersonCreate", actual: "\(genderSource)"))
                }
                let _result = PersonCreate(names: names, gender: gender)
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["age"] as AnyObject?) {
                case let .success(value): _result.age = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["birthdate"] as AnyObject?) {
                case let .success(value): _result.birthdate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["birthdateEstimated"] as AnyObject?) {
                case let .success(value): _result.birthdateEstimated = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["dead"] as AnyObject?) {
                case let .success(value): _result.dead = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["deathDate"] as AnyObject?) {
                case let .success(value): _result.deathDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["causeOfDeath"] as AnyObject?) {
                case let .success(value): _result.causeOfDeath = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PersonAddressCreate].self, source: sourceDictionary["addresses"] as AnyObject?) {
                case let .success(value): _result.addresses = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PersonAttributeCreate].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["deathdateEstimated"] as AnyObject?) {
                case let .success(value): _result.deathdateEstimated = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["birthtime"] as AnyObject?) {
                case let .success(value): _result.birthtime = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonCreate", actual: "\(source)"))
            }
        }
        // Decoder for [PersonCreateFull]
        Decoders.addDecoder(clazz: [PersonCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonCreateFull]> in
            return Decoders.decode(clazz: [PersonCreateFull].self, source: source)
        }

        // Decoder for PersonCreateFull
        Decoders.addDecoder(clazz: PersonCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let namesSource = sourceDictionary["names"] as AnyObject? else {
                    return .failure(.missingKey(key: "names"))
                }
                guard let names = Decoders.decode(clazz: [PersonNameCreate].self.self, source: namesSource).value else {
                    return .failure(.typeMismatch(expected: "PersonCreateFull", actual: "\(namesSource)"))
                }
                guard let genderSource = sourceDictionary["gender"] as AnyObject? else {
                    return .failure(.missingKey(key: "gender"))
                }
                guard let gender = Decoders.decode(clazz: PersonCreateFull.Gender.self.self, source: genderSource).value else {
                    return .failure(.typeMismatch(expected: "PersonCreateFull", actual: "\(genderSource)"))
                }
                let _result = PersonCreateFull(names: names, gender: gender)
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["age"] as AnyObject?) {
                case let .success(value): _result.age = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["birthdate"] as AnyObject?) {
                case let .success(value): _result.birthdate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["birthdateEstimated"] as AnyObject?) {
                case let .success(value): _result.birthdateEstimated = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["dead"] as AnyObject?) {
                case let .success(value): _result.dead = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["deathDate"] as AnyObject?) {
                case let .success(value): _result.deathDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["causeOfDeath"] as AnyObject?) {
                case let .success(value): _result.causeOfDeath = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PersonAddressCreate].self, source: sourceDictionary["addresses"] as AnyObject?) {
                case let .success(value): _result.addresses = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PersonAttributeCreate].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["deathdateEstimated"] as AnyObject?) {
                case let .success(value): _result.deathdateEstimated = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["birthtime"] as AnyObject?) {
                case let .success(value): _result.birthtime = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [PersonGet]
        Decoders.addDecoder(clazz: [PersonGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonGet]> in
            return Decoders.decode(clazz: [PersonGet].self, source: source)
        }

        // Decoder for PersonGet
        Decoders.addDecoder(clazz: PersonGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PersonGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonGet.Gender.self, source: sourceDictionary["gender"] as AnyObject?) {
                case let .success(value): _result.gender = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["age"] as AnyObject?) {
                case let .success(value): _result.age = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["birthdate"] as AnyObject?) {
                case let .success(value): _result.birthdate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["birthdateEstimated"] as AnyObject?) {
                case let .success(value): _result.birthdateEstimated = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["dead"] as AnyObject?) {
                case let .success(value): _result.dead = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["deathDate"] as AnyObject?) {
                case let .success(value): _result.deathDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["causeOfDeath"] as AnyObject?) {
                case let .success(value): _result.causeOfDeath = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PersonAttributeGetRef].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonNameGetRef.self, source: sourceDictionary["preferredName"] as AnyObject?) {
                case let .success(value): _result.preferredName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonAddressGetRef.self, source: sourceDictionary["preferredAddress"] as AnyObject?) {
                case let .success(value): _result.preferredAddress = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["deathdateEstimated"] as AnyObject?) {
                case let .success(value): _result.deathdateEstimated = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["birthtime"] as AnyObject?) {
                case let .success(value): _result.birthtime = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonGet", actual: "\(source)"))
            }
        }
        // Decoder for [PersonGetFull]
        Decoders.addDecoder(clazz: [PersonGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonGetFull]> in
            return Decoders.decode(clazz: [PersonGetFull].self, source: source)
        }

        // Decoder for PersonGetFull
        Decoders.addDecoder(clazz: PersonGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PersonGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonGetFull.Gender.self, source: sourceDictionary["gender"] as AnyObject?) {
                case let .success(value): _result.gender = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["age"] as AnyObject?) {
                case let .success(value): _result.age = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["birthdate"] as AnyObject?) {
                case let .success(value): _result.birthdate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["birthdateEstimated"] as AnyObject?) {
                case let .success(value): _result.birthdateEstimated = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["dead"] as AnyObject?) {
                case let .success(value): _result.dead = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["deathDate"] as AnyObject?) {
                case let .success(value): _result.deathDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["causeOfDeath"] as AnyObject?) {
                case let .success(value): _result.causeOfDeath = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PersonAttributeGetRef].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonNameGet.self, source: sourceDictionary["preferredName"] as AnyObject?) {
                case let .success(value): _result.preferredName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonAddressGet.self, source: sourceDictionary["preferredAddress"] as AnyObject?) {
                case let .success(value): _result.preferredAddress = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PersonNameGet].self, source: sourceDictionary["names"] as AnyObject?) {
                case let .success(value): _result.names = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PersonAddressGet].self, source: sourceDictionary["addresses"] as AnyObject?) {
                case let .success(value): _result.addresses = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["deathdateEstimated"] as AnyObject?) {
                case let .success(value): _result.deathdateEstimated = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["birthtime"] as AnyObject?) {
                case let .success(value): _result.birthtime = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [PersonGetRef]
        Decoders.addDecoder(clazz: [PersonGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonGetRef]> in
            return Decoders.decode(clazz: [PersonGetRef].self, source: source)
        }

        // Decoder for PersonGetRef
        Decoders.addDecoder(clazz: PersonGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PersonGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [PersonNameCreate]
        Decoders.addDecoder(clazz: [PersonNameCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonNameCreate]> in
            return Decoders.decode(clazz: [PersonNameCreate].self, source: source)
        }

        // Decoder for PersonNameCreate
        Decoders.addDecoder(clazz: PersonNameCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonNameCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let givenNameSource = sourceDictionary["givenName"] as AnyObject? else {
                    return .failure(.missingKey(key: "givenName"))
                }
                guard let givenName = Decoders.decode(clazz: String.self.self, source: givenNameSource).value else {
                    return .failure(.typeMismatch(expected: "PersonNameCreate", actual: "\(givenNameSource)"))
                }
                let _result = PersonNameCreate(givenName: givenName)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["middleName"] as AnyObject?) {
                case let .success(value): _result.middleName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyName"] as AnyObject?) {
                case let .success(value): _result.familyName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyName2"] as AnyObject?) {
                case let .success(value): _result.familyName2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["prefix"] as AnyObject?) {
                case let .success(value): _result._prefix = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyNamePrefix"] as AnyObject?) {
                case let .success(value): _result.familyNamePrefix = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyNameSuffix"] as AnyObject?) {
                case let .success(value): _result.familyNameSuffix = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["degree"] as AnyObject?) {
                case let .success(value): _result.degree = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonNameCreate", actual: "\(source)"))
            }
        }
        // Decoder for [PersonNameCreateFull]
        Decoders.addDecoder(clazz: [PersonNameCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonNameCreateFull]> in
            return Decoders.decode(clazz: [PersonNameCreateFull].self, source: source)
        }

        // Decoder for PersonNameCreateFull
        Decoders.addDecoder(clazz: PersonNameCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonNameCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let givenNameSource = sourceDictionary["givenName"] as AnyObject? else {
                    return .failure(.missingKey(key: "givenName"))
                }
                guard let givenName = Decoders.decode(clazz: String.self.self, source: givenNameSource).value else {
                    return .failure(.typeMismatch(expected: "PersonNameCreateFull", actual: "\(givenNameSource)"))
                }
                let _result = PersonNameCreateFull(givenName: givenName)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["middleName"] as AnyObject?) {
                case let .success(value): _result.middleName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyName"] as AnyObject?) {
                case let .success(value): _result.familyName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyName2"] as AnyObject?) {
                case let .success(value): _result.familyName2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["prefix"] as AnyObject?) {
                case let .success(value): _result._prefix = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyNamePrefix"] as AnyObject?) {
                case let .success(value): _result.familyNamePrefix = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyNameSuffix"] as AnyObject?) {
                case let .success(value): _result.familyNameSuffix = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["degree"] as AnyObject?) {
                case let .success(value): _result.degree = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonNameCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [PersonNameGet]
        Decoders.addDecoder(clazz: [PersonNameGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonNameGet]> in
            return Decoders.decode(clazz: [PersonNameGet].self, source: source)
        }

        // Decoder for PersonNameGet
        Decoders.addDecoder(clazz: PersonNameGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonNameGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PersonNameGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["givenName"] as AnyObject?) {
                case let .success(value): _result.givenName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["middleName"] as AnyObject?) {
                case let .success(value): _result.middleName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyName"] as AnyObject?) {
                case let .success(value): _result.familyName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyName2"] as AnyObject?) {
                case let .success(value): _result.familyName2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonNameGet", actual: "\(source)"))
            }
        }
        // Decoder for [PersonNameGetFull]
        Decoders.addDecoder(clazz: [PersonNameGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonNameGetFull]> in
            return Decoders.decode(clazz: [PersonNameGetFull].self, source: source)
        }

        // Decoder for PersonNameGetFull
        Decoders.addDecoder(clazz: PersonNameGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonNameGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PersonNameGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["givenName"] as AnyObject?) {
                case let .success(value): _result.givenName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["middleName"] as AnyObject?) {
                case let .success(value): _result.middleName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyName"] as AnyObject?) {
                case let .success(value): _result.familyName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyName2"] as AnyObject?) {
                case let .success(value): _result.familyName2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["prefix"] as AnyObject?) {
                case let .success(value): _result._prefix = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyNamePrefix"] as AnyObject?) {
                case let .success(value): _result.familyNamePrefix = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyNameSuffix"] as AnyObject?) {
                case let .success(value): _result.familyNameSuffix = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["degree"] as AnyObject?) {
                case let .success(value): _result.degree = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonNameGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [PersonNameGetRef]
        Decoders.addDecoder(clazz: [PersonNameGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonNameGetRef]> in
            return Decoders.decode(clazz: [PersonNameGetRef].self, source: source)
        }

        // Decoder for PersonNameGetRef
        Decoders.addDecoder(clazz: PersonNameGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonNameGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PersonNameGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonNameGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [PersonNameUpdate]
        Decoders.addDecoder(clazz: [PersonNameUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonNameUpdate]> in
            return Decoders.decode(clazz: [PersonNameUpdate].self, source: source)
        }

        // Decoder for PersonNameUpdate
        Decoders.addDecoder(clazz: PersonNameUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonNameUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let givenNameSource = sourceDictionary["givenName"] as AnyObject? else {
                    return .failure(.missingKey(key: "givenName"))
                }
                guard let givenName = Decoders.decode(clazz: String.self.self, source: givenNameSource).value else {
                    return .failure(.typeMismatch(expected: "PersonNameUpdate", actual: "\(givenNameSource)"))
                }
                let _result = PersonNameUpdate(givenName: givenName)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["middleName"] as AnyObject?) {
                case let .success(value): _result.middleName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyName"] as AnyObject?) {
                case let .success(value): _result.familyName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyName2"] as AnyObject?) {
                case let .success(value): _result.familyName2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["prefix"] as AnyObject?) {
                case let .success(value): _result._prefix = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyNamePrefix"] as AnyObject?) {
                case let .success(value): _result.familyNamePrefix = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyNameSuffix"] as AnyObject?) {
                case let .success(value): _result.familyNameSuffix = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["degree"] as AnyObject?) {
                case let .success(value): _result.degree = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonNameUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [PersonUpdate]
        Decoders.addDecoder(clazz: [PersonUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonUpdate]> in
            return Decoders.decode(clazz: [PersonUpdate].self, source: source)
        }

        // Decoder for PersonUpdate
        Decoders.addDecoder(clazz: PersonUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let deadSource = sourceDictionary["dead"] as AnyObject? else {
                    return .failure(.missingKey(key: "dead"))
                }
                guard let dead = Decoders.decode(clazz: Bool.self.self, source: deadSource).value else {
                    return .failure(.typeMismatch(expected: "PersonUpdate", actual: "\(deadSource)"))
                }
                guard let causeOfDeathSource = sourceDictionary["causeOfDeath"] as AnyObject? else {
                    return .failure(.missingKey(key: "causeOfDeath"))
                }
                guard let causeOfDeath = Decoders.decode(clazz: String.self.self, source: causeOfDeathSource).value else {
                    return .failure(.typeMismatch(expected: "PersonUpdate", actual: "\(causeOfDeathSource)"))
                }
                let _result = PersonUpdate(dead: dead, causeOfDeath: causeOfDeath)
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["deathDate"] as AnyObject?) {
                case let .success(value): _result.deathDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["age"] as AnyObject?) {
                case let .success(value): _result.age = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonUpdate.Gender.self, source: sourceDictionary["gender"] as AnyObject?) {
                case let .success(value): _result.gender = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["birthdate"] as AnyObject?) {
                case let .success(value): _result.birthdate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["birthdateEstimated"] as AnyObject?) {
                case let .success(value): _result.birthdateEstimated = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredName"] as AnyObject?) {
                case let .success(value): _result.preferredName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredAddress"] as AnyObject?) {
                case let .success(value): _result.preferredAddress = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PersonAttributeCreate].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["deathdateEstimated"] as AnyObject?) {
                case let .success(value): _result.deathdateEstimated = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["birthtime"] as AnyObject?) {
                case let .success(value): _result.birthtime = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [PersonattributetypeCreate]
        Decoders.addDecoder(clazz: [PersonattributetypeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonattributetypeCreate]> in
            return Decoders.decode(clazz: [PersonattributetypeCreate].self, source: source)
        }

        // Decoder for PersonattributetypeCreate
        Decoders.addDecoder(clazz: PersonattributetypeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonattributetypeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "PersonattributetypeCreate", actual: "\(nameSource)"))
                }
                guard let descriptionSource = sourceDictionary["description"] as AnyObject? else {
                    return .failure(.missingKey(key: "description"))
                }
                guard let description = Decoders.decode(clazz: String.self.self, source: descriptionSource).value else {
                    return .failure(.typeMismatch(expected: "PersonattributetypeCreate", actual: "\(descriptionSource)"))
                }
                let _result = PersonattributetypeCreate(name: name, description: description)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["format"] as AnyObject?) {
                case let .success(value): _result.format = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["foreignKey"] as AnyObject?) {
                case let .success(value): _result.foreignKey = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["sortWeight"] as AnyObject?) {
                case let .success(value): _result.sortWeight = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["searchable"] as AnyObject?) {
                case let .success(value): _result.searchable = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PrivilegeCreate.self, source: sourceDictionary["editPrivilege"] as AnyObject?) {
                case let .success(value): _result.editPrivilege = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonattributetypeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [PersonattributetypeCreateFull]
        Decoders.addDecoder(clazz: [PersonattributetypeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonattributetypeCreateFull]> in
            return Decoders.decode(clazz: [PersonattributetypeCreateFull].self, source: source)
        }

        // Decoder for PersonattributetypeCreateFull
        Decoders.addDecoder(clazz: PersonattributetypeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonattributetypeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "PersonattributetypeCreateFull", actual: "\(nameSource)"))
                }
                guard let descriptionSource = sourceDictionary["description"] as AnyObject? else {
                    return .failure(.missingKey(key: "description"))
                }
                guard let description = Decoders.decode(clazz: String.self.self, source: descriptionSource).value else {
                    return .failure(.typeMismatch(expected: "PersonattributetypeCreateFull", actual: "\(descriptionSource)"))
                }
                let _result = PersonattributetypeCreateFull(name: name, description: description)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["format"] as AnyObject?) {
                case let .success(value): _result.format = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["foreignKey"] as AnyObject?) {
                case let .success(value): _result.foreignKey = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["sortWeight"] as AnyObject?) {
                case let .success(value): _result.sortWeight = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["searchable"] as AnyObject?) {
                case let .success(value): _result.searchable = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PrivilegeCreate.self, source: sourceDictionary["editPrivilege"] as AnyObject?) {
                case let .success(value): _result.editPrivilege = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonattributetypeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [PersonattributetypeGet]
        Decoders.addDecoder(clazz: [PersonattributetypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonattributetypeGet]> in
            return Decoders.decode(clazz: [PersonattributetypeGet].self, source: source)
        }

        // Decoder for PersonattributetypeGet
        Decoders.addDecoder(clazz: PersonattributetypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonattributetypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PersonattributetypeGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["format"] as AnyObject?) {
                case let .success(value): _result.format = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["foreignKey"] as AnyObject?) {
                case let .success(value): _result.foreignKey = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["sortWeight"] as AnyObject?) {
                case let .success(value): _result.sortWeight = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["searchable"] as AnyObject?) {
                case let .success(value): _result.searchable = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PrivilegeGetRef.self, source: sourceDictionary["editPrivilege"] as AnyObject?) {
                case let .success(value): _result.editPrivilege = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonattributetypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [PersonattributetypeGetFull]
        Decoders.addDecoder(clazz: [PersonattributetypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonattributetypeGetFull]> in
            return Decoders.decode(clazz: [PersonattributetypeGetFull].self, source: source)
        }

        // Decoder for PersonattributetypeGetFull
        Decoders.addDecoder(clazz: PersonattributetypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonattributetypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PersonattributetypeGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["format"] as AnyObject?) {
                case let .success(value): _result.format = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["foreignKey"] as AnyObject?) {
                case let .success(value): _result.foreignKey = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["sortWeight"] as AnyObject?) {
                case let .success(value): _result.sortWeight = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["searchable"] as AnyObject?) {
                case let .success(value): _result.searchable = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PrivilegeGet.self, source: sourceDictionary["editPrivilege"] as AnyObject?) {
                case let .success(value): _result.editPrivilege = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonattributetypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [PersonattributetypeGetRef]
        Decoders.addDecoder(clazz: [PersonattributetypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonattributetypeGetRef]> in
            return Decoders.decode(clazz: [PersonattributetypeGetRef].self, source: source)
        }

        // Decoder for PersonattributetypeGetRef
        Decoders.addDecoder(clazz: PersonattributetypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonattributetypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PersonattributetypeGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonattributetypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [PersonattributetypeUpdate]
        Decoders.addDecoder(clazz: [PersonattributetypeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonattributetypeUpdate]> in
            return Decoders.decode(clazz: [PersonattributetypeUpdate].self, source: source)
        }

        // Decoder for PersonattributetypeUpdate
        Decoders.addDecoder(clazz: PersonattributetypeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonattributetypeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "PersonattributetypeUpdate", actual: "\(nameSource)"))
                }
                guard let descriptionSource = sourceDictionary["description"] as AnyObject? else {
                    return .failure(.missingKey(key: "description"))
                }
                guard let description = Decoders.decode(clazz: String.self.self, source: descriptionSource).value else {
                    return .failure(.typeMismatch(expected: "PersonattributetypeUpdate", actual: "\(descriptionSource)"))
                }
                let _result = PersonattributetypeUpdate(name: name, description: description)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["format"] as AnyObject?) {
                case let .success(value): _result.format = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["foreignKey"] as AnyObject?) {
                case let .success(value): _result.foreignKey = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["sortWeight"] as AnyObject?) {
                case let .success(value): _result.sortWeight = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["searchable"] as AnyObject?) {
                case let .success(value): _result.searchable = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PrivilegeCreate.self, source: sourceDictionary["editPrivilege"] as AnyObject?) {
                case let .success(value): _result.editPrivilege = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonattributetypeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [PersonimageGet]
        Decoders.addDecoder(clazz: [PersonimageGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonimageGet]> in
            return Decoders.decode(clazz: [PersonimageGet].self, source: source)
        }

        // Decoder for PersonimageGet
        Decoders.addDecoder(clazz: PersonimageGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonimageGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PersonimageGet()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonimageGet", actual: "\(source)"))
            }
        }
        // Decoder for [PersonimageGetFull]
        Decoders.addDecoder(clazz: [PersonimageGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonimageGetFull]> in
            return Decoders.decode(clazz: [PersonimageGetFull].self, source: source)
        }

        // Decoder for PersonimageGetFull
        Decoders.addDecoder(clazz: PersonimageGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonimageGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PersonimageGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonimageGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [PersonimageGetRef]
        Decoders.addDecoder(clazz: [PersonimageGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonimageGetRef]> in
            return Decoders.decode(clazz: [PersonimageGetRef].self, source: source)
        }

        // Decoder for PersonimageGetRef
        Decoders.addDecoder(clazz: PersonimageGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonimageGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PersonimageGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonimageGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [PrivilegeCreate]
        Decoders.addDecoder(clazz: [PrivilegeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PrivilegeCreate]> in
            return Decoders.decode(clazz: [PrivilegeCreate].self, source: source)
        }

        // Decoder for PrivilegeCreate
        Decoders.addDecoder(clazz: PrivilegeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PrivilegeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "PrivilegeCreate", actual: "\(nameSource)"))
                }
                let _result = PrivilegeCreate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PrivilegeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [PrivilegeCreateFull]
        Decoders.addDecoder(clazz: [PrivilegeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PrivilegeCreateFull]> in
            return Decoders.decode(clazz: [PrivilegeCreateFull].self, source: source)
        }

        // Decoder for PrivilegeCreateFull
        Decoders.addDecoder(clazz: PrivilegeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PrivilegeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "PrivilegeCreateFull", actual: "\(nameSource)"))
                }
                let _result = PrivilegeCreateFull(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PrivilegeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [PrivilegeGet]
        Decoders.addDecoder(clazz: [PrivilegeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PrivilegeGet]> in
            return Decoders.decode(clazz: [PrivilegeGet].self, source: source)
        }

        // Decoder for PrivilegeGet
        Decoders.addDecoder(clazz: PrivilegeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PrivilegeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PrivilegeGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PrivilegeGet", actual: "\(source)"))
            }
        }
        // Decoder for [PrivilegeGetFull]
        Decoders.addDecoder(clazz: [PrivilegeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PrivilegeGetFull]> in
            return Decoders.decode(clazz: [PrivilegeGetFull].self, source: source)
        }

        // Decoder for PrivilegeGetFull
        Decoders.addDecoder(clazz: PrivilegeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PrivilegeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PrivilegeGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PrivilegeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [PrivilegeGetRef]
        Decoders.addDecoder(clazz: [PrivilegeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PrivilegeGetRef]> in
            return Decoders.decode(clazz: [PrivilegeGetRef].self, source: source)
        }

        // Decoder for PrivilegeGetRef
        Decoders.addDecoder(clazz: PrivilegeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PrivilegeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PrivilegeGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PrivilegeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [PrivilegeUpdate]
        Decoders.addDecoder(clazz: [PrivilegeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PrivilegeUpdate]> in
            return Decoders.decode(clazz: [PrivilegeUpdate].self, source: source)
        }

        // Decoder for PrivilegeUpdate
        Decoders.addDecoder(clazz: PrivilegeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PrivilegeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = PrivilegeUpdate()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PrivilegeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramCreate]
        Decoders.addDecoder(clazz: [ProgramCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramCreate]> in
            return Decoders.decode(clazz: [ProgramCreate].self, source: source)
        }

        // Decoder for ProgramCreate
        Decoders.addDecoder(clazz: ProgramCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ProgramCreate", actual: "\(nameSource)"))
                }
                guard let descriptionSource = sourceDictionary["description"] as AnyObject? else {
                    return .failure(.missingKey(key: "description"))
                }
                guard let description = Decoders.decode(clazz: String.self.self, source: descriptionSource).value else {
                    return .failure(.typeMismatch(expected: "ProgramCreate", actual: "\(descriptionSource)"))
                }
                guard let conceptSource = sourceDictionary["concept"] as AnyObject? else {
                    return .failure(.missingKey(key: "concept"))
                }
                guard let concept = Decoders.decode(clazz: String.self.self, source: conceptSource).value else {
                    return .failure(.typeMismatch(expected: "ProgramCreate", actual: "\(conceptSource)"))
                }
                let _result = ProgramCreate(name: name, description: description, concept: concept)
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outcomesConcept"] as AnyObject?) {
                case let .success(value): _result.outcomesConcept = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramCreateFull]
        Decoders.addDecoder(clazz: [ProgramCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramCreateFull]> in
            return Decoders.decode(clazz: [ProgramCreateFull].self, source: source)
        }

        // Decoder for ProgramCreateFull
        Decoders.addDecoder(clazz: ProgramCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ProgramCreateFull", actual: "\(nameSource)"))
                }
                guard let descriptionSource = sourceDictionary["description"] as AnyObject? else {
                    return .failure(.missingKey(key: "description"))
                }
                guard let description = Decoders.decode(clazz: String.self.self, source: descriptionSource).value else {
                    return .failure(.typeMismatch(expected: "ProgramCreateFull", actual: "\(descriptionSource)"))
                }
                guard let conceptSource = sourceDictionary["concept"] as AnyObject? else {
                    return .failure(.missingKey(key: "concept"))
                }
                guard let concept = Decoders.decode(clazz: ConceptCreate.self.self, source: conceptSource).value else {
                    return .failure(.typeMismatch(expected: "ProgramCreateFull", actual: "\(conceptSource)"))
                }
                let _result = ProgramCreateFull(name: name, description: description, concept: concept)
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptCreate.self, source: sourceDictionary["outcomesConcept"] as AnyObject?) {
                case let .success(value): _result.outcomesConcept = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramGet]
        Decoders.addDecoder(clazz: [ProgramGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramGet]> in
            return Decoders.decode(clazz: [ProgramGet].self, source: source)
        }

        // Decoder for ProgramGet
        Decoders.addDecoder(clazz: ProgramGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ProgramGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [WorkflowGetRef].self, source: sourceDictionary["allWorkflows"] as AnyObject?) {
                case let .success(value): _result.allWorkflows = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramGet", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramGetFull]
        Decoders.addDecoder(clazz: [ProgramGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramGetFull]> in
            return Decoders.decode(clazz: [ProgramGetFull].self, source: source)
        }

        // Decoder for ProgramGetFull
        Decoders.addDecoder(clazz: ProgramGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ProgramGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [WorkflowGet].self, source: sourceDictionary["allWorkflows"] as AnyObject?) {
                case let .success(value): _result.allWorkflows = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramGetRef]
        Decoders.addDecoder(clazz: [ProgramGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramGetRef]> in
            return Decoders.decode(clazz: [ProgramGetRef].self, source: source)
        }

        // Decoder for ProgramGetRef
        Decoders.addDecoder(clazz: ProgramGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ProgramGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [WorkflowGetRef].self, source: sourceDictionary["allWorkflows"] as AnyObject?) {
                case let .success(value): _result.allWorkflows = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramUpdate]
        Decoders.addDecoder(clazz: [ProgramUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramUpdate]> in
            return Decoders.decode(clazz: [ProgramUpdate].self, source: source)
        }

        // Decoder for ProgramUpdate
        Decoders.addDecoder(clazz: ProgramUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ProgramUpdate()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramenrollmentCreate]
        Decoders.addDecoder(clazz: [ProgramenrollmentCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramenrollmentCreate]> in
            return Decoders.decode(clazz: [ProgramenrollmentCreate].self, source: source)
        }

        // Decoder for ProgramenrollmentCreate
        Decoders.addDecoder(clazz: ProgramenrollmentCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramenrollmentCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let patientSource = sourceDictionary["patient"] as AnyObject? else {
                    return .failure(.missingKey(key: "patient"))
                }
                guard let patient = Decoders.decode(clazz: String.self.self, source: patientSource).value else {
                    return .failure(.typeMismatch(expected: "ProgramenrollmentCreate", actual: "\(patientSource)"))
                }
                guard let programSource = sourceDictionary["program"] as AnyObject? else {
                    return .failure(.missingKey(key: "program"))
                }
                guard let program = Decoders.decode(clazz: String.self.self, source: programSource).value else {
                    return .failure(.typeMismatch(expected: "ProgramenrollmentCreate", actual: "\(programSource)"))
                }
                guard let dateEnrolledSource = sourceDictionary["dateEnrolled"] as AnyObject? else {
                    return .failure(.missingKey(key: "dateEnrolled"))
                }
                guard let dateEnrolled = Decoders.decode(clazz: ISOFullDate.self.self, source: dateEnrolledSource).value else {
                    return .failure(.typeMismatch(expected: "ProgramenrollmentCreate", actual: "\(dateEnrolledSource)"))
                }
                let _result = ProgramenrollmentCreate(patient: patient, program: program, dateEnrolled: dateEnrolled)
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["dateCompleted"] as AnyObject?) {
                case let .success(value): _result.dateCompleted = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ProgramenrollmentStateCreate].self, source: sourceDictionary["states"] as AnyObject?) {
                case let .success(value): _result.states = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptCreate.self, source: sourceDictionary["outcome"] as AnyObject?) {
                case let .success(value): _result.outcome = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramenrollmentCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramenrollmentCreateFull]
        Decoders.addDecoder(clazz: [ProgramenrollmentCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramenrollmentCreateFull]> in
            return Decoders.decode(clazz: [ProgramenrollmentCreateFull].self, source: source)
        }

        // Decoder for ProgramenrollmentCreateFull
        Decoders.addDecoder(clazz: ProgramenrollmentCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramenrollmentCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let patientSource = sourceDictionary["patient"] as AnyObject? else {
                    return .failure(.missingKey(key: "patient"))
                }
                guard let patient = Decoders.decode(clazz: PatientCreate.self.self, source: patientSource).value else {
                    return .failure(.typeMismatch(expected: "ProgramenrollmentCreateFull", actual: "\(patientSource)"))
                }
                guard let programSource = sourceDictionary["program"] as AnyObject? else {
                    return .failure(.missingKey(key: "program"))
                }
                guard let program = Decoders.decode(clazz: ProgramCreate.self.self, source: programSource).value else {
                    return .failure(.typeMismatch(expected: "ProgramenrollmentCreateFull", actual: "\(programSource)"))
                }
                guard let dateEnrolledSource = sourceDictionary["dateEnrolled"] as AnyObject? else {
                    return .failure(.missingKey(key: "dateEnrolled"))
                }
                guard let dateEnrolled = Decoders.decode(clazz: ISOFullDate.self.self, source: dateEnrolledSource).value else {
                    return .failure(.typeMismatch(expected: "ProgramenrollmentCreateFull", actual: "\(dateEnrolledSource)"))
                }
                let _result = ProgramenrollmentCreateFull(patient: patient, program: program, dateEnrolled: dateEnrolled)
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["dateCompleted"] as AnyObject?) {
                case let .success(value): _result.dateCompleted = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationCreate.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ProgramenrollmentStateCreate].self, source: sourceDictionary["states"] as AnyObject?) {
                case let .success(value): _result.states = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptCreate.self, source: sourceDictionary["outcome"] as AnyObject?) {
                case let .success(value): _result.outcome = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramenrollmentCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramenrollmentGet]
        Decoders.addDecoder(clazz: [ProgramenrollmentGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramenrollmentGet]> in
            return Decoders.decode(clazz: [ProgramenrollmentGet].self, source: source)
        }

        // Decoder for ProgramenrollmentGet
        Decoders.addDecoder(clazz: ProgramenrollmentGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramenrollmentGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ProgramenrollmentGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["dateEnrolled"] as AnyObject?) {
                case let .success(value): _result.dateEnrolled = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["dateCompleted"] as AnyObject?) {
                case let .success(value): _result.dateCompleted = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientGetRef.self, source: sourceDictionary["patient"] as AnyObject?) {
                case let .success(value): _result.patient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ProgramGetRef.self, source: sourceDictionary["program"] as AnyObject?) {
                case let .success(value): _result.program = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationGetRef.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramenrollmentGet", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramenrollmentGetFull]
        Decoders.addDecoder(clazz: [ProgramenrollmentGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramenrollmentGetFull]> in
            return Decoders.decode(clazz: [ProgramenrollmentGetFull].self, source: source)
        }

        // Decoder for ProgramenrollmentGetFull
        Decoders.addDecoder(clazz: ProgramenrollmentGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramenrollmentGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ProgramenrollmentGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["dateEnrolled"] as AnyObject?) {
                case let .success(value): _result.dateEnrolled = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["dateCompleted"] as AnyObject?) {
                case let .success(value): _result.dateCompleted = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientGet.self, source: sourceDictionary["patient"] as AnyObject?) {
                case let .success(value): _result.patient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ProgramGet.self, source: sourceDictionary["program"] as AnyObject?) {
                case let .success(value): _result.program = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationGet.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramenrollmentGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramenrollmentGetRef]
        Decoders.addDecoder(clazz: [ProgramenrollmentGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramenrollmentGetRef]> in
            return Decoders.decode(clazz: [ProgramenrollmentGetRef].self, source: source)
        }

        // Decoder for ProgramenrollmentGetRef
        Decoders.addDecoder(clazz: ProgramenrollmentGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramenrollmentGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ProgramenrollmentGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramenrollmentGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramenrollmentStateCreate]
        Decoders.addDecoder(clazz: [ProgramenrollmentStateCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramenrollmentStateCreate]> in
            return Decoders.decode(clazz: [ProgramenrollmentStateCreate].self, source: source)
        }

        // Decoder for ProgramenrollmentStateCreate
        Decoders.addDecoder(clazz: ProgramenrollmentStateCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramenrollmentStateCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let stateSource = sourceDictionary["state"] as AnyObject? else {
                    return .failure(.missingKey(key: "state"))
                }
                guard let state = Decoders.decode(clazz: WorkflowStateCreate.self.self, source: stateSource).value else {
                    return .failure(.typeMismatch(expected: "ProgramenrollmentStateCreate", actual: "\(stateSource)"))
                }
                let _result = ProgramenrollmentStateCreate(state: state)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramenrollmentStateCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramenrollmentStateCreateFull]
        Decoders.addDecoder(clazz: [ProgramenrollmentStateCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramenrollmentStateCreateFull]> in
            return Decoders.decode(clazz: [ProgramenrollmentStateCreateFull].self, source: source)
        }

        // Decoder for ProgramenrollmentStateCreateFull
        Decoders.addDecoder(clazz: ProgramenrollmentStateCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramenrollmentStateCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let stateSource = sourceDictionary["state"] as AnyObject? else {
                    return .failure(.missingKey(key: "state"))
                }
                guard let state = Decoders.decode(clazz: WorkflowStateCreate.self.self, source: stateSource).value else {
                    return .failure(.typeMismatch(expected: "ProgramenrollmentStateCreateFull", actual: "\(stateSource)"))
                }
                let _result = ProgramenrollmentStateCreateFull(state: state)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramenrollmentStateCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramenrollmentStateGet]
        Decoders.addDecoder(clazz: [ProgramenrollmentStateGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramenrollmentStateGet]> in
            return Decoders.decode(clazz: [ProgramenrollmentStateGet].self, source: source)
        }

        // Decoder for ProgramenrollmentStateGet
        Decoders.addDecoder(clazz: ProgramenrollmentStateGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramenrollmentStateGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ProgramenrollmentStateGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: WorkflowStateGet.self, source: sourceDictionary["state"] as AnyObject?) {
                case let .success(value): _result.state = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramenrollmentStateGet", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramenrollmentStateGetFull]
        Decoders.addDecoder(clazz: [ProgramenrollmentStateGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramenrollmentStateGetFull]> in
            return Decoders.decode(clazz: [ProgramenrollmentStateGetFull].self, source: source)
        }

        // Decoder for ProgramenrollmentStateGetFull
        Decoders.addDecoder(clazz: ProgramenrollmentStateGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramenrollmentStateGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ProgramenrollmentStateGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: WorkflowStateGetRef.self, source: sourceDictionary["state"] as AnyObject?) {
                case let .success(value): _result.state = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["patientProgram"] as AnyObject?) {
                case let .success(value): _result.patientProgram = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramenrollmentStateGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramenrollmentStateGetRef]
        Decoders.addDecoder(clazz: [ProgramenrollmentStateGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramenrollmentStateGetRef]> in
            return Decoders.decode(clazz: [ProgramenrollmentStateGetRef].self, source: source)
        }

        // Decoder for ProgramenrollmentStateGetRef
        Decoders.addDecoder(clazz: ProgramenrollmentStateGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramenrollmentStateGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ProgramenrollmentStateGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: WorkflowStateGetRef.self, source: sourceDictionary["state"] as AnyObject?) {
                case let .success(value): _result.state = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["patientProgram"] as AnyObject?) {
                case let .success(value): _result.patientProgram = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramenrollmentStateGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramenrollmentStateUpdate]
        Decoders.addDecoder(clazz: [ProgramenrollmentStateUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramenrollmentStateUpdate]> in
            return Decoders.decode(clazz: [ProgramenrollmentStateUpdate].self, source: source)
        }

        // Decoder for ProgramenrollmentStateUpdate
        Decoders.addDecoder(clazz: ProgramenrollmentStateUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramenrollmentStateUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ProgramenrollmentStateUpdate()
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramenrollmentStateUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramenrollmentUpdate]
        Decoders.addDecoder(clazz: [ProgramenrollmentUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramenrollmentUpdate]> in
            return Decoders.decode(clazz: [ProgramenrollmentUpdate].self, source: source)
        }

        // Decoder for ProgramenrollmentUpdate
        Decoders.addDecoder(clazz: ProgramenrollmentUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramenrollmentUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let dateEnrolledSource = sourceDictionary["dateEnrolled"] as AnyObject? else {
                    return .failure(.missingKey(key: "dateEnrolled"))
                }
                guard let dateEnrolled = Decoders.decode(clazz: ISOFullDate.self.self, source: dateEnrolledSource).value else {
                    return .failure(.typeMismatch(expected: "ProgramenrollmentUpdate", actual: "\(dateEnrolledSource)"))
                }
                let _result = ProgramenrollmentUpdate(dateEnrolled: dateEnrolled)
                switch Decoders.decodeOptional(clazz: [ProgramenrollmentStateCreate].self, source: sourceDictionary["states"] as AnyObject?) {
                case let .success(value): _result.states = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptCreate.self, source: sourceDictionary["outcome"] as AnyObject?) {
                case let .success(value): _result.outcome = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationCreate.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["dateCompleted"] as AnyObject?) {
                case let .success(value): _result.dateCompleted = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramenrollmentUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderAttributeCreate]
        Decoders.addDecoder(clazz: [ProviderAttributeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderAttributeCreate]> in
            return Decoders.decode(clazz: [ProviderAttributeCreate].self, source: source)
        }

        // Decoder for ProviderAttributeCreate
        Decoders.addDecoder(clazz: ProviderAttributeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderAttributeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let attributeTypeSource = sourceDictionary["attributeType"] as AnyObject? else {
                    return .failure(.missingKey(key: "attributeType"))
                }
                guard let attributeType = Decoders.decode(clazz: String.self.self, source: attributeTypeSource).value else {
                    return .failure(.typeMismatch(expected: "ProviderAttributeCreate", actual: "\(attributeTypeSource)"))
                }
                guard let valueSource = sourceDictionary["value"] as AnyObject? else {
                    return .failure(.missingKey(key: "value"))
                }
                guard let value = Decoders.decode(clazz: String.self.self, source: valueSource).value else {
                    return .failure(.typeMismatch(expected: "ProviderAttributeCreate", actual: "\(valueSource)"))
                }
                let _result = ProviderAttributeCreate(attributeType: attributeType, value: value)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderAttributeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderAttributeCreateFull]
        Decoders.addDecoder(clazz: [ProviderAttributeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderAttributeCreateFull]> in
            return Decoders.decode(clazz: [ProviderAttributeCreateFull].self, source: source)
        }

        // Decoder for ProviderAttributeCreateFull
        Decoders.addDecoder(clazz: ProviderAttributeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderAttributeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let attributeTypeSource = sourceDictionary["attributeType"] as AnyObject? else {
                    return .failure(.missingKey(key: "attributeType"))
                }
                guard let attributeType = Decoders.decode(clazz: String.self.self, source: attributeTypeSource).value else {
                    return .failure(.typeMismatch(expected: "ProviderAttributeCreateFull", actual: "\(attributeTypeSource)"))
                }
                guard let valueSource = sourceDictionary["value"] as AnyObject? else {
                    return .failure(.missingKey(key: "value"))
                }
                guard let value = Decoders.decode(clazz: String.self.self, source: valueSource).value else {
                    return .failure(.typeMismatch(expected: "ProviderAttributeCreateFull", actual: "\(valueSource)"))
                }
                let _result = ProviderAttributeCreateFull(attributeType: attributeType, value: value)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderAttributeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderAttributeGet]
        Decoders.addDecoder(clazz: [ProviderAttributeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderAttributeGet]> in
            return Decoders.decode(clazz: [ProviderAttributeGet].self, source: source)
        }

        // Decoder for ProviderAttributeGet
        Decoders.addDecoder(clazz: ProviderAttributeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderAttributeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ProviderAttributeGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderAttributeGet", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderAttributeGetFull]
        Decoders.addDecoder(clazz: [ProviderAttributeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderAttributeGetFull]> in
            return Decoders.decode(clazz: [ProviderAttributeGetFull].self, source: source)
        }

        // Decoder for ProviderAttributeGetFull
        Decoders.addDecoder(clazz: ProviderAttributeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderAttributeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ProviderAttributeGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderAttributeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderAttributeGetRef]
        Decoders.addDecoder(clazz: [ProviderAttributeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderAttributeGetRef]> in
            return Decoders.decode(clazz: [ProviderAttributeGetRef].self, source: source)
        }

        // Decoder for ProviderAttributeGetRef
        Decoders.addDecoder(clazz: ProviderAttributeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderAttributeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ProviderAttributeGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderAttributeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderAttributeUpdate]
        Decoders.addDecoder(clazz: [ProviderAttributeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderAttributeUpdate]> in
            return Decoders.decode(clazz: [ProviderAttributeUpdate].self, source: source)
        }

        // Decoder for ProviderAttributeUpdate
        Decoders.addDecoder(clazz: ProviderAttributeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderAttributeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let attributeTypeSource = sourceDictionary["attributeType"] as AnyObject? else {
                    return .failure(.missingKey(key: "attributeType"))
                }
                guard let attributeType = Decoders.decode(clazz: String.self.self, source: attributeTypeSource).value else {
                    return .failure(.typeMismatch(expected: "ProviderAttributeUpdate", actual: "\(attributeTypeSource)"))
                }
                guard let valueSource = sourceDictionary["value"] as AnyObject? else {
                    return .failure(.missingKey(key: "value"))
                }
                guard let value = Decoders.decode(clazz: String.self.self, source: valueSource).value else {
                    return .failure(.typeMismatch(expected: "ProviderAttributeUpdate", actual: "\(valueSource)"))
                }
                let _result = ProviderAttributeUpdate(attributeType: attributeType, value: value)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderAttributeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderCreate]
        Decoders.addDecoder(clazz: [ProviderCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderCreate]> in
            return Decoders.decode(clazz: [ProviderCreate].self, source: source)
        }

        // Decoder for ProviderCreate
        Decoders.addDecoder(clazz: ProviderCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ProviderCreate", actual: "\(nameSource)"))
                }
                guard let personSource = sourceDictionary["person"] as AnyObject? else {
                    return .failure(.missingKey(key: "person"))
                }
                guard let person = Decoders.decode(clazz: String.self.self, source: personSource).value else {
                    return .failure(.typeMismatch(expected: "ProviderCreate", actual: "\(personSource)"))
                }
                guard let identifierSource = sourceDictionary["identifier"] as AnyObject? else {
                    return .failure(.missingKey(key: "identifier"))
                }
                guard let identifier = Decoders.decode(clazz: String.self.self, source: identifierSource).value else {
                    return .failure(.typeMismatch(expected: "ProviderCreate", actual: "\(identifierSource)"))
                }
                let _result = ProviderCreate(name: name, person: person, identifier: identifier)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ProviderAttributeCreate].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderCreateFull]
        Decoders.addDecoder(clazz: [ProviderCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderCreateFull]> in
            return Decoders.decode(clazz: [ProviderCreateFull].self, source: source)
        }

        // Decoder for ProviderCreateFull
        Decoders.addDecoder(clazz: ProviderCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ProviderCreateFull", actual: "\(nameSource)"))
                }
                guard let personSource = sourceDictionary["person"] as AnyObject? else {
                    return .failure(.missingKey(key: "person"))
                }
                guard let person = Decoders.decode(clazz: PersonCreate.self.self, source: personSource).value else {
                    return .failure(.typeMismatch(expected: "ProviderCreateFull", actual: "\(personSource)"))
                }
                guard let identifierSource = sourceDictionary["identifier"] as AnyObject? else {
                    return .failure(.missingKey(key: "identifier"))
                }
                guard let identifier = Decoders.decode(clazz: String.self.self, source: identifierSource).value else {
                    return .failure(.typeMismatch(expected: "ProviderCreateFull", actual: "\(identifierSource)"))
                }
                let _result = ProviderCreateFull(name: name, person: person, identifier: identifier)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ProviderAttributeCreate].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderGet]
        Decoders.addDecoder(clazz: [ProviderGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderGet]> in
            return Decoders.decode(clazz: [ProviderGet].self, source: source)
        }

        // Decoder for ProviderGet
        Decoders.addDecoder(clazz: ProviderGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ProviderGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonGetRef.self, source: sourceDictionary["person"] as AnyObject?) {
                case let .success(value): _result.person = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["identifier"] as AnyObject?) {
                case let .success(value): _result.identifier = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ProviderAttributeGetRef].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderGet", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderGetFull]
        Decoders.addDecoder(clazz: [ProviderGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderGetFull]> in
            return Decoders.decode(clazz: [ProviderGetFull].self, source: source)
        }

        // Decoder for ProviderGetFull
        Decoders.addDecoder(clazz: ProviderGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ProviderGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonGet.self, source: sourceDictionary["person"] as AnyObject?) {
                case let .success(value): _result.person = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["identifier"] as AnyObject?) {
                case let .success(value): _result.identifier = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ProviderAttributeGet].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderGetRef]
        Decoders.addDecoder(clazz: [ProviderGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderGetRef]> in
            return Decoders.decode(clazz: [ProviderGetRef].self, source: source)
        }

        // Decoder for ProviderGetRef
        Decoders.addDecoder(clazz: ProviderGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ProviderGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderUpdate]
        Decoders.addDecoder(clazz: [ProviderUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderUpdate]> in
            return Decoders.decode(clazz: [ProviderUpdate].self, source: source)
        }

        // Decoder for ProviderUpdate
        Decoders.addDecoder(clazz: ProviderUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ProviderUpdate", actual: "\(nameSource)"))
                }
                guard let personSource = sourceDictionary["person"] as AnyObject? else {
                    return .failure(.missingKey(key: "person"))
                }
                guard let person = Decoders.decode(clazz: String.self.self, source: personSource).value else {
                    return .failure(.typeMismatch(expected: "ProviderUpdate", actual: "\(personSource)"))
                }
                guard let identifierSource = sourceDictionary["identifier"] as AnyObject? else {
                    return .failure(.missingKey(key: "identifier"))
                }
                guard let identifier = Decoders.decode(clazz: String.self.self, source: identifierSource).value else {
                    return .failure(.typeMismatch(expected: "ProviderUpdate", actual: "\(identifierSource)"))
                }
                let _result = ProviderUpdate(name: name, person: person, identifier: identifier)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ProviderAttributeCreate].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderattributetypeCreate]
        Decoders.addDecoder(clazz: [ProviderattributetypeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderattributetypeCreate]> in
            return Decoders.decode(clazz: [ProviderattributetypeCreate].self, source: source)
        }

        // Decoder for ProviderattributetypeCreate
        Decoders.addDecoder(clazz: ProviderattributetypeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderattributetypeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ProviderattributetypeCreate", actual: "\(nameSource)"))
                }
                guard let datatypeClassnameSource = sourceDictionary["datatypeClassname"] as AnyObject? else {
                    return .failure(.missingKey(key: "datatypeClassname"))
                }
                guard let datatypeClassname = Decoders.decode(clazz: String.self.self, source: datatypeClassnameSource).value else {
                    return .failure(.typeMismatch(expected: "ProviderattributetypeCreate", actual: "\(datatypeClassnameSource)"))
                }
                let _result = ProviderattributetypeCreate(name: name, datatypeClassname: datatypeClassname)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderattributetypeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderattributetypeCreateFull]
        Decoders.addDecoder(clazz: [ProviderattributetypeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderattributetypeCreateFull]> in
            return Decoders.decode(clazz: [ProviderattributetypeCreateFull].self, source: source)
        }

        // Decoder for ProviderattributetypeCreateFull
        Decoders.addDecoder(clazz: ProviderattributetypeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderattributetypeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ProviderattributetypeCreateFull", actual: "\(nameSource)"))
                }
                guard let datatypeClassnameSource = sourceDictionary["datatypeClassname"] as AnyObject? else {
                    return .failure(.missingKey(key: "datatypeClassname"))
                }
                guard let datatypeClassname = Decoders.decode(clazz: String.self.self, source: datatypeClassnameSource).value else {
                    return .failure(.typeMismatch(expected: "ProviderattributetypeCreateFull", actual: "\(datatypeClassnameSource)"))
                }
                let _result = ProviderattributetypeCreateFull(name: name, datatypeClassname: datatypeClassname)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderattributetypeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderattributetypeGet]
        Decoders.addDecoder(clazz: [ProviderattributetypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderattributetypeGet]> in
            return Decoders.decode(clazz: [ProviderattributetypeGet].self, source: source)
        }

        // Decoder for ProviderattributetypeGet
        Decoders.addDecoder(clazz: ProviderattributetypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderattributetypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ProviderattributetypeGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderattributetypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderattributetypeGetFull]
        Decoders.addDecoder(clazz: [ProviderattributetypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderattributetypeGetFull]> in
            return Decoders.decode(clazz: [ProviderattributetypeGetFull].self, source: source)
        }

        // Decoder for ProviderattributetypeGetFull
        Decoders.addDecoder(clazz: ProviderattributetypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderattributetypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ProviderattributetypeGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderattributetypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderattributetypeGetRef]
        Decoders.addDecoder(clazz: [ProviderattributetypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderattributetypeGetRef]> in
            return Decoders.decode(clazz: [ProviderattributetypeGetRef].self, source: source)
        }

        // Decoder for ProviderattributetypeGetRef
        Decoders.addDecoder(clazz: ProviderattributetypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderattributetypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ProviderattributetypeGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderattributetypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderattributetypeUpdate]
        Decoders.addDecoder(clazz: [ProviderattributetypeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderattributetypeUpdate]> in
            return Decoders.decode(clazz: [ProviderattributetypeUpdate].self, source: source)
        }

        // Decoder for ProviderattributetypeUpdate
        Decoders.addDecoder(clazz: ProviderattributetypeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderattributetypeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ProviderattributetypeUpdate", actual: "\(nameSource)"))
                }
                guard let datatypeClassnameSource = sourceDictionary["datatypeClassname"] as AnyObject? else {
                    return .failure(.missingKey(key: "datatypeClassname"))
                }
                guard let datatypeClassname = Decoders.decode(clazz: String.self.self, source: datatypeClassnameSource).value else {
                    return .failure(.typeMismatch(expected: "ProviderattributetypeUpdate", actual: "\(datatypeClassnameSource)"))
                }
                let _result = ProviderattributetypeUpdate(name: name, datatypeClassname: datatypeClassname)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderattributetypeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [RelationshipCreate]
        Decoders.addDecoder(clazz: [RelationshipCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RelationshipCreate]> in
            return Decoders.decode(clazz: [RelationshipCreate].self, source: source)
        }

        // Decoder for RelationshipCreate
        Decoders.addDecoder(clazz: RelationshipCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RelationshipCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let personASource = sourceDictionary["personA"] as AnyObject? else {
                    return .failure(.missingKey(key: "personA"))
                }
                guard let personA = Decoders.decode(clazz: String.self.self, source: personASource).value else {
                    return .failure(.typeMismatch(expected: "RelationshipCreate", actual: "\(personASource)"))
                }
                guard let relationshipTypeSource = sourceDictionary["relationshipType"] as AnyObject? else {
                    return .failure(.missingKey(key: "relationshipType"))
                }
                guard let relationshipType = Decoders.decode(clazz: String.self.self, source: relationshipTypeSource).value else {
                    return .failure(.typeMismatch(expected: "RelationshipCreate", actual: "\(relationshipTypeSource)"))
                }
                guard let personBSource = sourceDictionary["personB"] as AnyObject? else {
                    return .failure(.missingKey(key: "personB"))
                }
                guard let personB = Decoders.decode(clazz: String.self.self, source: personBSource).value else {
                    return .failure(.typeMismatch(expected: "RelationshipCreate", actual: "\(personBSource)"))
                }
                let _result = RelationshipCreate(personA: personA, relationshipType: relationshipType, personB: personB)
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RelationshipCreate", actual: "\(source)"))
            }
        }
        // Decoder for [RelationshipCreateFull]
        Decoders.addDecoder(clazz: [RelationshipCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RelationshipCreateFull]> in
            return Decoders.decode(clazz: [RelationshipCreateFull].self, source: source)
        }

        // Decoder for RelationshipCreateFull
        Decoders.addDecoder(clazz: RelationshipCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RelationshipCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let personASource = sourceDictionary["personA"] as AnyObject? else {
                    return .failure(.missingKey(key: "personA"))
                }
                guard let personA = Decoders.decode(clazz: PersonCreate.self.self, source: personASource).value else {
                    return .failure(.typeMismatch(expected: "RelationshipCreateFull", actual: "\(personASource)"))
                }
                guard let relationshipTypeSource = sourceDictionary["relationshipType"] as AnyObject? else {
                    return .failure(.missingKey(key: "relationshipType"))
                }
                guard let relationshipType = Decoders.decode(clazz: RelationshiptypeCreate.self.self, source: relationshipTypeSource).value else {
                    return .failure(.typeMismatch(expected: "RelationshipCreateFull", actual: "\(relationshipTypeSource)"))
                }
                guard let personBSource = sourceDictionary["personB"] as AnyObject? else {
                    return .failure(.missingKey(key: "personB"))
                }
                guard let personB = Decoders.decode(clazz: PersonCreate.self.self, source: personBSource).value else {
                    return .failure(.typeMismatch(expected: "RelationshipCreateFull", actual: "\(personBSource)"))
                }
                let _result = RelationshipCreateFull(personA: personA, relationshipType: relationshipType, personB: personB)
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RelationshipCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [RelationshipGet]
        Decoders.addDecoder(clazz: [RelationshipGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RelationshipGet]> in
            return Decoders.decode(clazz: [RelationshipGet].self, source: source)
        }

        // Decoder for RelationshipGet
        Decoders.addDecoder(clazz: RelationshipGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RelationshipGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = RelationshipGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonGetRef.self, source: sourceDictionary["personA"] as AnyObject?) {
                case let .success(value): _result.personA = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: RelationshiptypeGetRef.self, source: sourceDictionary["relationshipType"] as AnyObject?) {
                case let .success(value): _result.relationshipType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonGetRef.self, source: sourceDictionary["personB"] as AnyObject?) {
                case let .success(value): _result.personB = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RelationshipGet", actual: "\(source)"))
            }
        }
        // Decoder for [RelationshipGetFull]
        Decoders.addDecoder(clazz: [RelationshipGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RelationshipGetFull]> in
            return Decoders.decode(clazz: [RelationshipGetFull].self, source: source)
        }

        // Decoder for RelationshipGetFull
        Decoders.addDecoder(clazz: RelationshipGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RelationshipGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = RelationshipGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonGet.self, source: sourceDictionary["personA"] as AnyObject?) {
                case let .success(value): _result.personA = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: RelationshiptypeGet.self, source: sourceDictionary["relationshipType"] as AnyObject?) {
                case let .success(value): _result.relationshipType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonGet.self, source: sourceDictionary["personB"] as AnyObject?) {
                case let .success(value): _result.personB = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RelationshipGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [RelationshipGetRef]
        Decoders.addDecoder(clazz: [RelationshipGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RelationshipGetRef]> in
            return Decoders.decode(clazz: [RelationshipGetRef].self, source: source)
        }

        // Decoder for RelationshipGetRef
        Decoders.addDecoder(clazz: RelationshipGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RelationshipGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = RelationshipGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RelationshipGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [RelationshipUpdate]
        Decoders.addDecoder(clazz: [RelationshipUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RelationshipUpdate]> in
            return Decoders.decode(clazz: [RelationshipUpdate].self, source: source)
        }

        // Decoder for RelationshipUpdate
        Decoders.addDecoder(clazz: RelationshipUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RelationshipUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = RelationshipUpdate()
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RelationshipUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [RelationshiptypeCreate]
        Decoders.addDecoder(clazz: [RelationshiptypeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RelationshiptypeCreate]> in
            return Decoders.decode(clazz: [RelationshiptypeCreate].self, source: source)
        }

        // Decoder for RelationshiptypeCreate
        Decoders.addDecoder(clazz: RelationshiptypeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RelationshiptypeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "RelationshiptypeCreate", actual: "\(nameSource)"))
                }
                guard let aIsToBSource = sourceDictionary["aIsToB"] as AnyObject? else {
                    return .failure(.missingKey(key: "aIsToB"))
                }
                guard let aIsToB = Decoders.decode(clazz: String.self.self, source: aIsToBSource).value else {
                    return .failure(.typeMismatch(expected: "RelationshiptypeCreate", actual: "\(aIsToBSource)"))
                }
                guard let bIsToASource = sourceDictionary["bIsToA"] as AnyObject? else {
                    return .failure(.missingKey(key: "bIsToA"))
                }
                guard let bIsToA = Decoders.decode(clazz: String.self.self, source: bIsToASource).value else {
                    return .failure(.typeMismatch(expected: "RelationshiptypeCreate", actual: "\(bIsToASource)"))
                }
                let _result = RelationshiptypeCreate(name: name, aIsToB: aIsToB, bIsToA: bIsToA)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["weight"] as AnyObject?) {
                case let .success(value): _result.weight = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RelationshiptypeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [RelationshiptypeCreateFull]
        Decoders.addDecoder(clazz: [RelationshiptypeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RelationshiptypeCreateFull]> in
            return Decoders.decode(clazz: [RelationshiptypeCreateFull].self, source: source)
        }

        // Decoder for RelationshiptypeCreateFull
        Decoders.addDecoder(clazz: RelationshiptypeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RelationshiptypeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "RelationshiptypeCreateFull", actual: "\(nameSource)"))
                }
                guard let aIsToBSource = sourceDictionary["aIsToB"] as AnyObject? else {
                    return .failure(.missingKey(key: "aIsToB"))
                }
                guard let aIsToB = Decoders.decode(clazz: String.self.self, source: aIsToBSource).value else {
                    return .failure(.typeMismatch(expected: "RelationshiptypeCreateFull", actual: "\(aIsToBSource)"))
                }
                guard let bIsToASource = sourceDictionary["bIsToA"] as AnyObject? else {
                    return .failure(.missingKey(key: "bIsToA"))
                }
                guard let bIsToA = Decoders.decode(clazz: String.self.self, source: bIsToASource).value else {
                    return .failure(.typeMismatch(expected: "RelationshiptypeCreateFull", actual: "\(bIsToASource)"))
                }
                let _result = RelationshiptypeCreateFull(name: name, aIsToB: aIsToB, bIsToA: bIsToA)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["weight"] as AnyObject?) {
                case let .success(value): _result.weight = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RelationshiptypeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [RelationshiptypeGet]
        Decoders.addDecoder(clazz: [RelationshiptypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RelationshiptypeGet]> in
            return Decoders.decode(clazz: [RelationshiptypeGet].self, source: source)
        }

        // Decoder for RelationshiptypeGet
        Decoders.addDecoder(clazz: RelationshiptypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RelationshiptypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = RelationshiptypeGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["aIsToB"] as AnyObject?) {
                case let .success(value): _result.aIsToB = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["bIsToA"] as AnyObject?) {
                case let .success(value): _result.bIsToA = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RelationshiptypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [RelationshiptypeGetFull]
        Decoders.addDecoder(clazz: [RelationshiptypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RelationshiptypeGetFull]> in
            return Decoders.decode(clazz: [RelationshiptypeGetFull].self, source: source)
        }

        // Decoder for RelationshiptypeGetFull
        Decoders.addDecoder(clazz: RelationshiptypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RelationshiptypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = RelationshiptypeGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["aIsToB"] as AnyObject?) {
                case let .success(value): _result.aIsToB = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["bIsToA"] as AnyObject?) {
                case let .success(value): _result.bIsToA = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["weight"] as AnyObject?) {
                case let .success(value): _result.weight = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RelationshiptypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [RelationshiptypeGetRef]
        Decoders.addDecoder(clazz: [RelationshiptypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RelationshiptypeGetRef]> in
            return Decoders.decode(clazz: [RelationshiptypeGetRef].self, source: source)
        }

        // Decoder for RelationshiptypeGetRef
        Decoders.addDecoder(clazz: RelationshiptypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RelationshiptypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = RelationshiptypeGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RelationshiptypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [RelationshiptypeUpdate]
        Decoders.addDecoder(clazz: [RelationshiptypeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RelationshiptypeUpdate]> in
            return Decoders.decode(clazz: [RelationshiptypeUpdate].self, source: source)
        }

        // Decoder for RelationshiptypeUpdate
        Decoders.addDecoder(clazz: RelationshiptypeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RelationshiptypeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = RelationshiptypeUpdate()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RelationshiptypeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestCohortDefinitionCreate]
        Decoders.addDecoder(clazz: [ReportingrestCohortDefinitionCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestCohortDefinitionCreate]> in
            return Decoders.decode(clazz: [ReportingrestCohortDefinitionCreate].self, source: source)
        }

        // Decoder for ReportingrestCohortDefinitionCreate
        Decoders.addDecoder(clazz: ReportingrestCohortDefinitionCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestCohortDefinitionCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ReportingrestCohortDefinitionCreate", actual: "\(nameSource)"))
                }
                let _result = ReportingrestCohortDefinitionCreate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestCohortDefinitionCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestCohortDefinitionCreateFull]
        Decoders.addDecoder(clazz: [ReportingrestCohortDefinitionCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestCohortDefinitionCreateFull]> in
            return Decoders.decode(clazz: [ReportingrestCohortDefinitionCreateFull].self, source: source)
        }

        // Decoder for ReportingrestCohortDefinitionCreateFull
        Decoders.addDecoder(clazz: ReportingrestCohortDefinitionCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestCohortDefinitionCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ReportingrestCohortDefinitionCreateFull", actual: "\(nameSource)"))
                }
                let _result = ReportingrestCohortDefinitionCreateFull(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestCohortDefinitionCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestCohortDefinitionGet]
        Decoders.addDecoder(clazz: [ReportingrestCohortDefinitionGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestCohortDefinitionGet]> in
            return Decoders.decode(clazz: [ReportingrestCohortDefinitionGet].self, source: source)
        }

        // Decoder for ReportingrestCohortDefinitionGet
        Decoders.addDecoder(clazz: ReportingrestCohortDefinitionGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestCohortDefinitionGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ReportingrestCohortDefinitionGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestCohortDefinitionGet", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestCohortDefinitionGetFull]
        Decoders.addDecoder(clazz: [ReportingrestCohortDefinitionGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestCohortDefinitionGetFull]> in
            return Decoders.decode(clazz: [ReportingrestCohortDefinitionGetFull].self, source: source)
        }

        // Decoder for ReportingrestCohortDefinitionGetFull
        Decoders.addDecoder(clazz: ReportingrestCohortDefinitionGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestCohortDefinitionGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ReportingrestCohortDefinitionGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestCohortDefinitionGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestCohortDefinitionGetRef]
        Decoders.addDecoder(clazz: [ReportingrestCohortDefinitionGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestCohortDefinitionGetRef]> in
            return Decoders.decode(clazz: [ReportingrestCohortDefinitionGetRef].self, source: source)
        }

        // Decoder for ReportingrestCohortDefinitionGetRef
        Decoders.addDecoder(clazz: ReportingrestCohortDefinitionGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestCohortDefinitionGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ReportingrestCohortDefinitionGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestCohortDefinitionGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestCohortDefinitionUpdate]
        Decoders.addDecoder(clazz: [ReportingrestCohortDefinitionUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestCohortDefinitionUpdate]> in
            return Decoders.decode(clazz: [ReportingrestCohortDefinitionUpdate].self, source: source)
        }

        // Decoder for ReportingrestCohortDefinitionUpdate
        Decoders.addDecoder(clazz: ReportingrestCohortDefinitionUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestCohortDefinitionUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ReportingrestCohortDefinitionUpdate", actual: "\(nameSource)"))
                }
                let _result = ReportingrestCohortDefinitionUpdate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestCohortDefinitionUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestCohortGet]
        Decoders.addDecoder(clazz: [ReportingrestCohortGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestCohortGet]> in
            return Decoders.decode(clazz: [ReportingrestCohortGet].self, source: source)
        }

        // Decoder for ReportingrestCohortGet
        Decoders.addDecoder(clazz: ReportingrestCohortGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestCohortGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ReportingrestCohortGet()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestCohortGet", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestCohortGetFull]
        Decoders.addDecoder(clazz: [ReportingrestCohortGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestCohortGetFull]> in
            return Decoders.decode(clazz: [ReportingrestCohortGetFull].self, source: source)
        }

        // Decoder for ReportingrestCohortGetFull
        Decoders.addDecoder(clazz: ReportingrestCohortGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestCohortGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ReportingrestCohortGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestCohortGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestCohortGetRef]
        Decoders.addDecoder(clazz: [ReportingrestCohortGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestCohortGetRef]> in
            return Decoders.decode(clazz: [ReportingrestCohortGetRef].self, source: source)
        }

        // Decoder for ReportingrestCohortGetRef
        Decoders.addDecoder(clazz: ReportingrestCohortGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestCohortGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ReportingrestCohortGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestCohortGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestDataSetDefinitionCreate]
        Decoders.addDecoder(clazz: [ReportingrestDataSetDefinitionCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestDataSetDefinitionCreate]> in
            return Decoders.decode(clazz: [ReportingrestDataSetDefinitionCreate].self, source: source)
        }

        // Decoder for ReportingrestDataSetDefinitionCreate
        Decoders.addDecoder(clazz: ReportingrestDataSetDefinitionCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestDataSetDefinitionCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ReportingrestDataSetDefinitionCreate", actual: "\(nameSource)"))
                }
                let _result = ReportingrestDataSetDefinitionCreate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestDataSetDefinitionCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestDataSetDefinitionCreateFull]
        Decoders.addDecoder(clazz: [ReportingrestDataSetDefinitionCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestDataSetDefinitionCreateFull]> in
            return Decoders.decode(clazz: [ReportingrestDataSetDefinitionCreateFull].self, source: source)
        }

        // Decoder for ReportingrestDataSetDefinitionCreateFull
        Decoders.addDecoder(clazz: ReportingrestDataSetDefinitionCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestDataSetDefinitionCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ReportingrestDataSetDefinitionCreateFull", actual: "\(nameSource)"))
                }
                let _result = ReportingrestDataSetDefinitionCreateFull(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestDataSetDefinitionCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestDataSetDefinitionGet]
        Decoders.addDecoder(clazz: [ReportingrestDataSetDefinitionGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestDataSetDefinitionGet]> in
            return Decoders.decode(clazz: [ReportingrestDataSetDefinitionGet].self, source: source)
        }

        // Decoder for ReportingrestDataSetDefinitionGet
        Decoders.addDecoder(clazz: ReportingrestDataSetDefinitionGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestDataSetDefinitionGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ReportingrestDataSetDefinitionGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestDataSetDefinitionGet", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestDataSetDefinitionGetFull]
        Decoders.addDecoder(clazz: [ReportingrestDataSetDefinitionGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestDataSetDefinitionGetFull]> in
            return Decoders.decode(clazz: [ReportingrestDataSetDefinitionGetFull].self, source: source)
        }

        // Decoder for ReportingrestDataSetDefinitionGetFull
        Decoders.addDecoder(clazz: ReportingrestDataSetDefinitionGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestDataSetDefinitionGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ReportingrestDataSetDefinitionGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestDataSetDefinitionGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestDataSetDefinitionGetRef]
        Decoders.addDecoder(clazz: [ReportingrestDataSetDefinitionGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestDataSetDefinitionGetRef]> in
            return Decoders.decode(clazz: [ReportingrestDataSetDefinitionGetRef].self, source: source)
        }

        // Decoder for ReportingrestDataSetDefinitionGetRef
        Decoders.addDecoder(clazz: ReportingrestDataSetDefinitionGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestDataSetDefinitionGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ReportingrestDataSetDefinitionGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestDataSetDefinitionGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestDataSetDefinitionUpdate]
        Decoders.addDecoder(clazz: [ReportingrestDataSetDefinitionUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestDataSetDefinitionUpdate]> in
            return Decoders.decode(clazz: [ReportingrestDataSetDefinitionUpdate].self, source: source)
        }

        // Decoder for ReportingrestDataSetDefinitionUpdate
        Decoders.addDecoder(clazz: ReportingrestDataSetDefinitionUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestDataSetDefinitionUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ReportingrestDataSetDefinitionUpdate", actual: "\(nameSource)"))
                }
                let _result = ReportingrestDataSetDefinitionUpdate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestDataSetDefinitionUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestDataSetGet]
        Decoders.addDecoder(clazz: [ReportingrestDataSetGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestDataSetGet]> in
            return Decoders.decode(clazz: [ReportingrestDataSetGet].self, source: source)
        }

        // Decoder for ReportingrestDataSetGet
        Decoders.addDecoder(clazz: ReportingrestDataSetGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestDataSetGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ReportingrestDataSetGet()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestDataSetGet", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestDataSetGetFull]
        Decoders.addDecoder(clazz: [ReportingrestDataSetGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestDataSetGetFull]> in
            return Decoders.decode(clazz: [ReportingrestDataSetGetFull].self, source: source)
        }

        // Decoder for ReportingrestDataSetGetFull
        Decoders.addDecoder(clazz: ReportingrestDataSetGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestDataSetGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ReportingrestDataSetGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestDataSetGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestDataSetGetRef]
        Decoders.addDecoder(clazz: [ReportingrestDataSetGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestDataSetGetRef]> in
            return Decoders.decode(clazz: [ReportingrestDataSetGetRef].self, source: source)
        }

        // Decoder for ReportingrestDataSetGetRef
        Decoders.addDecoder(clazz: ReportingrestDataSetGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestDataSetGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ReportingrestDataSetGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestDataSetGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestReportDefinitionCreate]
        Decoders.addDecoder(clazz: [ReportingrestReportDefinitionCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestReportDefinitionCreate]> in
            return Decoders.decode(clazz: [ReportingrestReportDefinitionCreate].self, source: source)
        }

        // Decoder for ReportingrestReportDefinitionCreate
        Decoders.addDecoder(clazz: ReportingrestReportDefinitionCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestReportDefinitionCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ReportingrestReportDefinitionCreate", actual: "\(nameSource)"))
                }
                let _result = ReportingrestReportDefinitionCreate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestReportDefinitionCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestReportDefinitionCreateFull]
        Decoders.addDecoder(clazz: [ReportingrestReportDefinitionCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestReportDefinitionCreateFull]> in
            return Decoders.decode(clazz: [ReportingrestReportDefinitionCreateFull].self, source: source)
        }

        // Decoder for ReportingrestReportDefinitionCreateFull
        Decoders.addDecoder(clazz: ReportingrestReportDefinitionCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestReportDefinitionCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ReportingrestReportDefinitionCreateFull", actual: "\(nameSource)"))
                }
                let _result = ReportingrestReportDefinitionCreateFull(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestReportDefinitionCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestReportDefinitionGet]
        Decoders.addDecoder(clazz: [ReportingrestReportDefinitionGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestReportDefinitionGet]> in
            return Decoders.decode(clazz: [ReportingrestReportDefinitionGet].self, source: source)
        }

        // Decoder for ReportingrestReportDefinitionGet
        Decoders.addDecoder(clazz: ReportingrestReportDefinitionGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestReportDefinitionGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ReportingrestReportDefinitionGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestReportDefinitionGet", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestReportDefinitionGetFull]
        Decoders.addDecoder(clazz: [ReportingrestReportDefinitionGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestReportDefinitionGetFull]> in
            return Decoders.decode(clazz: [ReportingrestReportDefinitionGetFull].self, source: source)
        }

        // Decoder for ReportingrestReportDefinitionGetFull
        Decoders.addDecoder(clazz: ReportingrestReportDefinitionGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestReportDefinitionGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ReportingrestReportDefinitionGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestReportDefinitionGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestReportDefinitionGetRef]
        Decoders.addDecoder(clazz: [ReportingrestReportDefinitionGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestReportDefinitionGetRef]> in
            return Decoders.decode(clazz: [ReportingrestReportDefinitionGetRef].self, source: source)
        }

        // Decoder for ReportingrestReportDefinitionGetRef
        Decoders.addDecoder(clazz: ReportingrestReportDefinitionGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestReportDefinitionGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ReportingrestReportDefinitionGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestReportDefinitionGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestReportDefinitionUpdate]
        Decoders.addDecoder(clazz: [ReportingrestReportDefinitionUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestReportDefinitionUpdate]> in
            return Decoders.decode(clazz: [ReportingrestReportDefinitionUpdate].self, source: source)
        }

        // Decoder for ReportingrestReportDefinitionUpdate
        Decoders.addDecoder(clazz: ReportingrestReportDefinitionUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestReportDefinitionUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "ReportingrestReportDefinitionUpdate", actual: "\(nameSource)"))
                }
                let _result = ReportingrestReportDefinitionUpdate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestReportDefinitionUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestReportRequestGet]
        Decoders.addDecoder(clazz: [ReportingrestReportRequestGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestReportRequestGet]> in
            return Decoders.decode(clazz: [ReportingrestReportRequestGet].self, source: source)
        }

        // Decoder for ReportingrestReportRequestGet
        Decoders.addDecoder(clazz: ReportingrestReportRequestGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestReportRequestGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ReportingrestReportRequestGet()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestReportRequestGet", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestReportRequestGetFull]
        Decoders.addDecoder(clazz: [ReportingrestReportRequestGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestReportRequestGetFull]> in
            return Decoders.decode(clazz: [ReportingrestReportRequestGetFull].self, source: source)
        }

        // Decoder for ReportingrestReportRequestGetFull
        Decoders.addDecoder(clazz: ReportingrestReportRequestGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestReportRequestGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ReportingrestReportRequestGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestReportRequestGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestReportRequestGetRef]
        Decoders.addDecoder(clazz: [ReportingrestReportRequestGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestReportRequestGetRef]> in
            return Decoders.decode(clazz: [ReportingrestReportRequestGetRef].self, source: source)
        }

        // Decoder for ReportingrestReportRequestGetRef
        Decoders.addDecoder(clazz: ReportingrestReportRequestGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestReportRequestGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ReportingrestReportRequestGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestReportRequestGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestReportdataGet]
        Decoders.addDecoder(clazz: [ReportingrestReportdataGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestReportdataGet]> in
            return Decoders.decode(clazz: [ReportingrestReportdataGet].self, source: source)
        }

        // Decoder for ReportingrestReportdataGet
        Decoders.addDecoder(clazz: ReportingrestReportdataGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestReportdataGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ReportingrestReportdataGet()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestReportdataGet", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestReportdataGetFull]
        Decoders.addDecoder(clazz: [ReportingrestReportdataGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestReportdataGetFull]> in
            return Decoders.decode(clazz: [ReportingrestReportdataGetFull].self, source: source)
        }

        // Decoder for ReportingrestReportdataGetFull
        Decoders.addDecoder(clazz: ReportingrestReportdataGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestReportdataGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ReportingrestReportdataGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestReportdataGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestReportdataGetRef]
        Decoders.addDecoder(clazz: [ReportingrestReportdataGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestReportdataGetRef]> in
            return Decoders.decode(clazz: [ReportingrestReportdataGetRef].self, source: source)
        }

        // Decoder for ReportingrestReportdataGetRef
        Decoders.addDecoder(clazz: ReportingrestReportdataGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestReportdataGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ReportingrestReportdataGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestReportdataGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [RoleCreate]
        Decoders.addDecoder(clazz: [RoleCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RoleCreate]> in
            return Decoders.decode(clazz: [RoleCreate].self, source: source)
        }

        // Decoder for RoleCreate
        Decoders.addDecoder(clazz: RoleCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RoleCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "RoleCreate", actual: "\(nameSource)"))
                }
                let _result = RoleCreate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PrivilegeCreate].self, source: sourceDictionary["privileges"] as AnyObject?) {
                case let .success(value): _result.privileges = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [RoleCreate].self, source: sourceDictionary["inheritedRoles"] as AnyObject?) {
                case let .success(value): _result.inheritedRoles = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RoleCreate", actual: "\(source)"))
            }
        }
        // Decoder for [RoleCreateFull]
        Decoders.addDecoder(clazz: [RoleCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RoleCreateFull]> in
            return Decoders.decode(clazz: [RoleCreateFull].self, source: source)
        }

        // Decoder for RoleCreateFull
        Decoders.addDecoder(clazz: RoleCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RoleCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "RoleCreateFull", actual: "\(nameSource)"))
                }
                let _result = RoleCreateFull(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PrivilegeCreate].self, source: sourceDictionary["privileges"] as AnyObject?) {
                case let .success(value): _result.privileges = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [RoleCreate].self, source: sourceDictionary["inheritedRoles"] as AnyObject?) {
                case let .success(value): _result.inheritedRoles = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RoleCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [RoleGet]
        Decoders.addDecoder(clazz: [RoleGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RoleGet]> in
            return Decoders.decode(clazz: [RoleGet].self, source: source)
        }

        // Decoder for RoleGet
        Decoders.addDecoder(clazz: RoleGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RoleGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = RoleGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PrivilegeGetRef].self, source: sourceDictionary["privileges"] as AnyObject?) {
                case let .success(value): _result.privileges = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [RoleGetRef].self, source: sourceDictionary["inheritedRoles"] as AnyObject?) {
                case let .success(value): _result.inheritedRoles = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RoleGet", actual: "\(source)"))
            }
        }
        // Decoder for [RoleGetFull]
        Decoders.addDecoder(clazz: [RoleGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RoleGetFull]> in
            return Decoders.decode(clazz: [RoleGetFull].self, source: source)
        }

        // Decoder for RoleGetFull
        Decoders.addDecoder(clazz: RoleGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RoleGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = RoleGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PrivilegeGet].self, source: sourceDictionary["privileges"] as AnyObject?) {
                case let .success(value): _result.privileges = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [RoleGet].self, source: sourceDictionary["inheritedRoles"] as AnyObject?) {
                case let .success(value): _result.inheritedRoles = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [RoleGet].self, source: sourceDictionary["allInheritedRoles"] as AnyObject?) {
                case let .success(value): _result.allInheritedRoles = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RoleGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [RoleGetRef]
        Decoders.addDecoder(clazz: [RoleGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RoleGetRef]> in
            return Decoders.decode(clazz: [RoleGetRef].self, source: source)
        }

        // Decoder for RoleGetRef
        Decoders.addDecoder(clazz: RoleGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RoleGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = RoleGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RoleGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [RoleUpdate]
        Decoders.addDecoder(clazz: [RoleUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RoleUpdate]> in
            return Decoders.decode(clazz: [RoleUpdate].self, source: source)
        }

        // Decoder for RoleUpdate
        Decoders.addDecoder(clazz: RoleUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RoleUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = RoleUpdate()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PrivilegeCreate].self, source: sourceDictionary["privileges"] as AnyObject?) {
                case let .success(value): _result.privileges = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [RoleCreate].self, source: sourceDictionary["inheritedRoles"] as AnyObject?) {
                case let .success(value): _result.inheritedRoles = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RoleUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ServerlogGet]
        Decoders.addDecoder(clazz: [ServerlogGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ServerlogGet]> in
            return Decoders.decode(clazz: [ServerlogGet].self, source: source)
        }

        // Decoder for ServerlogGet
        Decoders.addDecoder(clazz: ServerlogGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ServerlogGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ServerlogGet()
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["serverLog"] as AnyObject?) {
                case let .success(value): _result.serverLog = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ServerlogGet", actual: "\(source)"))
            }
        }
        // Decoder for [ServerlogGetFull]
        Decoders.addDecoder(clazz: [ServerlogGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ServerlogGetFull]> in
            return Decoders.decode(clazz: [ServerlogGetFull].self, source: source)
        }

        // Decoder for ServerlogGetFull
        Decoders.addDecoder(clazz: ServerlogGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ServerlogGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ServerlogGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["serverLog"] as AnyObject?) {
                case let .success(value): _result.serverLog = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ServerlogGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ServerlogGetRef]
        Decoders.addDecoder(clazz: [ServerlogGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ServerlogGetRef]> in
            return Decoders.decode(clazz: [ServerlogGetRef].self, source: source)
        }

        // Decoder for ServerlogGetRef
        Decoders.addDecoder(clazz: ServerlogGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ServerlogGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = ServerlogGetRef()
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["serverLog"] as AnyObject?) {
                case let .success(value): _result.serverLog = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ServerlogGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [SystemsettingCreate]
        Decoders.addDecoder(clazz: [SystemsettingCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[SystemsettingCreate]> in
            return Decoders.decode(clazz: [SystemsettingCreate].self, source: source)
        }

        // Decoder for SystemsettingCreate
        Decoders.addDecoder(clazz: SystemsettingCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SystemsettingCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let propertySource = sourceDictionary["property"] as AnyObject? else {
                    return .failure(.missingKey(key: "property"))
                }
                guard let property = Decoders.decode(clazz: String.self.self, source: propertySource).value else {
                    return .failure(.typeMismatch(expected: "SystemsettingCreate", actual: "\(propertySource)"))
                }
                let _result = SystemsettingCreate(property: property)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "SystemsettingCreate", actual: "\(source)"))
            }
        }
        // Decoder for [SystemsettingCreateFull]
        Decoders.addDecoder(clazz: [SystemsettingCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[SystemsettingCreateFull]> in
            return Decoders.decode(clazz: [SystemsettingCreateFull].self, source: source)
        }

        // Decoder for SystemsettingCreateFull
        Decoders.addDecoder(clazz: SystemsettingCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SystemsettingCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let propertySource = sourceDictionary["property"] as AnyObject? else {
                    return .failure(.missingKey(key: "property"))
                }
                guard let property = Decoders.decode(clazz: String.self.self, source: propertySource).value else {
                    return .failure(.typeMismatch(expected: "SystemsettingCreateFull", actual: "\(propertySource)"))
                }
                let _result = SystemsettingCreateFull(property: property)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "SystemsettingCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [SystemsettingGet]
        Decoders.addDecoder(clazz: [SystemsettingGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[SystemsettingGet]> in
            return Decoders.decode(clazz: [SystemsettingGet].self, source: source)
        }

        // Decoder for SystemsettingGet
        Decoders.addDecoder(clazz: SystemsettingGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SystemsettingGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = SystemsettingGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["property"] as AnyObject?) {
                case let .success(value): _result.property = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "SystemsettingGet", actual: "\(source)"))
            }
        }
        // Decoder for [SystemsettingGetFull]
        Decoders.addDecoder(clazz: [SystemsettingGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[SystemsettingGetFull]> in
            return Decoders.decode(clazz: [SystemsettingGetFull].self, source: source)
        }

        // Decoder for SystemsettingGetFull
        Decoders.addDecoder(clazz: SystemsettingGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SystemsettingGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = SystemsettingGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["property"] as AnyObject?) {
                case let .success(value): _result.property = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "SystemsettingGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [SystemsettingGetRef]
        Decoders.addDecoder(clazz: [SystemsettingGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[SystemsettingGetRef]> in
            return Decoders.decode(clazz: [SystemsettingGetRef].self, source: source)
        }

        // Decoder for SystemsettingGetRef
        Decoders.addDecoder(clazz: SystemsettingGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SystemsettingGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = SystemsettingGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "SystemsettingGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [SystemsettingUpdate]
        Decoders.addDecoder(clazz: [SystemsettingUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[SystemsettingUpdate]> in
            return Decoders.decode(clazz: [SystemsettingUpdate].self, source: source)
        }

        // Decoder for SystemsettingUpdate
        Decoders.addDecoder(clazz: SystemsettingUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SystemsettingUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = SystemsettingUpdate()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "SystemsettingUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [TaskactionCreate]
        Decoders.addDecoder(clazz: [TaskactionCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaskactionCreate]> in
            return Decoders.decode(clazz: [TaskactionCreate].self, source: source)
        }

        // Decoder for TaskactionCreate
        Decoders.addDecoder(clazz: TaskactionCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaskactionCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let actionSource = sourceDictionary["action"] as AnyObject? else {
                    return .failure(.missingKey(key: "action"))
                }
                guard let action = Decoders.decode(clazz: TaskactionCreate.Action.self.self, source: actionSource).value else {
                    return .failure(.typeMismatch(expected: "TaskactionCreate", actual: "\(actionSource)"))
                }
                let _result = TaskactionCreate(action: action)
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["tasks"] as AnyObject?) {
                case let .success(value): _result.tasks = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["allTasks"] as AnyObject?) {
                case let .success(value): _result.allTasks = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaskactionCreate", actual: "\(source)"))
            }
        }
        // Decoder for [TaskactionCreateFull]
        Decoders.addDecoder(clazz: [TaskactionCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaskactionCreateFull]> in
            return Decoders.decode(clazz: [TaskactionCreateFull].self, source: source)
        }

        // Decoder for TaskactionCreateFull
        Decoders.addDecoder(clazz: TaskactionCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaskactionCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let actionSource = sourceDictionary["action"] as AnyObject? else {
                    return .failure(.missingKey(key: "action"))
                }
                guard let action = Decoders.decode(clazz: TaskactionCreateFull.Action.self.self, source: actionSource).value else {
                    return .failure(.typeMismatch(expected: "TaskactionCreateFull", actual: "\(actionSource)"))
                }
                let _result = TaskactionCreateFull(action: action)
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["tasks"] as AnyObject?) {
                case let .success(value): _result.tasks = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["allTasks"] as AnyObject?) {
                case let .success(value): _result.allTasks = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaskactionCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [TaskactionGet]
        Decoders.addDecoder(clazz: [TaskactionGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaskactionGet]> in
            return Decoders.decode(clazz: [TaskactionGet].self, source: source)
        }

        // Decoder for TaskactionGet
        Decoders.addDecoder(clazz: TaskactionGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaskactionGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = TaskactionGet()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaskactionGet", actual: "\(source)"))
            }
        }
        // Decoder for [TaskactionGetFull]
        Decoders.addDecoder(clazz: [TaskactionGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaskactionGetFull]> in
            return Decoders.decode(clazz: [TaskactionGetFull].self, source: source)
        }

        // Decoder for TaskactionGetFull
        Decoders.addDecoder(clazz: TaskactionGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaskactionGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = TaskactionGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaskactionGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [TaskactionGetRef]
        Decoders.addDecoder(clazz: [TaskactionGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaskactionGetRef]> in
            return Decoders.decode(clazz: [TaskactionGetRef].self, source: source)
        }

        // Decoder for TaskactionGetRef
        Decoders.addDecoder(clazz: TaskactionGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaskactionGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = TaskactionGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaskactionGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [TaskdefinitionCreate]
        Decoders.addDecoder(clazz: [TaskdefinitionCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaskdefinitionCreate]> in
            return Decoders.decode(clazz: [TaskdefinitionCreate].self, source: source)
        }

        // Decoder for TaskdefinitionCreate
        Decoders.addDecoder(clazz: TaskdefinitionCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaskdefinitionCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "TaskdefinitionCreate", actual: "\(nameSource)"))
                }
                let _result = TaskdefinitionCreate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaskdefinitionCreate", actual: "\(source)"))
            }
        }
        // Decoder for [TaskdefinitionCreateFull]
        Decoders.addDecoder(clazz: [TaskdefinitionCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaskdefinitionCreateFull]> in
            return Decoders.decode(clazz: [TaskdefinitionCreateFull].self, source: source)
        }

        // Decoder for TaskdefinitionCreateFull
        Decoders.addDecoder(clazz: TaskdefinitionCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaskdefinitionCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "TaskdefinitionCreateFull", actual: "\(nameSource)"))
                }
                let _result = TaskdefinitionCreateFull(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaskdefinitionCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [TaskdefinitionGet]
        Decoders.addDecoder(clazz: [TaskdefinitionGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaskdefinitionGet]> in
            return Decoders.decode(clazz: [TaskdefinitionGet].self, source: source)
        }

        // Decoder for TaskdefinitionGet
        Decoders.addDecoder(clazz: TaskdefinitionGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaskdefinitionGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = TaskdefinitionGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaskdefinitionGet", actual: "\(source)"))
            }
        }
        // Decoder for [TaskdefinitionGetFull]
        Decoders.addDecoder(clazz: [TaskdefinitionGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaskdefinitionGetFull]> in
            return Decoders.decode(clazz: [TaskdefinitionGetFull].self, source: source)
        }

        // Decoder for TaskdefinitionGetFull
        Decoders.addDecoder(clazz: TaskdefinitionGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaskdefinitionGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = TaskdefinitionGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaskdefinitionGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [TaskdefinitionGetRef]
        Decoders.addDecoder(clazz: [TaskdefinitionGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaskdefinitionGetRef]> in
            return Decoders.decode(clazz: [TaskdefinitionGetRef].self, source: source)
        }

        // Decoder for TaskdefinitionGetRef
        Decoders.addDecoder(clazz: TaskdefinitionGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaskdefinitionGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = TaskdefinitionGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaskdefinitionGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [TaskdefinitionUpdate]
        Decoders.addDecoder(clazz: [TaskdefinitionUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaskdefinitionUpdate]> in
            return Decoders.decode(clazz: [TaskdefinitionUpdate].self, source: source)
        }

        // Decoder for TaskdefinitionUpdate
        Decoders.addDecoder(clazz: TaskdefinitionUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaskdefinitionUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "TaskdefinitionUpdate", actual: "\(nameSource)"))
                }
                let _result = TaskdefinitionUpdate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaskdefinitionUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [UserCreate]
        Decoders.addDecoder(clazz: [UserCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UserCreate]> in
            return Decoders.decode(clazz: [UserCreate].self, source: source)
        }

        // Decoder for UserCreate
        Decoders.addDecoder(clazz: UserCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "UserCreate", actual: "\(nameSource)"))
                }
                guard let usernameSource = sourceDictionary["username"] as AnyObject? else {
                    return .failure(.missingKey(key: "username"))
                }
                guard let username = Decoders.decode(clazz: String.self.self, source: usernameSource).value else {
                    return .failure(.typeMismatch(expected: "UserCreate", actual: "\(usernameSource)"))
                }
                guard let passwordSource = sourceDictionary["password"] as AnyObject? else {
                    return .failure(.missingKey(key: "password"))
                }
                guard let password = Decoders.decode(clazz: String.self.self, source: passwordSource).value else {
                    return .failure(.typeMismatch(expected: "UserCreate", actual: "\(passwordSource)"))
                }
                guard let personSource = sourceDictionary["person"] as AnyObject? else {
                    return .failure(.missingKey(key: "person"))
                }
                guard let person = Decoders.decode(clazz: PersonCreate.self.self, source: personSource).value else {
                    return .failure(.typeMismatch(expected: "UserCreate", actual: "\(personSource)"))
                }
                let _result = UserCreate(name: name, username: username, password: password, person: person)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["systemId"] as AnyObject?) {
                case let .success(value): _result.systemId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["userProperties"] as AnyObject?) {
                case let .success(value): _result.userProperties = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [RoleCreate].self, source: sourceDictionary["roles"] as AnyObject?) {
                case let .success(value): _result.roles = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Any].self, source: sourceDictionary["proficientLocales"] as AnyObject?) {
                case let .success(value): _result.proficientLocales = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["secretQuestion"] as AnyObject?) {
                case let .success(value): _result.secretQuestion = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UserCreate", actual: "\(source)"))
            }
        }
        // Decoder for [UserCreateFull]
        Decoders.addDecoder(clazz: [UserCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UserCreateFull]> in
            return Decoders.decode(clazz: [UserCreateFull].self, source: source)
        }

        // Decoder for UserCreateFull
        Decoders.addDecoder(clazz: UserCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "UserCreateFull", actual: "\(nameSource)"))
                }
                guard let usernameSource = sourceDictionary["username"] as AnyObject? else {
                    return .failure(.missingKey(key: "username"))
                }
                guard let username = Decoders.decode(clazz: String.self.self, source: usernameSource).value else {
                    return .failure(.typeMismatch(expected: "UserCreateFull", actual: "\(usernameSource)"))
                }
                guard let passwordSource = sourceDictionary["password"] as AnyObject? else {
                    return .failure(.missingKey(key: "password"))
                }
                guard let password = Decoders.decode(clazz: String.self.self, source: passwordSource).value else {
                    return .failure(.typeMismatch(expected: "UserCreateFull", actual: "\(passwordSource)"))
                }
                guard let personSource = sourceDictionary["person"] as AnyObject? else {
                    return .failure(.missingKey(key: "person"))
                }
                guard let person = Decoders.decode(clazz: PersonCreate.self.self, source: personSource).value else {
                    return .failure(.typeMismatch(expected: "UserCreateFull", actual: "\(personSource)"))
                }
                let _result = UserCreateFull(name: name, username: username, password: password, person: person)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["systemId"] as AnyObject?) {
                case let .success(value): _result.systemId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["userProperties"] as AnyObject?) {
                case let .success(value): _result.userProperties = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [RoleCreate].self, source: sourceDictionary["roles"] as AnyObject?) {
                case let .success(value): _result.roles = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Any].self, source: sourceDictionary["proficientLocales"] as AnyObject?) {
                case let .success(value): _result.proficientLocales = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["secretQuestion"] as AnyObject?) {
                case let .success(value): _result.secretQuestion = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UserCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [UserGet]
        Decoders.addDecoder(clazz: [UserGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UserGet]> in
            return Decoders.decode(clazz: [UserGet].self, source: source)
        }

        // Decoder for UserGet
        Decoders.addDecoder(clazz: UserGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = UserGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["username"] as AnyObject?) {
                case let .success(value): _result.username = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["systemId"] as AnyObject?) {
                case let .success(value): _result.systemId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["userProperties"] as AnyObject?) {
                case let .success(value): _result.userProperties = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonGetRef.self, source: sourceDictionary["person"] as AnyObject?) {
                case let .success(value): _result.person = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PrivilegeGetRef].self, source: sourceDictionary["privileges"] as AnyObject?) {
                case let .success(value): _result.privileges = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [RoleGetRef].self, source: sourceDictionary["roles"] as AnyObject?) {
                case let .success(value): _result.roles = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UserGet", actual: "\(source)"))
            }
        }
        // Decoder for [UserGetFull]
        Decoders.addDecoder(clazz: [UserGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UserGetFull]> in
            return Decoders.decode(clazz: [UserGetFull].self, source: source)
        }

        // Decoder for UserGetFull
        Decoders.addDecoder(clazz: UserGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = UserGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["username"] as AnyObject?) {
                case let .success(value): _result.username = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["systemId"] as AnyObject?) {
                case let .success(value): _result.systemId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["userProperties"] as AnyObject?) {
                case let .success(value): _result.userProperties = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonGet.self, source: sourceDictionary["person"] as AnyObject?) {
                case let .success(value): _result.person = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PrivilegeGet].self, source: sourceDictionary["privileges"] as AnyObject?) {
                case let .success(value): _result.privileges = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [RoleGet].self, source: sourceDictionary["roles"] as AnyObject?) {
                case let .success(value): _result.roles = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [RoleGet].self, source: sourceDictionary["allRoles"] as AnyObject?) {
                case let .success(value): _result.allRoles = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Any].self, source: sourceDictionary["proficientLocales"] as AnyObject?) {
                case let .success(value): _result.proficientLocales = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["secretQuestion"] as AnyObject?) {
                case let .success(value): _result.secretQuestion = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UserGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [UserGetRef]
        Decoders.addDecoder(clazz: [UserGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UserGetRef]> in
            return Decoders.decode(clazz: [UserGetRef].self, source: source)
        }

        // Decoder for UserGetRef
        Decoders.addDecoder(clazz: UserGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = UserGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UserGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [UserUpdate]
        Decoders.addDecoder(clazz: [UserUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UserUpdate]> in
            return Decoders.decode(clazz: [UserUpdate].self, source: source)
        }

        // Decoder for UserUpdate
        Decoders.addDecoder(clazz: UserUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "UserUpdate", actual: "\(nameSource)"))
                }
                guard let usernameSource = sourceDictionary["username"] as AnyObject? else {
                    return .failure(.missingKey(key: "username"))
                }
                guard let username = Decoders.decode(clazz: String.self.self, source: usernameSource).value else {
                    return .failure(.typeMismatch(expected: "UserUpdate", actual: "\(usernameSource)"))
                }
                guard let passwordSource = sourceDictionary["password"] as AnyObject? else {
                    return .failure(.missingKey(key: "password"))
                }
                guard let password = Decoders.decode(clazz: String.self.self, source: passwordSource).value else {
                    return .failure(.typeMismatch(expected: "UserUpdate", actual: "\(passwordSource)"))
                }
                guard let personSource = sourceDictionary["person"] as AnyObject? else {
                    return .failure(.missingKey(key: "person"))
                }
                guard let person = Decoders.decode(clazz: PersonCreate.self.self, source: personSource).value else {
                    return .failure(.typeMismatch(expected: "UserUpdate", actual: "\(personSource)"))
                }
                let _result = UserUpdate(name: name, username: username, password: password, person: person)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["systemId"] as AnyObject?) {
                case let .success(value): _result.systemId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["userProperties"] as AnyObject?) {
                case let .success(value): _result.userProperties = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [RoleCreate].self, source: sourceDictionary["roles"] as AnyObject?) {
                case let .success(value): _result.roles = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Any].self, source: sourceDictionary["proficientLocales"] as AnyObject?) {
                case let .success(value): _result.proficientLocales = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["secretQuestion"] as AnyObject?) {
                case let .success(value): _result.secretQuestion = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UserUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [VisitAttributeCreate]
        Decoders.addDecoder(clazz: [VisitAttributeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitAttributeCreate]> in
            return Decoders.decode(clazz: [VisitAttributeCreate].self, source: source)
        }

        // Decoder for VisitAttributeCreate
        Decoders.addDecoder(clazz: VisitAttributeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitAttributeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let attributeTypeSource = sourceDictionary["attributeType"] as AnyObject? else {
                    return .failure(.missingKey(key: "attributeType"))
                }
                guard let attributeType = Decoders.decode(clazz: String.self.self, source: attributeTypeSource).value else {
                    return .failure(.typeMismatch(expected: "VisitAttributeCreate", actual: "\(attributeTypeSource)"))
                }
                guard let valueSource = sourceDictionary["value"] as AnyObject? else {
                    return .failure(.missingKey(key: "value"))
                }
                guard let value = Decoders.decode(clazz: String.self.self, source: valueSource).value else {
                    return .failure(.typeMismatch(expected: "VisitAttributeCreate", actual: "\(valueSource)"))
                }
                let _result = VisitAttributeCreate(attributeType: attributeType, value: value)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitAttributeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [VisitAttributeCreateFull]
        Decoders.addDecoder(clazz: [VisitAttributeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitAttributeCreateFull]> in
            return Decoders.decode(clazz: [VisitAttributeCreateFull].self, source: source)
        }

        // Decoder for VisitAttributeCreateFull
        Decoders.addDecoder(clazz: VisitAttributeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitAttributeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let attributeTypeSource = sourceDictionary["attributeType"] as AnyObject? else {
                    return .failure(.missingKey(key: "attributeType"))
                }
                guard let attributeType = Decoders.decode(clazz: String.self.self, source: attributeTypeSource).value else {
                    return .failure(.typeMismatch(expected: "VisitAttributeCreateFull", actual: "\(attributeTypeSource)"))
                }
                guard let valueSource = sourceDictionary["value"] as AnyObject? else {
                    return .failure(.missingKey(key: "value"))
                }
                guard let value = Decoders.decode(clazz: String.self.self, source: valueSource).value else {
                    return .failure(.typeMismatch(expected: "VisitAttributeCreateFull", actual: "\(valueSource)"))
                }
                let _result = VisitAttributeCreateFull(attributeType: attributeType, value: value)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitAttributeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [VisitAttributeGet]
        Decoders.addDecoder(clazz: [VisitAttributeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitAttributeGet]> in
            return Decoders.decode(clazz: [VisitAttributeGet].self, source: source)
        }

        // Decoder for VisitAttributeGet
        Decoders.addDecoder(clazz: VisitAttributeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitAttributeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = VisitAttributeGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitAttributeGet", actual: "\(source)"))
            }
        }
        // Decoder for [VisitAttributeGetFull]
        Decoders.addDecoder(clazz: [VisitAttributeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitAttributeGetFull]> in
            return Decoders.decode(clazz: [VisitAttributeGetFull].self, source: source)
        }

        // Decoder for VisitAttributeGetFull
        Decoders.addDecoder(clazz: VisitAttributeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitAttributeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = VisitAttributeGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitAttributeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [VisitAttributeGetRef]
        Decoders.addDecoder(clazz: [VisitAttributeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitAttributeGetRef]> in
            return Decoders.decode(clazz: [VisitAttributeGetRef].self, source: source)
        }

        // Decoder for VisitAttributeGetRef
        Decoders.addDecoder(clazz: VisitAttributeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitAttributeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = VisitAttributeGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitAttributeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [VisitAttributeUpdate]
        Decoders.addDecoder(clazz: [VisitAttributeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitAttributeUpdate]> in
            return Decoders.decode(clazz: [VisitAttributeUpdate].self, source: source)
        }

        // Decoder for VisitAttributeUpdate
        Decoders.addDecoder(clazz: VisitAttributeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitAttributeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let attributeTypeSource = sourceDictionary["attributeType"] as AnyObject? else {
                    return .failure(.missingKey(key: "attributeType"))
                }
                guard let attributeType = Decoders.decode(clazz: String.self.self, source: attributeTypeSource).value else {
                    return .failure(.typeMismatch(expected: "VisitAttributeUpdate", actual: "\(attributeTypeSource)"))
                }
                guard let valueSource = sourceDictionary["value"] as AnyObject? else {
                    return .failure(.missingKey(key: "value"))
                }
                guard let value = Decoders.decode(clazz: String.self.self, source: valueSource).value else {
                    return .failure(.typeMismatch(expected: "VisitAttributeUpdate", actual: "\(valueSource)"))
                }
                let _result = VisitAttributeUpdate(attributeType: attributeType, value: value)
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitAttributeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [VisitCreate]
        Decoders.addDecoder(clazz: [VisitCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitCreate]> in
            return Decoders.decode(clazz: [VisitCreate].self, source: source)
        }

        // Decoder for VisitCreate
        Decoders.addDecoder(clazz: VisitCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let patientSource = sourceDictionary["patient"] as AnyObject? else {
                    return .failure(.missingKey(key: "patient"))
                }
                guard let patient = Decoders.decode(clazz: String.self.self, source: patientSource).value else {
                    return .failure(.typeMismatch(expected: "VisitCreate", actual: "\(patientSource)"))
                }
                guard let visitTypeSource = sourceDictionary["visitType"] as AnyObject? else {
                    return .failure(.missingKey(key: "visitType"))
                }
                guard let visitType = Decoders.decode(clazz: String.self.self, source: visitTypeSource).value else {
                    return .failure(.typeMismatch(expected: "VisitCreate", actual: "\(visitTypeSource)"))
                }
                let _result = VisitCreate(patient: patient, visitType: visitType)
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDatetime"] as AnyObject?) {
                case let .success(value): _result.startDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["indication"] as AnyObject?) {
                case let .success(value): _result.indication = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["stopDatetime"] as AnyObject?) {
                case let .success(value): _result.stopDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["encounters"] as AnyObject?) {
                case let .success(value): _result.encounters = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [VisitAttributeCreate].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitCreate", actual: "\(source)"))
            }
        }
        // Decoder for [VisitCreateFull]
        Decoders.addDecoder(clazz: [VisitCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitCreateFull]> in
            return Decoders.decode(clazz: [VisitCreateFull].self, source: source)
        }

        // Decoder for VisitCreateFull
        Decoders.addDecoder(clazz: VisitCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let patientSource = sourceDictionary["patient"] as AnyObject? else {
                    return .failure(.missingKey(key: "patient"))
                }
                guard let patient = Decoders.decode(clazz: PatientCreate.self.self, source: patientSource).value else {
                    return .failure(.typeMismatch(expected: "VisitCreateFull", actual: "\(patientSource)"))
                }
                guard let visitTypeSource = sourceDictionary["visitType"] as AnyObject? else {
                    return .failure(.missingKey(key: "visitType"))
                }
                guard let visitType = Decoders.decode(clazz: VisittypeCreate.self.self, source: visitTypeSource).value else {
                    return .failure(.typeMismatch(expected: "VisitCreateFull", actual: "\(visitTypeSource)"))
                }
                let _result = VisitCreateFull(patient: patient, visitType: visitType)
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDatetime"] as AnyObject?) {
                case let .success(value): _result.startDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationCreate.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptCreate.self, source: sourceDictionary["indication"] as AnyObject?) {
                case let .success(value): _result.indication = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["stopDatetime"] as AnyObject?) {
                case let .success(value): _result.stopDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [EncounterCreate].self, source: sourceDictionary["encounters"] as AnyObject?) {
                case let .success(value): _result.encounters = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [VisitAttributeCreate].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [VisitGet]
        Decoders.addDecoder(clazz: [VisitGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitGet]> in
            return Decoders.decode(clazz: [VisitGet].self, source: source)
        }

        // Decoder for VisitGet
        Decoders.addDecoder(clazz: VisitGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = VisitGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDatetime"] as AnyObject?) {
                case let .success(value): _result.startDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["stopDatetime"] as AnyObject?) {
                case let .success(value): _result.stopDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientGetRef.self, source: sourceDictionary["patient"] as AnyObject?) {
                case let .success(value): _result.patient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: VisittypeGetRef.self, source: sourceDictionary["visitType"] as AnyObject?) {
                case let .success(value): _result.visitType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["indication"] as AnyObject?) {
                case let .success(value): _result.indication = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationGetRef.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [EncounterGetRef].self, source: sourceDictionary["encounters"] as AnyObject?) {
                case let .success(value): _result.encounters = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitGet", actual: "\(source)"))
            }
        }
        // Decoder for [VisitGetFull]
        Decoders.addDecoder(clazz: [VisitGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitGetFull]> in
            return Decoders.decode(clazz: [VisitGetFull].self, source: source)
        }

        // Decoder for VisitGetFull
        Decoders.addDecoder(clazz: VisitGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = VisitGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDatetime"] as AnyObject?) {
                case let .success(value): _result.startDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["stopDatetime"] as AnyObject?) {
                case let .success(value): _result.stopDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientGet.self, source: sourceDictionary["patient"] as AnyObject?) {
                case let .success(value): _result.patient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: VisittypeGet.self, source: sourceDictionary["visitType"] as AnyObject?) {
                case let .success(value): _result.visitType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["indication"] as AnyObject?) {
                case let .success(value): _result.indication = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationGet.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [EncounterGet].self, source: sourceDictionary["encounters"] as AnyObject?) {
                case let .success(value): _result.encounters = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [VisitGetRef]
        Decoders.addDecoder(clazz: [VisitGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitGetRef]> in
            return Decoders.decode(clazz: [VisitGetRef].self, source: source)
        }

        // Decoder for VisitGetRef
        Decoders.addDecoder(clazz: VisitGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = VisitGetRef()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [VisitUpdate]
        Decoders.addDecoder(clazz: [VisitUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitUpdate]> in
            return Decoders.decode(clazz: [VisitUpdate].self, source: source)
        }

        // Decoder for VisitUpdate
        Decoders.addDecoder(clazz: VisitUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = VisitUpdate()
                switch Decoders.decodeOptional(clazz: VisittypeCreate.self, source: sourceDictionary["visitType"] as AnyObject?) {
                case let .success(value): _result.visitType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDatetime"] as AnyObject?) {
                case let .success(value): _result.startDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationCreate.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptCreate.self, source: sourceDictionary["indication"] as AnyObject?) {
                case let .success(value): _result.indication = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["stopDatetime"] as AnyObject?) {
                case let .success(value): _result.stopDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [EncounterCreate].self, source: sourceDictionary["encounters"] as AnyObject?) {
                case let .success(value): _result.encounters = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [VisitattributetypeCreate]
        Decoders.addDecoder(clazz: [VisitattributetypeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitattributetypeCreate]> in
            return Decoders.decode(clazz: [VisitattributetypeCreate].self, source: source)
        }

        // Decoder for VisitattributetypeCreate
        Decoders.addDecoder(clazz: VisitattributetypeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitattributetypeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "VisitattributetypeCreate", actual: "\(nameSource)"))
                }
                guard let datatypeClassnameSource = sourceDictionary["datatypeClassname"] as AnyObject? else {
                    return .failure(.missingKey(key: "datatypeClassname"))
                }
                guard let datatypeClassname = Decoders.decode(clazz: String.self.self, source: datatypeClassnameSource).value else {
                    return .failure(.typeMismatch(expected: "VisitattributetypeCreate", actual: "\(datatypeClassnameSource)"))
                }
                let _result = VisitattributetypeCreate(name: name, datatypeClassname: datatypeClassname)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitattributetypeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [VisitattributetypeCreateFull]
        Decoders.addDecoder(clazz: [VisitattributetypeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitattributetypeCreateFull]> in
            return Decoders.decode(clazz: [VisitattributetypeCreateFull].self, source: source)
        }

        // Decoder for VisitattributetypeCreateFull
        Decoders.addDecoder(clazz: VisitattributetypeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitattributetypeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "VisitattributetypeCreateFull", actual: "\(nameSource)"))
                }
                guard let datatypeClassnameSource = sourceDictionary["datatypeClassname"] as AnyObject? else {
                    return .failure(.missingKey(key: "datatypeClassname"))
                }
                guard let datatypeClassname = Decoders.decode(clazz: String.self.self, source: datatypeClassnameSource).value else {
                    return .failure(.typeMismatch(expected: "VisitattributetypeCreateFull", actual: "\(datatypeClassnameSource)"))
                }
                let _result = VisitattributetypeCreateFull(name: name, datatypeClassname: datatypeClassname)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitattributetypeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [VisitattributetypeGet]
        Decoders.addDecoder(clazz: [VisitattributetypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitattributetypeGet]> in
            return Decoders.decode(clazz: [VisitattributetypeGet].self, source: source)
        }

        // Decoder for VisitattributetypeGet
        Decoders.addDecoder(clazz: VisitattributetypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitattributetypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = VisitattributetypeGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitattributetypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [VisitattributetypeGetFull]
        Decoders.addDecoder(clazz: [VisitattributetypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitattributetypeGetFull]> in
            return Decoders.decode(clazz: [VisitattributetypeGetFull].self, source: source)
        }

        // Decoder for VisitattributetypeGetFull
        Decoders.addDecoder(clazz: VisitattributetypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitattributetypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = VisitattributetypeGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitattributetypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [VisitattributetypeGetRef]
        Decoders.addDecoder(clazz: [VisitattributetypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitattributetypeGetRef]> in
            return Decoders.decode(clazz: [VisitattributetypeGetRef].self, source: source)
        }

        // Decoder for VisitattributetypeGetRef
        Decoders.addDecoder(clazz: VisitattributetypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitattributetypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = VisitattributetypeGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitattributetypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [VisitattributetypeUpdate]
        Decoders.addDecoder(clazz: [VisitattributetypeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitattributetypeUpdate]> in
            return Decoders.decode(clazz: [VisitattributetypeUpdate].self, source: source)
        }

        // Decoder for VisitattributetypeUpdate
        Decoders.addDecoder(clazz: VisitattributetypeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitattributetypeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "VisitattributetypeUpdate", actual: "\(nameSource)"))
                }
                guard let datatypeClassnameSource = sourceDictionary["datatypeClassname"] as AnyObject? else {
                    return .failure(.missingKey(key: "datatypeClassname"))
                }
                guard let datatypeClassname = Decoders.decode(clazz: String.self.self, source: datatypeClassnameSource).value else {
                    return .failure(.typeMismatch(expected: "VisitattributetypeUpdate", actual: "\(datatypeClassnameSource)"))
                }
                let _result = VisitattributetypeUpdate(name: name, datatypeClassname: datatypeClassname)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitattributetypeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [VisittypeCreate]
        Decoders.addDecoder(clazz: [VisittypeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisittypeCreate]> in
            return Decoders.decode(clazz: [VisittypeCreate].self, source: source)
        }

        // Decoder for VisittypeCreate
        Decoders.addDecoder(clazz: VisittypeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisittypeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "VisittypeCreate", actual: "\(nameSource)"))
                }
                let _result = VisittypeCreate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisittypeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [VisittypeCreateFull]
        Decoders.addDecoder(clazz: [VisittypeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisittypeCreateFull]> in
            return Decoders.decode(clazz: [VisittypeCreateFull].self, source: source)
        }

        // Decoder for VisittypeCreateFull
        Decoders.addDecoder(clazz: VisittypeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisittypeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "VisittypeCreateFull", actual: "\(nameSource)"))
                }
                let _result = VisittypeCreateFull(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisittypeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [VisittypeGet]
        Decoders.addDecoder(clazz: [VisittypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisittypeGet]> in
            return Decoders.decode(clazz: [VisittypeGet].self, source: source)
        }

        // Decoder for VisittypeGet
        Decoders.addDecoder(clazz: VisittypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisittypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = VisittypeGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisittypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [VisittypeGetFull]
        Decoders.addDecoder(clazz: [VisittypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisittypeGetFull]> in
            return Decoders.decode(clazz: [VisittypeGetFull].self, source: source)
        }

        // Decoder for VisittypeGetFull
        Decoders.addDecoder(clazz: VisittypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisittypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = VisittypeGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisittypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [VisittypeGetRef]
        Decoders.addDecoder(clazz: [VisittypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisittypeGetRef]> in
            return Decoders.decode(clazz: [VisittypeGetRef].self, source: source)
        }

        // Decoder for VisittypeGetRef
        Decoders.addDecoder(clazz: VisittypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisittypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = VisittypeGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisittypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [VisittypeUpdate]
        Decoders.addDecoder(clazz: [VisittypeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisittypeUpdate]> in
            return Decoders.decode(clazz: [VisittypeUpdate].self, source: source)
        }

        // Decoder for VisittypeUpdate
        Decoders.addDecoder(clazz: VisittypeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisittypeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "VisittypeUpdate", actual: "\(nameSource)"))
                }
                let _result = VisittypeUpdate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisittypeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [WorkflowCreate]
        Decoders.addDecoder(clazz: [WorkflowCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[WorkflowCreate]> in
            return Decoders.decode(clazz: [WorkflowCreate].self, source: source)
        }

        // Decoder for WorkflowCreate
        Decoders.addDecoder(clazz: WorkflowCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<WorkflowCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "WorkflowCreate", actual: "\(nameSource)"))
                }
                let _result = WorkflowCreate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "WorkflowCreate", actual: "\(source)"))
            }
        }
        // Decoder for [WorkflowCreateFull]
        Decoders.addDecoder(clazz: [WorkflowCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[WorkflowCreateFull]> in
            return Decoders.decode(clazz: [WorkflowCreateFull].self, source: source)
        }

        // Decoder for WorkflowCreateFull
        Decoders.addDecoder(clazz: WorkflowCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<WorkflowCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "WorkflowCreateFull", actual: "\(nameSource)"))
                }
                let _result = WorkflowCreateFull(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "WorkflowCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [WorkflowGet]
        Decoders.addDecoder(clazz: [WorkflowGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[WorkflowGet]> in
            return Decoders.decode(clazz: [WorkflowGet].self, source: source)
        }

        // Decoder for WorkflowGet
        Decoders.addDecoder(clazz: WorkflowGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<WorkflowGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = WorkflowGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [WorkflowStateGetRef].self, source: sourceDictionary["states"] as AnyObject?) {
                case let .success(value): _result.states = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "WorkflowGet", actual: "\(source)"))
            }
        }
        // Decoder for [WorkflowGetFull]
        Decoders.addDecoder(clazz: [WorkflowGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[WorkflowGetFull]> in
            return Decoders.decode(clazz: [WorkflowGetFull].self, source: source)
        }

        // Decoder for WorkflowGetFull
        Decoders.addDecoder(clazz: WorkflowGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<WorkflowGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = WorkflowGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [WorkflowStateGet].self, source: sourceDictionary["states"] as AnyObject?) {
                case let .success(value): _result.states = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "WorkflowGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [WorkflowGetRef]
        Decoders.addDecoder(clazz: [WorkflowGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[WorkflowGetRef]> in
            return Decoders.decode(clazz: [WorkflowGetRef].self, source: source)
        }

        // Decoder for WorkflowGetRef
        Decoders.addDecoder(clazz: WorkflowGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<WorkflowGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = WorkflowGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [WorkflowStateGet].self, source: sourceDictionary["states"] as AnyObject?) {
                case let .success(value): _result.states = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "WorkflowGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [WorkflowStateCreate]
        Decoders.addDecoder(clazz: [WorkflowStateCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[WorkflowStateCreate]> in
            return Decoders.decode(clazz: [WorkflowStateCreate].self, source: source)
        }

        // Decoder for WorkflowStateCreate
        Decoders.addDecoder(clazz: WorkflowStateCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<WorkflowStateCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = WorkflowStateCreate()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "WorkflowStateCreate", actual: "\(source)"))
            }
        }
        // Decoder for [WorkflowStateCreateFull]
        Decoders.addDecoder(clazz: [WorkflowStateCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[WorkflowStateCreateFull]> in
            return Decoders.decode(clazz: [WorkflowStateCreateFull].self, source: source)
        }

        // Decoder for WorkflowStateCreateFull
        Decoders.addDecoder(clazz: WorkflowStateCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<WorkflowStateCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = WorkflowStateCreateFull()
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "WorkflowStateCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [WorkflowStateGet]
        Decoders.addDecoder(clazz: [WorkflowStateGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[WorkflowStateGet]> in
            return Decoders.decode(clazz: [WorkflowStateGet].self, source: source)
        }

        // Decoder for WorkflowStateGet
        Decoders.addDecoder(clazz: WorkflowStateGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<WorkflowStateGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = WorkflowStateGet()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "WorkflowStateGet", actual: "\(source)"))
            }
        }
        // Decoder for [WorkflowStateGetFull]
        Decoders.addDecoder(clazz: [WorkflowStateGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[WorkflowStateGetFull]> in
            return Decoders.decode(clazz: [WorkflowStateGetFull].self, source: source)
        }

        // Decoder for WorkflowStateGetFull
        Decoders.addDecoder(clazz: WorkflowStateGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<WorkflowStateGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = WorkflowStateGetFull()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "WorkflowStateGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [WorkflowStateGetRef]
        Decoders.addDecoder(clazz: [WorkflowStateGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[WorkflowStateGetRef]> in
            return Decoders.decode(clazz: [WorkflowStateGetRef].self, source: source)
        }

        // Decoder for WorkflowStateGetRef
        Decoders.addDecoder(clazz: WorkflowStateGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<WorkflowStateGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = WorkflowStateGetRef()
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "WorkflowStateGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [WorkflowUpdate]
        Decoders.addDecoder(clazz: [WorkflowUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[WorkflowUpdate]> in
            return Decoders.decode(clazz: [WorkflowUpdate].self, source: source)
        }

        // Decoder for WorkflowUpdate
        Decoders.addDecoder(clazz: WorkflowUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<WorkflowUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                guard let nameSource = sourceDictionary["name"] as AnyObject? else {
                    return .failure(.missingKey(key: "name"))
                }
                guard let name = Decoders.decode(clazz: String.self.self, source: nameSource).value else {
                    return .failure(.typeMismatch(expected: "WorkflowUpdate", actual: "\(nameSource)"))
                }
                let _result = WorkflowUpdate(name: name)
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "WorkflowUpdate", actual: "\(source)"))
            }
        }
    }()

    static fileprivate func initialize() {
        _ = Decoders.__once
    }
}
