// Models.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation

protocol JSONEncodable {
    func encodeToJSON() -> Any
}

public enum ErrorResponse : Error {
    case HttpError(statusCode: Int, data: Data?, error: Error)
    case DecodeError(response: Data?, decodeError: DecodeError)
}

open class Response<T> {
    open let statusCode: Int
    open let header: [String: String]
    open let body: T?

    public init(statusCode: Int, header: [String: String], body: T?) {
        self.statusCode = statusCode
        self.header = header
        self.body = body
    }

    public convenience init(response: HTTPURLResponse, body: T?) {
        let rawHeader = response.allHeaderFields
        var header = [String:String]()
        for case let (key, value) as (String, String) in rawHeader {
            header[key] = value
        }
        self.init(statusCode: response.statusCode, header: header, body: body)
    }
}

public enum Decoded<ValueType> {
    case success(ValueType)
    case failure(DecodeError)
}

public extension Decoded {
    var value: ValueType? {
        switch self {
        case let .success(value):
            return value
        case .failure:
            return nil
        }
    }
}

public enum DecodeError {
    case typeMismatch(expected: String, actual: String)
    case missingKey(key: String)
    case parseError(message: String)
}

private var once = Int()
class Decoders {
    static fileprivate var decoders = Dictionary<String, ((AnyObject, AnyObject?) -> AnyObject)>()

    static func addDecoder<T>(clazz: T.Type, decoder: @escaping ((AnyObject, AnyObject?) -> Decoded<T>)) {
        let key = "\(T.self)"
        decoders[key] = { decoder($0, $1) as AnyObject }
    }

    static func decode<T>(clazz: T.Type, discriminator: String, source: AnyObject) -> Decoded<T> {
        let key = discriminator
        if let decoder = decoders[key], let value = decoder(source, nil) as? Decoded<T> {
            return value
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decode<T>(clazz: [T].Type, source: AnyObject) -> Decoded<[T]> {
        if let sourceArray = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in sourceArray {
                switch Decoders.decode(clazz: T.self, source: sourceValue, instance: nil) {
                case let .success(value):
                    values.append(value)
                case let .failure(error):
                    return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decode<T>(clazz: T.Type, source: AnyObject) -> Decoded<T> {
        switch Decoders.decode(clazz: T.self, source: source, instance: nil) {
    	    case let .success(value):
                return .success(value)
            case let .failure(error):
                return .failure(error)
        }
    }

    static open func decode<T: RawRepresentable>(clazz: T.Type, source: AnyObject) -> Decoded<T> {
        if let value = source as? T.RawValue {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "\(T.RawValue.self) matching a case from the enumeration \(T.self)", actual: String(describing: type(of: source))))
        }
    }

    static func decode<T, Key: Hashable>(clazz: [Key:T].Type, source: AnyObject) -> Decoded<[Key:T]> {
        if let sourceDictionary = source as? [Key: AnyObject] {
            var dictionary = [Key:T]()
            for (key, value) in sourceDictionary {
                switch Decoders.decode(clazz: T.self, source: value, instance: nil) {
                case let .success(value):
                    dictionary[key] = value
                case let .failure(error):
                    return .failure(error)
                }
            }
            return .success(dictionary)
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decodeOptional<T: RawRepresentable>(clazz: T.Type, source: AnyObject?) -> Decoded<T?> {
        guard !(source is NSNull), source != nil else { return .success(nil) }
        if let value = source as? T.RawValue {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "\(T.RawValue.self) matching a case from the enumeration \(T.self)", actual: String(describing: type(of: source))))
        }
    }

    static func decode<T>(clazz: T.Type, source: AnyObject, instance: AnyObject?) -> Decoded<T> {
        initialize()
        if let sourceNumber = source as? NSNumber, let value = sourceNumber.int32Value as? T, T.self is Int32.Type {
            return .success(value)
        }
        if let sourceNumber = source as? NSNumber, let value = sourceNumber.int32Value as? T, T.self is Int64.Type {
     	    return .success(value)
        }
        if let intermediate = source as? String, let value = UUID(uuidString: intermediate) as? T, source is String, T.self is UUID.Type {
            return .success(value)
        }
        if let value = source as? T {
            return .success(value)
        }
        if let intermediate = source as? String, let value = Data(base64Encoded: intermediate) as? T {
            return .success(value)
        }
        let key = "\(T.self)"
        if let decoder = decoders[key], let value = decoder(source, instance) as? Decoded<T> {
           return value
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    //Convert a Decoded so that its value is optional. DO WE STILL NEED THIS?
    static func toOptional<T>(decoded: Decoded<T>) -> Decoded<T?> {
        return .success(decoded.value)
    }

    static func decodeOptional<T>(clazz: T.Type, source: AnyObject?) -> Decoded<T?> {
        if let source = source, !(source is NSNull) {
            switch Decoders.decode(clazz: clazz, source: source, instance: nil) {
            case let .success(value): return .success(value)
            case let .failure(error): return .failure(error)
            }
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T>(clazz: [T].Type, source: AnyObject?) -> Decoded<[T]?> where T: RawRepresentable {
        if let source = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in source {
                switch Decoders.decodeOptional(clazz: T.self, source: sourceValue) {
                case let .success(value): if let value = value { values.append(value) }
                case let .failure(error): return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T>(clazz: [T].Type, source: AnyObject?) -> Decoded<[T]?> {
        if let source = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in source {
                switch Decoders.decode(clazz: T.self, source: sourceValue, instance: nil) {
                case let .success(value): values.append(value)
                case let .failure(error): return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T, Key: Hashable>(clazz: [Key:T].Type, source: AnyObject?) -> Decoded<[Key:T]?> {
        if let sourceDictionary = source as? [Key: AnyObject] {
            var dictionary = [Key:T]()
            for (key, value) in sourceDictionary {
                switch Decoders.decode(clazz: T.self, source: value, instance: nil) {
                case let .success(value): dictionary[key] = value
                case let .failure(error): return .failure(error)
                }
            }
            return .success(dictionary)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T: RawRepresentable, U: AnyObject>(clazz: T, source: AnyObject) -> Decoded<T?> where T.RawValue == U {
        if let value = source as? U {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "String", actual: String(describing: type(of: source))))
        }
    }


    private static var __once: () = {
        let formatters = [
            "yyyy-MM-dd",
            "yyyy-MM-dd'T'HH:mm:ssZZZZZ",
            "yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ",
            "yyyy-MM-dd'T'HH:mm:ss'Z'",
            "yyyy-MM-dd'T'HH:mm:ss.SSS",
            "yyyy-MM-dd HH:mm:ss"
        ].map { (format: String) -> DateFormatter in
            let formatter = DateFormatter()
            formatter.locale = Locale(identifier: "en_US_POSIX")
            formatter.dateFormat = format
            return formatter
        }
        // Decoder for Date
        Decoders.addDecoder(clazz: Date.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Date> in
           if let sourceString = source as? String {
                for formatter in formatters {
                    if let date = formatter.date(from: sourceString) {
                        return .success(date)
                    }
                }
            }
            if let sourceInt = source as? Int {
                // treat as a java date
                return .success(Date(timeIntervalSince1970: Double(sourceInt / 1000) ))
            }
            if source is String || source is Int {
                return .failure(.parseError(message: "Could not decode date"))
            } else {
                return .failure(.typeMismatch(expected: "String or Int", actual: "\(source)"))
            }
        }

        // Decoder for ISOFullDate
        Decoders.addDecoder(clazz: ISOFullDate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ISOFullDate> in
            if let string = source as? String,
               let isoDate = ISOFullDate.from(string: string) {
                return .success(isoDate)
            } else {
            	return .failure(.typeMismatch(expected: "ISO date", actual: "\(source)"))
            }
        }

        // Decoder for [AppGet]
        Decoders.addDecoder(clazz: [AppGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppGet]> in
            return Decoders.decode(clazz: [AppGet].self, source: source)
        }

        // Decoder for AppGet
        Decoders.addDecoder(clazz: AppGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AppGet() : instance as! AppGet
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppGet", actual: "\(source)"))
            }
        }
        // Decoder for [AppGetFull]
        Decoders.addDecoder(clazz: [AppGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppGetFull]> in
            return Decoders.decode(clazz: [AppGetFull].self, source: source)
        }

        // Decoder for AppGetFull
        Decoders.addDecoder(clazz: AppGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AppGetFull() : instance as! AppGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [AppGetRef]
        Decoders.addDecoder(clazz: [AppGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppGetRef]> in
            return Decoders.decode(clazz: [AppGetRef].self, source: source)
        }

        // Decoder for AppGetRef
        Decoders.addDecoder(clazz: AppGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AppGetRef() : instance as! AppGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmentGet]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmentGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmentGet]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmentGet].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmentGet
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmentGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmentGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AppointmentschedulingAppointmentGet() : instance as! AppointmentschedulingAppointmentGet
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmentGet", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmentGetFull]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmentGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmentGetFull]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmentGetFull].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmentGetFull
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmentGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmentGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AppointmentschedulingAppointmentGetFull() : instance as! AppointmentschedulingAppointmentGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmentGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmentGetRef]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmentGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmentGetRef]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmentGetRef].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmentGetRef
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmentGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmentGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AppointmentschedulingAppointmentGetRef() : instance as! AppointmentschedulingAppointmentGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmentGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmentblockGet]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmentblockGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmentblockGet]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmentblockGet].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmentblockGet
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmentblockGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmentblockGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AppointmentschedulingAppointmentblockGet() : instance as! AppointmentschedulingAppointmentblockGet
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmentblockGet", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmentblockGetFull]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmentblockGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmentblockGetFull]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmentblockGetFull].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmentblockGetFull
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmentblockGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmentblockGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AppointmentschedulingAppointmentblockGetFull() : instance as! AppointmentschedulingAppointmentblockGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmentblockGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmentblockGetRef]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmentblockGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmentblockGetRef]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmentblockGetRef].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmentblockGetRef
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmentblockGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmentblockGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AppointmentschedulingAppointmentblockGetRef() : instance as! AppointmentschedulingAppointmentblockGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmentblockGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmentrequestGet]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmentrequestGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmentrequestGet]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmentrequestGet].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmentrequestGet
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmentrequestGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmentrequestGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AppointmentschedulingAppointmentrequestGet() : instance as! AppointmentschedulingAppointmentrequestGet
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmentrequestGet", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmentrequestGetFull]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmentrequestGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmentrequestGetFull]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmentrequestGetFull].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmentrequestGetFull
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmentrequestGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmentrequestGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AppointmentschedulingAppointmentrequestGetFull() : instance as! AppointmentschedulingAppointmentrequestGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmentrequestGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmentrequestGetRef]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmentrequestGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmentrequestGetRef]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmentrequestGetRef].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmentrequestGetRef
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmentrequestGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmentrequestGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AppointmentschedulingAppointmentrequestGetRef() : instance as! AppointmentschedulingAppointmentrequestGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmentrequestGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmenttypeCreate]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmenttypeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmenttypeCreate]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmenttypeCreate].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmenttypeCreate
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmenttypeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmenttypeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AppointmentschedulingAppointmenttypeCreate() : instance as! AppointmentschedulingAppointmenttypeCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmenttypeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmenttypeCreateFull]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmenttypeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmenttypeCreateFull]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmenttypeCreateFull].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmenttypeCreateFull
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmenttypeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmenttypeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AppointmentschedulingAppointmenttypeCreateFull() : instance as! AppointmentschedulingAppointmenttypeCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmenttypeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmenttypeGet]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmenttypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmenttypeGet]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmenttypeGet].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmenttypeGet
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmenttypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmenttypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AppointmentschedulingAppointmenttypeGet() : instance as! AppointmentschedulingAppointmenttypeGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmenttypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmenttypeGetFull]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmenttypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmenttypeGetFull]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmenttypeGetFull].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmenttypeGetFull
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmenttypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmenttypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AppointmentschedulingAppointmenttypeGetFull() : instance as! AppointmentschedulingAppointmenttypeGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmenttypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmenttypeGetRef]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmenttypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmenttypeGetRef]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmenttypeGetRef].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmenttypeGetRef
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmenttypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmenttypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AppointmentschedulingAppointmenttypeGetRef() : instance as! AppointmentschedulingAppointmenttypeGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmenttypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingAppointmenttypeUpdate]
        Decoders.addDecoder(clazz: [AppointmentschedulingAppointmenttypeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingAppointmenttypeUpdate]> in
            return Decoders.decode(clazz: [AppointmentschedulingAppointmenttypeUpdate].self, source: source)
        }

        // Decoder for AppointmentschedulingAppointmenttypeUpdate
        Decoders.addDecoder(clazz: AppointmentschedulingAppointmenttypeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingAppointmenttypeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AppointmentschedulingAppointmenttypeUpdate() : instance as! AppointmentschedulingAppointmenttypeUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingAppointmenttypeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingTimeslotGet]
        Decoders.addDecoder(clazz: [AppointmentschedulingTimeslotGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingTimeslotGet]> in
            return Decoders.decode(clazz: [AppointmentschedulingTimeslotGet].self, source: source)
        }

        // Decoder for AppointmentschedulingTimeslotGet
        Decoders.addDecoder(clazz: AppointmentschedulingTimeslotGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingTimeslotGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AppointmentschedulingTimeslotGet() : instance as! AppointmentschedulingTimeslotGet
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingTimeslotGet", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingTimeslotGetFull]
        Decoders.addDecoder(clazz: [AppointmentschedulingTimeslotGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingTimeslotGetFull]> in
            return Decoders.decode(clazz: [AppointmentschedulingTimeslotGetFull].self, source: source)
        }

        // Decoder for AppointmentschedulingTimeslotGetFull
        Decoders.addDecoder(clazz: AppointmentschedulingTimeslotGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingTimeslotGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AppointmentschedulingTimeslotGetFull() : instance as! AppointmentschedulingTimeslotGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingTimeslotGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [AppointmentschedulingTimeslotGetRef]
        Decoders.addDecoder(clazz: [AppointmentschedulingTimeslotGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AppointmentschedulingTimeslotGetRef]> in
            return Decoders.decode(clazz: [AppointmentschedulingTimeslotGetRef].self, source: source)
        }

        // Decoder for AppointmentschedulingTimeslotGetRef
        Decoders.addDecoder(clazz: AppointmentschedulingTimeslotGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AppointmentschedulingTimeslotGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AppointmentschedulingTimeslotGetRef() : instance as! AppointmentschedulingTimeslotGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AppointmentschedulingTimeslotGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ApptemplateGet]
        Decoders.addDecoder(clazz: [ApptemplateGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ApptemplateGet]> in
            return Decoders.decode(clazz: [ApptemplateGet].self, source: source)
        }

        // Decoder for ApptemplateGet
        Decoders.addDecoder(clazz: ApptemplateGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ApptemplateGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ApptemplateGet() : instance as! ApptemplateGet
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ApptemplateGet", actual: "\(source)"))
            }
        }
        // Decoder for [ApptemplateGetFull]
        Decoders.addDecoder(clazz: [ApptemplateGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ApptemplateGetFull]> in
            return Decoders.decode(clazz: [ApptemplateGetFull].self, source: source)
        }

        // Decoder for ApptemplateGetFull
        Decoders.addDecoder(clazz: ApptemplateGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ApptemplateGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ApptemplateGetFull() : instance as! ApptemplateGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ApptemplateGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ApptemplateGetRef]
        Decoders.addDecoder(clazz: [ApptemplateGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ApptemplateGetRef]> in
            return Decoders.decode(clazz: [ApptemplateGetRef].self, source: source)
        }

        // Decoder for ApptemplateGetRef
        Decoders.addDecoder(clazz: ApptemplateGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ApptemplateGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ApptemplateGetRef() : instance as! ApptemplateGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ApptemplateGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [CaresettingGet]
        Decoders.addDecoder(clazz: [CaresettingGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CaresettingGet]> in
            return Decoders.decode(clazz: [CaresettingGet].self, source: source)
        }

        // Decoder for CaresettingGet
        Decoders.addDecoder(clazz: CaresettingGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CaresettingGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CaresettingGet() : instance as! CaresettingGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: CaresettingGet.CareSettingType.self, source: sourceDictionary["careSettingType"] as AnyObject?) {
                case let .success(value): _result.careSettingType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CaresettingGet", actual: "\(source)"))
            }
        }
        // Decoder for [CaresettingGetFull]
        Decoders.addDecoder(clazz: [CaresettingGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CaresettingGetFull]> in
            return Decoders.decode(clazz: [CaresettingGetFull].self, source: source)
        }

        // Decoder for CaresettingGetFull
        Decoders.addDecoder(clazz: CaresettingGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CaresettingGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CaresettingGetFull() : instance as! CaresettingGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: CaresettingGetFull.CareSettingType.self, source: sourceDictionary["careSettingType"] as AnyObject?) {
                case let .success(value): _result.careSettingType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CaresettingGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [CaresettingGetRef]
        Decoders.addDecoder(clazz: [CaresettingGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CaresettingGetRef]> in
            return Decoders.decode(clazz: [CaresettingGetRef].self, source: source)
        }

        // Decoder for CaresettingGetRef
        Decoders.addDecoder(clazz: CaresettingGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CaresettingGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CaresettingGetRef() : instance as! CaresettingGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CaresettingGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ChartSearchPreferenceGet]
        Decoders.addDecoder(clazz: [ChartSearchPreferenceGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ChartSearchPreferenceGet]> in
            return Decoders.decode(clazz: [ChartSearchPreferenceGet].self, source: source)
        }

        // Decoder for ChartSearchPreferenceGet
        Decoders.addDecoder(clazz: ChartSearchPreferenceGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ChartSearchPreferenceGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ChartSearchPreferenceGet() : instance as! ChartSearchPreferenceGet
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ChartSearchPreferenceGet", actual: "\(source)"))
            }
        }
        // Decoder for [ChartSearchPreferenceGetFull]
        Decoders.addDecoder(clazz: [ChartSearchPreferenceGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ChartSearchPreferenceGetFull]> in
            return Decoders.decode(clazz: [ChartSearchPreferenceGetFull].self, source: source)
        }

        // Decoder for ChartSearchPreferenceGetFull
        Decoders.addDecoder(clazz: ChartSearchPreferenceGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ChartSearchPreferenceGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ChartSearchPreferenceGetFull() : instance as! ChartSearchPreferenceGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ChartSearchPreferenceGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ChartSearchPreferenceGetRef]
        Decoders.addDecoder(clazz: [ChartSearchPreferenceGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ChartSearchPreferenceGetRef]> in
            return Decoders.decode(clazz: [ChartSearchPreferenceGetRef].self, source: source)
        }

        // Decoder for ChartSearchPreferenceGetRef
        Decoders.addDecoder(clazz: ChartSearchPreferenceGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ChartSearchPreferenceGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ChartSearchPreferenceGetRef() : instance as! ChartSearchPreferenceGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ChartSearchPreferenceGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ChartsearchnoteGet]
        Decoders.addDecoder(clazz: [ChartsearchnoteGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ChartsearchnoteGet]> in
            return Decoders.decode(clazz: [ChartsearchnoteGet].self, source: source)
        }

        // Decoder for ChartsearchnoteGet
        Decoders.addDecoder(clazz: ChartsearchnoteGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ChartsearchnoteGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ChartsearchnoteGet() : instance as! ChartsearchnoteGet
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ChartsearchnoteGet", actual: "\(source)"))
            }
        }
        // Decoder for [ChartsearchnoteGetFull]
        Decoders.addDecoder(clazz: [ChartsearchnoteGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ChartsearchnoteGetFull]> in
            return Decoders.decode(clazz: [ChartsearchnoteGetFull].self, source: source)
        }

        // Decoder for ChartsearchnoteGetFull
        Decoders.addDecoder(clazz: ChartsearchnoteGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ChartsearchnoteGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ChartsearchnoteGetFull() : instance as! ChartsearchnoteGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ChartsearchnoteGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ChartsearchnoteGetRef]
        Decoders.addDecoder(clazz: [ChartsearchnoteGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ChartsearchnoteGetRef]> in
            return Decoders.decode(clazz: [ChartsearchnoteGetRef].self, source: source)
        }

        // Decoder for ChartsearchnoteGetRef
        Decoders.addDecoder(clazz: ChartsearchnoteGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ChartsearchnoteGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ChartsearchnoteGetRef() : instance as! ChartsearchnoteGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ChartsearchnoteGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [CohortCreate]
        Decoders.addDecoder(clazz: [CohortCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CohortCreate]> in
            return Decoders.decode(clazz: [CohortCreate].self, source: source)
        }

        // Decoder for CohortCreate
        Decoders.addDecoder(clazz: CohortCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CohortCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CohortCreate() : instance as! CohortCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Int32].self, source: sourceDictionary["memberIds"] as AnyObject?) {
                case let .success(value): _result.memberIds = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CohortCreate", actual: "\(source)"))
            }
        }
        // Decoder for [CohortCreateFull]
        Decoders.addDecoder(clazz: [CohortCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CohortCreateFull]> in
            return Decoders.decode(clazz: [CohortCreateFull].self, source: source)
        }

        // Decoder for CohortCreateFull
        Decoders.addDecoder(clazz: CohortCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CohortCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CohortCreateFull() : instance as! CohortCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Int32].self, source: sourceDictionary["memberIds"] as AnyObject?) {
                case let .success(value): _result.memberIds = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CohortCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [CohortGet]
        Decoders.addDecoder(clazz: [CohortGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CohortGet]> in
            return Decoders.decode(clazz: [CohortGet].self, source: source)
        }

        // Decoder for CohortGet
        Decoders.addDecoder(clazz: CohortGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CohortGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CohortGet() : instance as! CohortGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CohortGet", actual: "\(source)"))
            }
        }
        // Decoder for [CohortGetFull]
        Decoders.addDecoder(clazz: [CohortGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CohortGetFull]> in
            return Decoders.decode(clazz: [CohortGetFull].self, source: source)
        }

        // Decoder for CohortGetFull
        Decoders.addDecoder(clazz: CohortGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CohortGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CohortGetFull() : instance as! CohortGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CohortGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [CohortGetRef]
        Decoders.addDecoder(clazz: [CohortGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CohortGetRef]> in
            return Decoders.decode(clazz: [CohortGetRef].self, source: source)
        }

        // Decoder for CohortGetRef
        Decoders.addDecoder(clazz: CohortGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CohortGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CohortGetRef() : instance as! CohortGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CohortGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [CohortMembershipCreate]
        Decoders.addDecoder(clazz: [CohortMembershipCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CohortMembershipCreate]> in
            return Decoders.decode(clazz: [CohortMembershipCreate].self, source: source)
        }

        // Decoder for CohortMembershipCreate
        Decoders.addDecoder(clazz: CohortMembershipCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CohortMembershipCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CohortMembershipCreate() : instance as! CohortMembershipCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["patientUuid"] as AnyObject?) {
                case let .success(value): _result.patientUuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CohortMembershipCreate", actual: "\(source)"))
            }
        }
        // Decoder for [CohortMembershipCreateFull]
        Decoders.addDecoder(clazz: [CohortMembershipCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CohortMembershipCreateFull]> in
            return Decoders.decode(clazz: [CohortMembershipCreateFull].self, source: source)
        }

        // Decoder for CohortMembershipCreateFull
        Decoders.addDecoder(clazz: CohortMembershipCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CohortMembershipCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CohortMembershipCreateFull() : instance as! CohortMembershipCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["patientUuid"] as AnyObject?) {
                case let .success(value): _result.patientUuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CohortMembershipCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [CohortMembershipGet]
        Decoders.addDecoder(clazz: [CohortMembershipGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CohortMembershipGet]> in
            return Decoders.decode(clazz: [CohortMembershipGet].self, source: source)
        }

        // Decoder for CohortMembershipGet
        Decoders.addDecoder(clazz: CohortMembershipGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CohortMembershipGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CohortMembershipGet() : instance as! CohortMembershipGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["patientUuid"] as AnyObject?) {
                case let .success(value): _result.patientUuid = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CohortMembershipGet", actual: "\(source)"))
            }
        }
        // Decoder for [CohortMembershipGetFull]
        Decoders.addDecoder(clazz: [CohortMembershipGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CohortMembershipGetFull]> in
            return Decoders.decode(clazz: [CohortMembershipGetFull].self, source: source)
        }

        // Decoder for CohortMembershipGetFull
        Decoders.addDecoder(clazz: CohortMembershipGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CohortMembershipGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CohortMembershipGetFull() : instance as! CohortMembershipGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["patientUuid"] as AnyObject?) {
                case let .success(value): _result.patientUuid = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CohortMembershipGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [CohortMembershipGetRef]
        Decoders.addDecoder(clazz: [CohortMembershipGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CohortMembershipGetRef]> in
            return Decoders.decode(clazz: [CohortMembershipGetRef].self, source: source)
        }

        // Decoder for CohortMembershipGetRef
        Decoders.addDecoder(clazz: CohortMembershipGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CohortMembershipGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CohortMembershipGetRef() : instance as! CohortMembershipGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CohortMembershipGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [CohortMembershipUpdate]
        Decoders.addDecoder(clazz: [CohortMembershipUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CohortMembershipUpdate]> in
            return Decoders.decode(clazz: [CohortMembershipUpdate].self, source: source)
        }

        // Decoder for CohortMembershipUpdate
        Decoders.addDecoder(clazz: CohortMembershipUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CohortMembershipUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CohortMembershipUpdate() : instance as! CohortMembershipUpdate
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CohortMembershipUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [CohortUpdate]
        Decoders.addDecoder(clazz: [CohortUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CohortUpdate]> in
            return Decoders.decode(clazz: [CohortUpdate].self, source: source)
        }

        // Decoder for CohortUpdate
        Decoders.addDecoder(clazz: CohortUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CohortUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CohortUpdate() : instance as! CohortUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CohortUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptAttributeCreate]
        Decoders.addDecoder(clazz: [ConceptAttributeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptAttributeCreate]> in
            return Decoders.decode(clazz: [ConceptAttributeCreate].self, source: source)
        }

        // Decoder for ConceptAttributeCreate
        Decoders.addDecoder(clazz: ConceptAttributeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptAttributeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptAttributeCreate() : instance as! ConceptAttributeCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptAttributeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptAttributeCreateFull]
        Decoders.addDecoder(clazz: [ConceptAttributeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptAttributeCreateFull]> in
            return Decoders.decode(clazz: [ConceptAttributeCreateFull].self, source: source)
        }

        // Decoder for ConceptAttributeCreateFull
        Decoders.addDecoder(clazz: ConceptAttributeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptAttributeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptAttributeCreateFull() : instance as! ConceptAttributeCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptAttributeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptAttributeGet]
        Decoders.addDecoder(clazz: [ConceptAttributeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptAttributeGet]> in
            return Decoders.decode(clazz: [ConceptAttributeGet].self, source: source)
        }

        // Decoder for ConceptAttributeGet
        Decoders.addDecoder(clazz: ConceptAttributeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptAttributeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptAttributeGet() : instance as! ConceptAttributeGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptAttributeGet", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptAttributeGetFull]
        Decoders.addDecoder(clazz: [ConceptAttributeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptAttributeGetFull]> in
            return Decoders.decode(clazz: [ConceptAttributeGetFull].self, source: source)
        }

        // Decoder for ConceptAttributeGetFull
        Decoders.addDecoder(clazz: ConceptAttributeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptAttributeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptAttributeGetFull() : instance as! ConceptAttributeGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptAttributeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptAttributeGetRef]
        Decoders.addDecoder(clazz: [ConceptAttributeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptAttributeGetRef]> in
            return Decoders.decode(clazz: [ConceptAttributeGetRef].self, source: source)
        }

        // Decoder for ConceptAttributeGetRef
        Decoders.addDecoder(clazz: ConceptAttributeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptAttributeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptAttributeGetRef() : instance as! ConceptAttributeGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptAttributeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptAttributeUpdate]
        Decoders.addDecoder(clazz: [ConceptAttributeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptAttributeUpdate]> in
            return Decoders.decode(clazz: [ConceptAttributeUpdate].self, source: source)
        }

        // Decoder for ConceptAttributeUpdate
        Decoders.addDecoder(clazz: ConceptAttributeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptAttributeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptAttributeUpdate() : instance as! ConceptAttributeUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptAttributeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptCreate]
        Decoders.addDecoder(clazz: [ConceptCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptCreate]> in
            return Decoders.decode(clazz: [ConceptCreate].self, source: source)
        }

        // Decoder for ConceptCreate
        Decoders.addDecoder(clazz: ConceptCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptCreate() : instance as! ConceptCreate
                switch Decoders.decodeOptional(clazz: [ConceptNameCreate].self, source: sourceDictionary["names"] as AnyObject?) {
                case let .success(value): _result.names = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatype"] as AnyObject?) {
                case let .success(value): _result.datatype = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["set"] as AnyObject?) {
                case let .success(value): _result._set = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["version"] as AnyObject?) {
                case let .success(value): _result.version = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["answers"] as AnyObject?) {
                case let .success(value): _result.answers = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["setMembers"] as AnyObject?) {
                case let .success(value): _result.setMembers = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hiNormal"] as AnyObject?) {
                case let .success(value): _result.hiNormal = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hiAbsolute"] as AnyObject?) {
                case let .success(value): _result.hiAbsolute = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hiCritical"] as AnyObject?) {
                case let .success(value): _result.hiCritical = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["lowNormal"] as AnyObject?) {
                case let .success(value): _result.lowNormal = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["lowAbsolute"] as AnyObject?) {
                case let .success(value): _result.lowAbsolute = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["lowCritical"] as AnyObject?) {
                case let .success(value): _result.lowCritical = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["units"] as AnyObject?) {
                case let .success(value): _result.units = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["allowDecimal"] as AnyObject?) {
                case let .success(value): _result.allowDecimal = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["displayPrecision"] as AnyObject?) {
                case let .success(value): _result.displayPrecision = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["conceptClass"] as AnyObject?) {
                case let .success(value): _result.conceptClass = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["descriptions"] as AnyObject?) {
                case let .success(value): _result.descriptions = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["mappings"] as AnyObject?) {
                case let .success(value): _result.mappings = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptCreateFull]
        Decoders.addDecoder(clazz: [ConceptCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptCreateFull]> in
            return Decoders.decode(clazz: [ConceptCreateFull].self, source: source)
        }

        // Decoder for ConceptCreateFull
        Decoders.addDecoder(clazz: ConceptCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptCreateFull() : instance as! ConceptCreateFull
                switch Decoders.decodeOptional(clazz: [ConceptNameCreate].self, source: sourceDictionary["names"] as AnyObject?) {
                case let .success(value): _result.names = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatype"] as AnyObject?) {
                case let .success(value): _result.datatype = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["set"] as AnyObject?) {
                case let .success(value): _result._set = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["version"] as AnyObject?) {
                case let .success(value): _result.version = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["answers"] as AnyObject?) {
                case let .success(value): _result.answers = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["setMembers"] as AnyObject?) {
                case let .success(value): _result.setMembers = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hiNormal"] as AnyObject?) {
                case let .success(value): _result.hiNormal = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hiAbsolute"] as AnyObject?) {
                case let .success(value): _result.hiAbsolute = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hiCritical"] as AnyObject?) {
                case let .success(value): _result.hiCritical = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["lowNormal"] as AnyObject?) {
                case let .success(value): _result.lowNormal = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["lowAbsolute"] as AnyObject?) {
                case let .success(value): _result.lowAbsolute = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["lowCritical"] as AnyObject?) {
                case let .success(value): _result.lowCritical = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["units"] as AnyObject?) {
                case let .success(value): _result.units = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["allowDecimal"] as AnyObject?) {
                case let .success(value): _result.allowDecimal = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["displayPrecision"] as AnyObject?) {
                case let .success(value): _result.displayPrecision = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptclassCreate.self, source: sourceDictionary["conceptClass"] as AnyObject?) {
                case let .success(value): _result.conceptClass = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ConceptDescriptionCreate].self, source: sourceDictionary["descriptions"] as AnyObject?) {
                case let .success(value): _result.descriptions = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ConceptMappingCreate].self, source: sourceDictionary["mappings"] as AnyObject?) {
                case let .success(value): _result.mappings = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptDescriptionCreate]
        Decoders.addDecoder(clazz: [ConceptDescriptionCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptDescriptionCreate]> in
            return Decoders.decode(clazz: [ConceptDescriptionCreate].self, source: source)
        }

        // Decoder for ConceptDescriptionCreate
        Decoders.addDecoder(clazz: ConceptDescriptionCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptDescriptionCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptDescriptionCreate() : instance as! ConceptDescriptionCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["locale"] as AnyObject?) {
                case let .success(value): _result.locale = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptDescriptionCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptDescriptionCreateFull]
        Decoders.addDecoder(clazz: [ConceptDescriptionCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptDescriptionCreateFull]> in
            return Decoders.decode(clazz: [ConceptDescriptionCreateFull].self, source: source)
        }

        // Decoder for ConceptDescriptionCreateFull
        Decoders.addDecoder(clazz: ConceptDescriptionCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptDescriptionCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptDescriptionCreateFull() : instance as! ConceptDescriptionCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["locale"] as AnyObject?) {
                case let .success(value): _result.locale = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptDescriptionCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptDescriptionGet]
        Decoders.addDecoder(clazz: [ConceptDescriptionGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptDescriptionGet]> in
            return Decoders.decode(clazz: [ConceptDescriptionGet].self, source: source)
        }

        // Decoder for ConceptDescriptionGet
        Decoders.addDecoder(clazz: ConceptDescriptionGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptDescriptionGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptDescriptionGet() : instance as! ConceptDescriptionGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["locale"] as AnyObject?) {
                case let .success(value): _result.locale = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptDescriptionGet", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptDescriptionGetFull]
        Decoders.addDecoder(clazz: [ConceptDescriptionGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptDescriptionGetFull]> in
            return Decoders.decode(clazz: [ConceptDescriptionGetFull].self, source: source)
        }

        // Decoder for ConceptDescriptionGetFull
        Decoders.addDecoder(clazz: ConceptDescriptionGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptDescriptionGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptDescriptionGetFull() : instance as! ConceptDescriptionGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["locale"] as AnyObject?) {
                case let .success(value): _result.locale = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptDescriptionGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptDescriptionGetRef]
        Decoders.addDecoder(clazz: [ConceptDescriptionGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptDescriptionGetRef]> in
            return Decoders.decode(clazz: [ConceptDescriptionGetRef].self, source: source)
        }

        // Decoder for ConceptDescriptionGetRef
        Decoders.addDecoder(clazz: ConceptDescriptionGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptDescriptionGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptDescriptionGetRef() : instance as! ConceptDescriptionGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptDescriptionGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptDescriptionUpdate]
        Decoders.addDecoder(clazz: [ConceptDescriptionUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptDescriptionUpdate]> in
            return Decoders.decode(clazz: [ConceptDescriptionUpdate].self, source: source)
        }

        // Decoder for ConceptDescriptionUpdate
        Decoders.addDecoder(clazz: ConceptDescriptionUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptDescriptionUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptDescriptionUpdate() : instance as! ConceptDescriptionUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["locale"] as AnyObject?) {
                case let .success(value): _result.locale = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptDescriptionUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptGet]
        Decoders.addDecoder(clazz: [ConceptGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptGet]> in
            return Decoders.decode(clazz: [ConceptGet].self, source: source)
        }

        // Decoder for ConceptGet
        Decoders.addDecoder(clazz: ConceptGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptGet() : instance as! ConceptGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptNameGet.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptdatatypeGetRef.self, source: sourceDictionary["datatype"] as AnyObject?) {
                case let .success(value): _result.datatype = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptclassGetRef.self, source: sourceDictionary["conceptClass"] as AnyObject?) {
                case let .success(value): _result.conceptClass = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["set"] as AnyObject?) {
                case let .success(value): _result._set = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["version"] as AnyObject?) {
                case let .success(value): _result.version = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ConceptNameGetRef].self, source: sourceDictionary["names"] as AnyObject?) {
                case let .success(value): _result.names = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ConceptDescriptionGetRef].self, source: sourceDictionary["descriptions"] as AnyObject?) {
                case let .success(value): _result.descriptions = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ConceptMappingGetRef].self, source: sourceDictionary["mappings"] as AnyObject?) {
                case let .success(value): _result.mappings = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Any].self, source: sourceDictionary["answers"] as AnyObject?) {
                case let .success(value): _result.answers = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Any].self, source: sourceDictionary["setMembers"] as AnyObject?) {
                case let .success(value): _result.setMembers = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptGet", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptGetFull]
        Decoders.addDecoder(clazz: [ConceptGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptGetFull]> in
            return Decoders.decode(clazz: [ConceptGetFull].self, source: source)
        }

        // Decoder for ConceptGetFull
        Decoders.addDecoder(clazz: ConceptGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptGetFull() : instance as! ConceptGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptGetRef]
        Decoders.addDecoder(clazz: [ConceptGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptGetRef]> in
            return Decoders.decode(clazz: [ConceptGetRef].self, source: source)
        }

        // Decoder for ConceptGetRef
        Decoders.addDecoder(clazz: ConceptGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptGetRef() : instance as! ConceptGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptMappingCreate]
        Decoders.addDecoder(clazz: [ConceptMappingCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptMappingCreate]> in
            return Decoders.decode(clazz: [ConceptMappingCreate].self, source: source)
        }

        // Decoder for ConceptMappingCreate
        Decoders.addDecoder(clazz: ConceptMappingCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptMappingCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptMappingCreate() : instance as! ConceptMappingCreate
                switch Decoders.decodeOptional(clazz: ConceptreferencetermCreate.self, source: sourceDictionary["conceptReferenceTerm"] as AnyObject?) {
                case let .success(value): _result.conceptReferenceTerm = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptmaptypeCreate.self, source: sourceDictionary["conceptMapType"] as AnyObject?) {
                case let .success(value): _result.conceptMapType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptMappingCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptMappingCreateFull]
        Decoders.addDecoder(clazz: [ConceptMappingCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptMappingCreateFull]> in
            return Decoders.decode(clazz: [ConceptMappingCreateFull].self, source: source)
        }

        // Decoder for ConceptMappingCreateFull
        Decoders.addDecoder(clazz: ConceptMappingCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptMappingCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptMappingCreateFull() : instance as! ConceptMappingCreateFull
                switch Decoders.decodeOptional(clazz: ConceptreferencetermCreate.self, source: sourceDictionary["conceptReferenceTerm"] as AnyObject?) {
                case let .success(value): _result.conceptReferenceTerm = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptmaptypeCreate.self, source: sourceDictionary["conceptMapType"] as AnyObject?) {
                case let .success(value): _result.conceptMapType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptMappingCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptMappingGet]
        Decoders.addDecoder(clazz: [ConceptMappingGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptMappingGet]> in
            return Decoders.decode(clazz: [ConceptMappingGet].self, source: source)
        }

        // Decoder for ConceptMappingGet
        Decoders.addDecoder(clazz: ConceptMappingGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptMappingGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptMappingGet() : instance as! ConceptMappingGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptreferencetermGetRef.self, source: sourceDictionary["conceptReferenceTerm"] as AnyObject?) {
                case let .success(value): _result.conceptReferenceTerm = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptmaptypeGetRef.self, source: sourceDictionary["conceptMapType"] as AnyObject?) {
                case let .success(value): _result.conceptMapType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptMappingGet", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptMappingGetFull]
        Decoders.addDecoder(clazz: [ConceptMappingGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptMappingGetFull]> in
            return Decoders.decode(clazz: [ConceptMappingGetFull].self, source: source)
        }

        // Decoder for ConceptMappingGetFull
        Decoders.addDecoder(clazz: ConceptMappingGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptMappingGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptMappingGetFull() : instance as! ConceptMappingGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptreferencetermGet.self, source: sourceDictionary["conceptReferenceTerm"] as AnyObject?) {
                case let .success(value): _result.conceptReferenceTerm = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptmaptypeGet.self, source: sourceDictionary["conceptMapType"] as AnyObject?) {
                case let .success(value): _result.conceptMapType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptMappingGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptMappingGetRef]
        Decoders.addDecoder(clazz: [ConceptMappingGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptMappingGetRef]> in
            return Decoders.decode(clazz: [ConceptMappingGetRef].self, source: source)
        }

        // Decoder for ConceptMappingGetRef
        Decoders.addDecoder(clazz: ConceptMappingGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptMappingGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptMappingGetRef() : instance as! ConceptMappingGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptMappingGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptMappingUpdate]
        Decoders.addDecoder(clazz: [ConceptMappingUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptMappingUpdate]> in
            return Decoders.decode(clazz: [ConceptMappingUpdate].self, source: source)
        }

        // Decoder for ConceptMappingUpdate
        Decoders.addDecoder(clazz: ConceptMappingUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptMappingUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptMappingUpdate() : instance as! ConceptMappingUpdate
                switch Decoders.decodeOptional(clazz: ConceptreferencetermCreate.self, source: sourceDictionary["conceptReferenceTerm"] as AnyObject?) {
                case let .success(value): _result.conceptReferenceTerm = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptmaptypeCreate.self, source: sourceDictionary["conceptMapType"] as AnyObject?) {
                case let .success(value): _result.conceptMapType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptMappingUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptNameCreate]
        Decoders.addDecoder(clazz: [ConceptNameCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptNameCreate]> in
            return Decoders.decode(clazz: [ConceptNameCreate].self, source: source)
        }

        // Decoder for ConceptNameCreate
        Decoders.addDecoder(clazz: ConceptNameCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptNameCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptNameCreate() : instance as! ConceptNameCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["locale"] as AnyObject?) {
                case let .success(value): _result.locale = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["localePreferred"] as AnyObject?) {
                case let .success(value): _result.localePreferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptNameCreate.ConceptNameType.self, source: sourceDictionary["conceptNameType"] as AnyObject?) {
                case let .success(value): _result.conceptNameType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptNameCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptNameCreateFull]
        Decoders.addDecoder(clazz: [ConceptNameCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptNameCreateFull]> in
            return Decoders.decode(clazz: [ConceptNameCreateFull].self, source: source)
        }

        // Decoder for ConceptNameCreateFull
        Decoders.addDecoder(clazz: ConceptNameCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptNameCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptNameCreateFull() : instance as! ConceptNameCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["locale"] as AnyObject?) {
                case let .success(value): _result.locale = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["localePreferred"] as AnyObject?) {
                case let .success(value): _result.localePreferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptNameCreateFull.ConceptNameType.self, source: sourceDictionary["conceptNameType"] as AnyObject?) {
                case let .success(value): _result.conceptNameType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptNameCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptNameGet]
        Decoders.addDecoder(clazz: [ConceptNameGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptNameGet]> in
            return Decoders.decode(clazz: [ConceptNameGet].self, source: source)
        }

        // Decoder for ConceptNameGet
        Decoders.addDecoder(clazz: ConceptNameGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptNameGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptNameGet() : instance as! ConceptNameGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["locale"] as AnyObject?) {
                case let .success(value): _result.locale = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["localePreferred"] as AnyObject?) {
                case let .success(value): _result.localePreferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptNameGet.ConceptNameType.self, source: sourceDictionary["conceptNameType"] as AnyObject?) {
                case let .success(value): _result.conceptNameType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptNameGet", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptNameGetFull]
        Decoders.addDecoder(clazz: [ConceptNameGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptNameGetFull]> in
            return Decoders.decode(clazz: [ConceptNameGetFull].self, source: source)
        }

        // Decoder for ConceptNameGetFull
        Decoders.addDecoder(clazz: ConceptNameGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptNameGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptNameGetFull() : instance as! ConceptNameGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["locale"] as AnyObject?) {
                case let .success(value): _result.locale = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["localePreferred"] as AnyObject?) {
                case let .success(value): _result.localePreferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptNameGetFull.ConceptNameType.self, source: sourceDictionary["conceptNameType"] as AnyObject?) {
                case let .success(value): _result.conceptNameType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptNameGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptNameGetRef]
        Decoders.addDecoder(clazz: [ConceptNameGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptNameGetRef]> in
            return Decoders.decode(clazz: [ConceptNameGetRef].self, source: source)
        }

        // Decoder for ConceptNameGetRef
        Decoders.addDecoder(clazz: ConceptNameGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptNameGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptNameGetRef() : instance as! ConceptNameGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptNameGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptNameUpdate]
        Decoders.addDecoder(clazz: [ConceptNameUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptNameUpdate]> in
            return Decoders.decode(clazz: [ConceptNameUpdate].self, source: source)
        }

        // Decoder for ConceptNameUpdate
        Decoders.addDecoder(clazz: ConceptNameUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptNameUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptNameUpdate() : instance as! ConceptNameUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptNameUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptUpdate]
        Decoders.addDecoder(clazz: [ConceptUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptUpdate]> in
            return Decoders.decode(clazz: [ConceptUpdate].self, source: source)
        }

        // Decoder for ConceptUpdate
        Decoders.addDecoder(clazz: ConceptUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptUpdate() : instance as! ConceptUpdate
                switch Decoders.decodeOptional(clazz: ConceptNameCreate.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ConceptNameCreate].self, source: sourceDictionary["names"] as AnyObject?) {
                case let .success(value): _result.names = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ConceptDescriptionCreate].self, source: sourceDictionary["descriptions"] as AnyObject?) {
                case let .success(value): _result.descriptions = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptattributetypeCreate]
        Decoders.addDecoder(clazz: [ConceptattributetypeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptattributetypeCreate]> in
            return Decoders.decode(clazz: [ConceptattributetypeCreate].self, source: source)
        }

        // Decoder for ConceptattributetypeCreate
        Decoders.addDecoder(clazz: ConceptattributetypeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptattributetypeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptattributetypeCreate() : instance as! ConceptattributetypeCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptattributetypeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptattributetypeCreateFull]
        Decoders.addDecoder(clazz: [ConceptattributetypeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptattributetypeCreateFull]> in
            return Decoders.decode(clazz: [ConceptattributetypeCreateFull].self, source: source)
        }

        // Decoder for ConceptattributetypeCreateFull
        Decoders.addDecoder(clazz: ConceptattributetypeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptattributetypeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptattributetypeCreateFull() : instance as! ConceptattributetypeCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptattributetypeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptattributetypeGet]
        Decoders.addDecoder(clazz: [ConceptattributetypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptattributetypeGet]> in
            return Decoders.decode(clazz: [ConceptattributetypeGet].self, source: source)
        }

        // Decoder for ConceptattributetypeGet
        Decoders.addDecoder(clazz: ConceptattributetypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptattributetypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptattributetypeGet() : instance as! ConceptattributetypeGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptattributetypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptattributetypeGetFull]
        Decoders.addDecoder(clazz: [ConceptattributetypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptattributetypeGetFull]> in
            return Decoders.decode(clazz: [ConceptattributetypeGetFull].self, source: source)
        }

        // Decoder for ConceptattributetypeGetFull
        Decoders.addDecoder(clazz: ConceptattributetypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptattributetypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptattributetypeGetFull() : instance as! ConceptattributetypeGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptattributetypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptattributetypeGetRef]
        Decoders.addDecoder(clazz: [ConceptattributetypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptattributetypeGetRef]> in
            return Decoders.decode(clazz: [ConceptattributetypeGetRef].self, source: source)
        }

        // Decoder for ConceptattributetypeGetRef
        Decoders.addDecoder(clazz: ConceptattributetypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptattributetypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptattributetypeGetRef() : instance as! ConceptattributetypeGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptattributetypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptattributetypeUpdate]
        Decoders.addDecoder(clazz: [ConceptattributetypeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptattributetypeUpdate]> in
            return Decoders.decode(clazz: [ConceptattributetypeUpdate].self, source: source)
        }

        // Decoder for ConceptattributetypeUpdate
        Decoders.addDecoder(clazz: ConceptattributetypeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptattributetypeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptattributetypeUpdate() : instance as! ConceptattributetypeUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptattributetypeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptclassCreate]
        Decoders.addDecoder(clazz: [ConceptclassCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptclassCreate]> in
            return Decoders.decode(clazz: [ConceptclassCreate].self, source: source)
        }

        // Decoder for ConceptclassCreate
        Decoders.addDecoder(clazz: ConceptclassCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptclassCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptclassCreate() : instance as! ConceptclassCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptclassCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptclassCreateFull]
        Decoders.addDecoder(clazz: [ConceptclassCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptclassCreateFull]> in
            return Decoders.decode(clazz: [ConceptclassCreateFull].self, source: source)
        }

        // Decoder for ConceptclassCreateFull
        Decoders.addDecoder(clazz: ConceptclassCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptclassCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptclassCreateFull() : instance as! ConceptclassCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptclassCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptclassGet]
        Decoders.addDecoder(clazz: [ConceptclassGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptclassGet]> in
            return Decoders.decode(clazz: [ConceptclassGet].self, source: source)
        }

        // Decoder for ConceptclassGet
        Decoders.addDecoder(clazz: ConceptclassGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptclassGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptclassGet() : instance as! ConceptclassGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptclassGet", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptclassGetFull]
        Decoders.addDecoder(clazz: [ConceptclassGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptclassGetFull]> in
            return Decoders.decode(clazz: [ConceptclassGetFull].self, source: source)
        }

        // Decoder for ConceptclassGetFull
        Decoders.addDecoder(clazz: ConceptclassGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptclassGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptclassGetFull() : instance as! ConceptclassGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptclassGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptclassGetRef]
        Decoders.addDecoder(clazz: [ConceptclassGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptclassGetRef]> in
            return Decoders.decode(clazz: [ConceptclassGetRef].self, source: source)
        }

        // Decoder for ConceptclassGetRef
        Decoders.addDecoder(clazz: ConceptclassGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptclassGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptclassGetRef() : instance as! ConceptclassGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptclassGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptclassUpdate]
        Decoders.addDecoder(clazz: [ConceptclassUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptclassUpdate]> in
            return Decoders.decode(clazz: [ConceptclassUpdate].self, source: source)
        }

        // Decoder for ConceptclassUpdate
        Decoders.addDecoder(clazz: ConceptclassUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptclassUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptclassUpdate() : instance as! ConceptclassUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptclassUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptdatatypeGet]
        Decoders.addDecoder(clazz: [ConceptdatatypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptdatatypeGet]> in
            return Decoders.decode(clazz: [ConceptdatatypeGet].self, source: source)
        }

        // Decoder for ConceptdatatypeGet
        Decoders.addDecoder(clazz: ConceptdatatypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptdatatypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptdatatypeGet() : instance as! ConceptdatatypeGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hl7Abbreviation"] as AnyObject?) {
                case let .success(value): _result.hl7Abbreviation = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptdatatypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptdatatypeGetFull]
        Decoders.addDecoder(clazz: [ConceptdatatypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptdatatypeGetFull]> in
            return Decoders.decode(clazz: [ConceptdatatypeGetFull].self, source: source)
        }

        // Decoder for ConceptdatatypeGetFull
        Decoders.addDecoder(clazz: ConceptdatatypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptdatatypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptdatatypeGetFull() : instance as! ConceptdatatypeGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hl7Abbreviation"] as AnyObject?) {
                case let .success(value): _result.hl7Abbreviation = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptdatatypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptdatatypeGetRef]
        Decoders.addDecoder(clazz: [ConceptdatatypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptdatatypeGetRef]> in
            return Decoders.decode(clazz: [ConceptdatatypeGetRef].self, source: source)
        }

        // Decoder for ConceptdatatypeGetRef
        Decoders.addDecoder(clazz: ConceptdatatypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptdatatypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptdatatypeGetRef() : instance as! ConceptdatatypeGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptdatatypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptmaptypeCreate]
        Decoders.addDecoder(clazz: [ConceptmaptypeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptmaptypeCreate]> in
            return Decoders.decode(clazz: [ConceptmaptypeCreate].self, source: source)
        }

        // Decoder for ConceptmaptypeCreate
        Decoders.addDecoder(clazz: ConceptmaptypeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptmaptypeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptmaptypeCreate() : instance as! ConceptmaptypeCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["isHidden"] as AnyObject?) {
                case let .success(value): _result.isHidden = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptmaptypeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptmaptypeCreateFull]
        Decoders.addDecoder(clazz: [ConceptmaptypeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptmaptypeCreateFull]> in
            return Decoders.decode(clazz: [ConceptmaptypeCreateFull].self, source: source)
        }

        // Decoder for ConceptmaptypeCreateFull
        Decoders.addDecoder(clazz: ConceptmaptypeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptmaptypeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptmaptypeCreateFull() : instance as! ConceptmaptypeCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["isHidden"] as AnyObject?) {
                case let .success(value): _result.isHidden = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptmaptypeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptmaptypeGet]
        Decoders.addDecoder(clazz: [ConceptmaptypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptmaptypeGet]> in
            return Decoders.decode(clazz: [ConceptmaptypeGet].self, source: source)
        }

        // Decoder for ConceptmaptypeGet
        Decoders.addDecoder(clazz: ConceptmaptypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptmaptypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptmaptypeGet() : instance as! ConceptmaptypeGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["isHidden"] as AnyObject?) {
                case let .success(value): _result.isHidden = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptmaptypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptmaptypeGetFull]
        Decoders.addDecoder(clazz: [ConceptmaptypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptmaptypeGetFull]> in
            return Decoders.decode(clazz: [ConceptmaptypeGetFull].self, source: source)
        }

        // Decoder for ConceptmaptypeGetFull
        Decoders.addDecoder(clazz: ConceptmaptypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptmaptypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptmaptypeGetFull() : instance as! ConceptmaptypeGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["isHidden"] as AnyObject?) {
                case let .success(value): _result.isHidden = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptmaptypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptmaptypeGetRef]
        Decoders.addDecoder(clazz: [ConceptmaptypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptmaptypeGetRef]> in
            return Decoders.decode(clazz: [ConceptmaptypeGetRef].self, source: source)
        }

        // Decoder for ConceptmaptypeGetRef
        Decoders.addDecoder(clazz: ConceptmaptypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptmaptypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptmaptypeGetRef() : instance as! ConceptmaptypeGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptmaptypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptmaptypeUpdate]
        Decoders.addDecoder(clazz: [ConceptmaptypeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptmaptypeUpdate]> in
            return Decoders.decode(clazz: [ConceptmaptypeUpdate].self, source: source)
        }

        // Decoder for ConceptmaptypeUpdate
        Decoders.addDecoder(clazz: ConceptmaptypeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptmaptypeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptmaptypeUpdate() : instance as! ConceptmaptypeUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["isHidden"] as AnyObject?) {
                case let .success(value): _result.isHidden = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptmaptypeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptreferencetermCreate]
        Decoders.addDecoder(clazz: [ConceptreferencetermCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptreferencetermCreate]> in
            return Decoders.decode(clazz: [ConceptreferencetermCreate].self, source: source)
        }

        // Decoder for ConceptreferencetermCreate
        Decoders.addDecoder(clazz: ConceptreferencetermCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptreferencetermCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptreferencetermCreate() : instance as! ConceptreferencetermCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["code"] as AnyObject?) {
                case let .success(value): _result.code = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["conceptSource"] as AnyObject?) {
                case let .success(value): _result.conceptSource = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["version"] as AnyObject?) {
                case let .success(value): _result.version = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptreferencetermCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptreferencetermCreateFull]
        Decoders.addDecoder(clazz: [ConceptreferencetermCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptreferencetermCreateFull]> in
            return Decoders.decode(clazz: [ConceptreferencetermCreateFull].self, source: source)
        }

        // Decoder for ConceptreferencetermCreateFull
        Decoders.addDecoder(clazz: ConceptreferencetermCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptreferencetermCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptreferencetermCreateFull() : instance as! ConceptreferencetermCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["code"] as AnyObject?) {
                case let .success(value): _result.code = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["conceptSource"] as AnyObject?) {
                case let .success(value): _result.conceptSource = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["version"] as AnyObject?) {
                case let .success(value): _result.version = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptreferencetermCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptreferencetermGet]
        Decoders.addDecoder(clazz: [ConceptreferencetermGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptreferencetermGet]> in
            return Decoders.decode(clazz: [ConceptreferencetermGet].self, source: source)
        }

        // Decoder for ConceptreferencetermGet
        Decoders.addDecoder(clazz: ConceptreferencetermGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptreferencetermGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptreferencetermGet() : instance as! ConceptreferencetermGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["code"] as AnyObject?) {
                case let .success(value): _result.code = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["version"] as AnyObject?) {
                case let .success(value): _result.version = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptsourceGetRef.self, source: sourceDictionary["conceptSource"] as AnyObject?) {
                case let .success(value): _result.conceptSource = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptreferencetermGet", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptreferencetermGetFull]
        Decoders.addDecoder(clazz: [ConceptreferencetermGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptreferencetermGetFull]> in
            return Decoders.decode(clazz: [ConceptreferencetermGetFull].self, source: source)
        }

        // Decoder for ConceptreferencetermGetFull
        Decoders.addDecoder(clazz: ConceptreferencetermGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptreferencetermGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptreferencetermGetFull() : instance as! ConceptreferencetermGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["code"] as AnyObject?) {
                case let .success(value): _result.code = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["version"] as AnyObject?) {
                case let .success(value): _result.version = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptsourceGet.self, source: sourceDictionary["conceptSource"] as AnyObject?) {
                case let .success(value): _result.conceptSource = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptreferencetermGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptreferencetermGetRef]
        Decoders.addDecoder(clazz: [ConceptreferencetermGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptreferencetermGetRef]> in
            return Decoders.decode(clazz: [ConceptreferencetermGetRef].self, source: source)
        }

        // Decoder for ConceptreferencetermGetRef
        Decoders.addDecoder(clazz: ConceptreferencetermGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptreferencetermGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptreferencetermGetRef() : instance as! ConceptreferencetermGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptreferencetermGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptreferencetermUpdate]
        Decoders.addDecoder(clazz: [ConceptreferencetermUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptreferencetermUpdate]> in
            return Decoders.decode(clazz: [ConceptreferencetermUpdate].self, source: source)
        }

        // Decoder for ConceptreferencetermUpdate
        Decoders.addDecoder(clazz: ConceptreferencetermUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptreferencetermUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptreferencetermUpdate() : instance as! ConceptreferencetermUpdate
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptreferencetermUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptreferencetermmapCreate]
        Decoders.addDecoder(clazz: [ConceptreferencetermmapCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptreferencetermmapCreate]> in
            return Decoders.decode(clazz: [ConceptreferencetermmapCreate].self, source: source)
        }

        // Decoder for ConceptreferencetermmapCreate
        Decoders.addDecoder(clazz: ConceptreferencetermmapCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptreferencetermmapCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptreferencetermmapCreate() : instance as! ConceptreferencetermmapCreate
                switch Decoders.decodeOptional(clazz: ConceptreferencetermCreate.self, source: sourceDictionary["termA"] as AnyObject?) {
                case let .success(value): _result.termA = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptreferencetermCreate.self, source: sourceDictionary["termB"] as AnyObject?) {
                case let .success(value): _result.termB = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptmaptypeCreate.self, source: sourceDictionary["conceptMapType"] as AnyObject?) {
                case let .success(value): _result.conceptMapType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptreferencetermmapCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptreferencetermmapCreateFull]
        Decoders.addDecoder(clazz: [ConceptreferencetermmapCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptreferencetermmapCreateFull]> in
            return Decoders.decode(clazz: [ConceptreferencetermmapCreateFull].self, source: source)
        }

        // Decoder for ConceptreferencetermmapCreateFull
        Decoders.addDecoder(clazz: ConceptreferencetermmapCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptreferencetermmapCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptreferencetermmapCreateFull() : instance as! ConceptreferencetermmapCreateFull
                switch Decoders.decodeOptional(clazz: ConceptreferencetermCreate.self, source: sourceDictionary["termA"] as AnyObject?) {
                case let .success(value): _result.termA = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptreferencetermCreate.self, source: sourceDictionary["termB"] as AnyObject?) {
                case let .success(value): _result.termB = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptmaptypeCreate.self, source: sourceDictionary["conceptMapType"] as AnyObject?) {
                case let .success(value): _result.conceptMapType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptreferencetermmapCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptreferencetermmapGet]
        Decoders.addDecoder(clazz: [ConceptreferencetermmapGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptreferencetermmapGet]> in
            return Decoders.decode(clazz: [ConceptreferencetermmapGet].self, source: source)
        }

        // Decoder for ConceptreferencetermmapGet
        Decoders.addDecoder(clazz: ConceptreferencetermmapGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptreferencetermmapGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptreferencetermmapGet() : instance as! ConceptreferencetermmapGet
                switch Decoders.decodeOptional(clazz: ConceptreferencetermGetRef.self, source: sourceDictionary["termA"] as AnyObject?) {
                case let .success(value): _result.termA = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptreferencetermGetRef.self, source: sourceDictionary["termB"] as AnyObject?) {
                case let .success(value): _result.termB = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptmaptypeGetRef.self, source: sourceDictionary["conceptMapType"] as AnyObject?) {
                case let .success(value): _result.conceptMapType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptreferencetermmapGet", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptreferencetermmapGetFull]
        Decoders.addDecoder(clazz: [ConceptreferencetermmapGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptreferencetermmapGetFull]> in
            return Decoders.decode(clazz: [ConceptreferencetermmapGetFull].self, source: source)
        }

        // Decoder for ConceptreferencetermmapGetFull
        Decoders.addDecoder(clazz: ConceptreferencetermmapGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptreferencetermmapGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptreferencetermmapGetFull() : instance as! ConceptreferencetermmapGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptreferencetermGet.self, source: sourceDictionary["termA"] as AnyObject?) {
                case let .success(value): _result.termA = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptreferencetermGet.self, source: sourceDictionary["termB"] as AnyObject?) {
                case let .success(value): _result.termB = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptmaptypeGet.self, source: sourceDictionary["conceptMapType"] as AnyObject?) {
                case let .success(value): _result.conceptMapType = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptreferencetermmapGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptreferencetermmapGetRef]
        Decoders.addDecoder(clazz: [ConceptreferencetermmapGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptreferencetermmapGetRef]> in
            return Decoders.decode(clazz: [ConceptreferencetermmapGetRef].self, source: source)
        }

        // Decoder for ConceptreferencetermmapGetRef
        Decoders.addDecoder(clazz: ConceptreferencetermmapGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptreferencetermmapGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptreferencetermmapGetRef() : instance as! ConceptreferencetermmapGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptreferencetermmapGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptreferencetermmapUpdate]
        Decoders.addDecoder(clazz: [ConceptreferencetermmapUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptreferencetermmapUpdate]> in
            return Decoders.decode(clazz: [ConceptreferencetermmapUpdate].self, source: source)
        }

        // Decoder for ConceptreferencetermmapUpdate
        Decoders.addDecoder(clazz: ConceptreferencetermmapUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptreferencetermmapUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptreferencetermmapUpdate() : instance as! ConceptreferencetermmapUpdate
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptreferencetermmapUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptsourceCreate]
        Decoders.addDecoder(clazz: [ConceptsourceCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptsourceCreate]> in
            return Decoders.decode(clazz: [ConceptsourceCreate].self, source: source)
        }

        // Decoder for ConceptsourceCreate
        Decoders.addDecoder(clazz: ConceptsourceCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptsourceCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptsourceCreate() : instance as! ConceptsourceCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hl7Code"] as AnyObject?) {
                case let .success(value): _result.hl7Code = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uniqueId"] as AnyObject?) {
                case let .success(value): _result.uniqueId = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptsourceCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptsourceCreateFull]
        Decoders.addDecoder(clazz: [ConceptsourceCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptsourceCreateFull]> in
            return Decoders.decode(clazz: [ConceptsourceCreateFull].self, source: source)
        }

        // Decoder for ConceptsourceCreateFull
        Decoders.addDecoder(clazz: ConceptsourceCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptsourceCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptsourceCreateFull() : instance as! ConceptsourceCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hl7Code"] as AnyObject?) {
                case let .success(value): _result.hl7Code = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uniqueId"] as AnyObject?) {
                case let .success(value): _result.uniqueId = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptsourceCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptsourceGet]
        Decoders.addDecoder(clazz: [ConceptsourceGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptsourceGet]> in
            return Decoders.decode(clazz: [ConceptsourceGet].self, source: source)
        }

        // Decoder for ConceptsourceGet
        Decoders.addDecoder(clazz: ConceptsourceGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptsourceGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptsourceGet() : instance as! ConceptsourceGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hl7Code"] as AnyObject?) {
                case let .success(value): _result.hl7Code = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uniqueId"] as AnyObject?) {
                case let .success(value): _result.uniqueId = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptsourceGet", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptsourceGetFull]
        Decoders.addDecoder(clazz: [ConceptsourceGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptsourceGetFull]> in
            return Decoders.decode(clazz: [ConceptsourceGetFull].self, source: source)
        }

        // Decoder for ConceptsourceGetFull
        Decoders.addDecoder(clazz: ConceptsourceGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptsourceGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptsourceGetFull() : instance as! ConceptsourceGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hl7Code"] as AnyObject?) {
                case let .success(value): _result.hl7Code = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uniqueId"] as AnyObject?) {
                case let .success(value): _result.uniqueId = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptsourceGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptsourceGetRef]
        Decoders.addDecoder(clazz: [ConceptsourceGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptsourceGetRef]> in
            return Decoders.decode(clazz: [ConceptsourceGetRef].self, source: source)
        }

        // Decoder for ConceptsourceGetRef
        Decoders.addDecoder(clazz: ConceptsourceGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptsourceGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptsourceGetRef() : instance as! ConceptsourceGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hl7Code"] as AnyObject?) {
                case let .success(value): _result.hl7Code = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptsourceGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptsourceUpdate]
        Decoders.addDecoder(clazz: [ConceptsourceUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptsourceUpdate]> in
            return Decoders.decode(clazz: [ConceptsourceUpdate].self, source: source)
        }

        // Decoder for ConceptsourceUpdate
        Decoders.addDecoder(clazz: ConceptsourceUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptsourceUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptsourceUpdate() : instance as! ConceptsourceUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hl7Code"] as AnyObject?) {
                case let .success(value): _result.hl7Code = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uniqueId"] as AnyObject?) {
                case let .success(value): _result.uniqueId = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptsourceUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptstopwordCreate]
        Decoders.addDecoder(clazz: [ConceptstopwordCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptstopwordCreate]> in
            return Decoders.decode(clazz: [ConceptstopwordCreate].self, source: source)
        }

        // Decoder for ConceptstopwordCreate
        Decoders.addDecoder(clazz: ConceptstopwordCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptstopwordCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptstopwordCreate() : instance as! ConceptstopwordCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["locale"] as AnyObject?) {
                case let .success(value): _result.locale = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptstopwordCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptstopwordCreateFull]
        Decoders.addDecoder(clazz: [ConceptstopwordCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptstopwordCreateFull]> in
            return Decoders.decode(clazz: [ConceptstopwordCreateFull].self, source: source)
        }

        // Decoder for ConceptstopwordCreateFull
        Decoders.addDecoder(clazz: ConceptstopwordCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptstopwordCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptstopwordCreateFull() : instance as! ConceptstopwordCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["locale"] as AnyObject?) {
                case let .success(value): _result.locale = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptstopwordCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptstopwordGet]
        Decoders.addDecoder(clazz: [ConceptstopwordGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptstopwordGet]> in
            return Decoders.decode(clazz: [ConceptstopwordGet].self, source: source)
        }

        // Decoder for ConceptstopwordGet
        Decoders.addDecoder(clazz: ConceptstopwordGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptstopwordGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptstopwordGet() : instance as! ConceptstopwordGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["locale"] as AnyObject?) {
                case let .success(value): _result.locale = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptstopwordGet", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptstopwordGetFull]
        Decoders.addDecoder(clazz: [ConceptstopwordGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptstopwordGetFull]> in
            return Decoders.decode(clazz: [ConceptstopwordGetFull].self, source: source)
        }

        // Decoder for ConceptstopwordGetFull
        Decoders.addDecoder(clazz: ConceptstopwordGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptstopwordGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptstopwordGetFull() : instance as! ConceptstopwordGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["locale"] as AnyObject?) {
                case let .success(value): _result.locale = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptstopwordGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptstopwordGetRef]
        Decoders.addDecoder(clazz: [ConceptstopwordGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptstopwordGetRef]> in
            return Decoders.decode(clazz: [ConceptstopwordGetRef].self, source: source)
        }

        // Decoder for ConceptstopwordGetRef
        Decoders.addDecoder(clazz: ConceptstopwordGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptstopwordGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptstopwordGetRef() : instance as! ConceptstopwordGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptstopwordGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ConceptstopwordUpdate]
        Decoders.addDecoder(clazz: [ConceptstopwordUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ConceptstopwordUpdate]> in
            return Decoders.decode(clazz: [ConceptstopwordUpdate].self, source: source)
        }

        // Decoder for ConceptstopwordUpdate
        Decoders.addDecoder(clazz: ConceptstopwordUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConceptstopwordUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ConceptstopwordUpdate() : instance as! ConceptstopwordUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["locale"] as AnyObject?) {
                case let .success(value): _result.locale = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ConceptstopwordUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [CustomdatatypeGet]
        Decoders.addDecoder(clazz: [CustomdatatypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomdatatypeGet]> in
            return Decoders.decode(clazz: [CustomdatatypeGet].self, source: source)
        }

        // Decoder for CustomdatatypeGet
        Decoders.addDecoder(clazz: CustomdatatypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomdatatypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CustomdatatypeGet() : instance as! CustomdatatypeGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [CustomdatatypeHandlersGetRef].self, source: sourceDictionary["handlers"] as AnyObject?) {
                case let .success(value): _result.handlers = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomdatatypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [CustomdatatypeGetFull]
        Decoders.addDecoder(clazz: [CustomdatatypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomdatatypeGetFull]> in
            return Decoders.decode(clazz: [CustomdatatypeGetFull].self, source: source)
        }

        // Decoder for CustomdatatypeGetFull
        Decoders.addDecoder(clazz: CustomdatatypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomdatatypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CustomdatatypeGetFull() : instance as! CustomdatatypeGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [CustomdatatypeHandlersGet].self, source: sourceDictionary["handlers"] as AnyObject?) {
                case let .success(value): _result.handlers = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomdatatypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [CustomdatatypeGetRef]
        Decoders.addDecoder(clazz: [CustomdatatypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomdatatypeGetRef]> in
            return Decoders.decode(clazz: [CustomdatatypeGetRef].self, source: source)
        }

        // Decoder for CustomdatatypeGetRef
        Decoders.addDecoder(clazz: CustomdatatypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomdatatypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CustomdatatypeGetRef() : instance as! CustomdatatypeGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomdatatypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [CustomdatatypeHandlersGet]
        Decoders.addDecoder(clazz: [CustomdatatypeHandlersGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomdatatypeHandlersGet]> in
            return Decoders.decode(clazz: [CustomdatatypeHandlersGet].self, source: source)
        }

        // Decoder for CustomdatatypeHandlersGet
        Decoders.addDecoder(clazz: CustomdatatypeHandlersGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomdatatypeHandlersGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CustomdatatypeHandlersGet() : instance as! CustomdatatypeHandlersGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerClassname"] as AnyObject?) {
                case let .success(value): _result.handlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomdatatypeHandlersGet", actual: "\(source)"))
            }
        }
        // Decoder for [CustomdatatypeHandlersGetFull]
        Decoders.addDecoder(clazz: [CustomdatatypeHandlersGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomdatatypeHandlersGetFull]> in
            return Decoders.decode(clazz: [CustomdatatypeHandlersGetFull].self, source: source)
        }

        // Decoder for CustomdatatypeHandlersGetFull
        Decoders.addDecoder(clazz: CustomdatatypeHandlersGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomdatatypeHandlersGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CustomdatatypeHandlersGetFull() : instance as! CustomdatatypeHandlersGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerClassname"] as AnyObject?) {
                case let .success(value): _result.handlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomdatatypeHandlersGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [CustomdatatypeHandlersGetRef]
        Decoders.addDecoder(clazz: [CustomdatatypeHandlersGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomdatatypeHandlersGetRef]> in
            return Decoders.decode(clazz: [CustomdatatypeHandlersGetRef].self, source: source)
        }

        // Decoder for CustomdatatypeHandlersGetRef
        Decoders.addDecoder(clazz: CustomdatatypeHandlersGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomdatatypeHandlersGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CustomdatatypeHandlersGetRef() : instance as! CustomdatatypeHandlersGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomdatatypeHandlersGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [DrugCreate]
        Decoders.addDecoder(clazz: [DrugCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DrugCreate]> in
            return Decoders.decode(clazz: [DrugCreate].self, source: source)
        }

        // Decoder for DrugCreate
        Decoders.addDecoder(clazz: DrugCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DrugCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DrugCreate() : instance as! DrugCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["combination"] as AnyObject?) {
                case let .success(value): _result.combination = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["doseStrength"] as AnyObject?) {
                case let .success(value): _result.doseStrength = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["maximumDailyDose"] as AnyObject?) {
                case let .success(value): _result.maximumDailyDose = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["minimumDailyDose"] as AnyObject?) {
                case let .success(value): _result.minimumDailyDose = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["units"] as AnyObject?) {
                case let .success(value): _result.units = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["dosageForm"] as AnyObject?) {
                case let .success(value): _result.dosageForm = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["route"] as AnyObject?) {
                case let .success(value): _result.route = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DrugCreate", actual: "\(source)"))
            }
        }
        // Decoder for [DrugCreateFull]
        Decoders.addDecoder(clazz: [DrugCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DrugCreateFull]> in
            return Decoders.decode(clazz: [DrugCreateFull].self, source: source)
        }

        // Decoder for DrugCreateFull
        Decoders.addDecoder(clazz: DrugCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DrugCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DrugCreateFull() : instance as! DrugCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["combination"] as AnyObject?) {
                case let .success(value): _result.combination = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptCreate.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["doseStrength"] as AnyObject?) {
                case let .success(value): _result.doseStrength = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["maximumDailyDose"] as AnyObject?) {
                case let .success(value): _result.maximumDailyDose = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["minimumDailyDose"] as AnyObject?) {
                case let .success(value): _result.minimumDailyDose = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["units"] as AnyObject?) {
                case let .success(value): _result.units = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptCreate.self, source: sourceDictionary["dosageForm"] as AnyObject?) {
                case let .success(value): _result.dosageForm = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptCreate.self, source: sourceDictionary["route"] as AnyObject?) {
                case let .success(value): _result.route = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DrugCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [DrugGet]
        Decoders.addDecoder(clazz: [DrugGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DrugGet]> in
            return Decoders.decode(clazz: [DrugGet].self, source: source)
        }

        // Decoder for DrugGet
        Decoders.addDecoder(clazz: DrugGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DrugGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DrugGet() : instance as! DrugGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["doseStrength"] as AnyObject?) {
                case let .success(value): _result.doseStrength = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["maximumDailyDose"] as AnyObject?) {
                case let .success(value): _result.maximumDailyDose = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["minimumDailyDose"] as AnyObject?) {
                case let .success(value): _result.minimumDailyDose = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["units"] as AnyObject?) {
                case let .success(value): _result.units = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["combination"] as AnyObject?) {
                case let .success(value): _result.combination = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["dosageForm"] as AnyObject?) {
                case let .success(value): _result.dosageForm = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["route"] as AnyObject?) {
                case let .success(value): _result.route = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DrugGet", actual: "\(source)"))
            }
        }
        // Decoder for [DrugGetFull]
        Decoders.addDecoder(clazz: [DrugGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DrugGetFull]> in
            return Decoders.decode(clazz: [DrugGetFull].self, source: source)
        }

        // Decoder for DrugGetFull
        Decoders.addDecoder(clazz: DrugGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DrugGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DrugGetFull() : instance as! DrugGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["doseStrength"] as AnyObject?) {
                case let .success(value): _result.doseStrength = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["maximumDailyDose"] as AnyObject?) {
                case let .success(value): _result.maximumDailyDose = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["minimumDailyDose"] as AnyObject?) {
                case let .success(value): _result.minimumDailyDose = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["units"] as AnyObject?) {
                case let .success(value): _result.units = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["combination"] as AnyObject?) {
                case let .success(value): _result.combination = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["dosageForm"] as AnyObject?) {
                case let .success(value): _result.dosageForm = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["route"] as AnyObject?) {
                case let .success(value): _result.route = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DrugGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [DrugGetRef]
        Decoders.addDecoder(clazz: [DrugGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DrugGetRef]> in
            return Decoders.decode(clazz: [DrugGetRef].self, source: source)
        }

        // Decoder for DrugGetRef
        Decoders.addDecoder(clazz: DrugGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DrugGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DrugGetRef() : instance as! DrugGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DrugGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [DrugIngredientCreate]
        Decoders.addDecoder(clazz: [DrugIngredientCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DrugIngredientCreate]> in
            return Decoders.decode(clazz: [DrugIngredientCreate].self, source: source)
        }

        // Decoder for DrugIngredientCreate
        Decoders.addDecoder(clazz: DrugIngredientCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DrugIngredientCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DrugIngredientCreate() : instance as! DrugIngredientCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["ingredient"] as AnyObject?) {
                case let .success(value): _result.ingredient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["strength"] as AnyObject?) {
                case let .success(value): _result.strength = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["units"] as AnyObject?) {
                case let .success(value): _result.units = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DrugIngredientCreate", actual: "\(source)"))
            }
        }
        // Decoder for [DrugIngredientCreateFull]
        Decoders.addDecoder(clazz: [DrugIngredientCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DrugIngredientCreateFull]> in
            return Decoders.decode(clazz: [DrugIngredientCreateFull].self, source: source)
        }

        // Decoder for DrugIngredientCreateFull
        Decoders.addDecoder(clazz: DrugIngredientCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DrugIngredientCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DrugIngredientCreateFull() : instance as! DrugIngredientCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["ingredient"] as AnyObject?) {
                case let .success(value): _result.ingredient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["strength"] as AnyObject?) {
                case let .success(value): _result.strength = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["units"] as AnyObject?) {
                case let .success(value): _result.units = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DrugIngredientCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [DrugIngredientGet]
        Decoders.addDecoder(clazz: [DrugIngredientGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DrugIngredientGet]> in
            return Decoders.decode(clazz: [DrugIngredientGet].self, source: source)
        }

        // Decoder for DrugIngredientGet
        Decoders.addDecoder(clazz: DrugIngredientGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DrugIngredientGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DrugIngredientGet() : instance as! DrugIngredientGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["strength"] as AnyObject?) {
                case let .success(value): _result.strength = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["ingredient"] as AnyObject?) {
                case let .success(value): _result.ingredient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["units"] as AnyObject?) {
                case let .success(value): _result.units = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DrugIngredientGet", actual: "\(source)"))
            }
        }
        // Decoder for [DrugIngredientGetFull]
        Decoders.addDecoder(clazz: [DrugIngredientGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DrugIngredientGetFull]> in
            return Decoders.decode(clazz: [DrugIngredientGetFull].self, source: source)
        }

        // Decoder for DrugIngredientGetFull
        Decoders.addDecoder(clazz: DrugIngredientGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DrugIngredientGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DrugIngredientGetFull() : instance as! DrugIngredientGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["strength"] as AnyObject?) {
                case let .success(value): _result.strength = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["ingredient"] as AnyObject?) {
                case let .success(value): _result.ingredient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["units"] as AnyObject?) {
                case let .success(value): _result.units = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DrugIngredientGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [DrugIngredientGetRef]
        Decoders.addDecoder(clazz: [DrugIngredientGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DrugIngredientGetRef]> in
            return Decoders.decode(clazz: [DrugIngredientGetRef].self, source: source)
        }

        // Decoder for DrugIngredientGetRef
        Decoders.addDecoder(clazz: DrugIngredientGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DrugIngredientGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DrugIngredientGetRef() : instance as! DrugIngredientGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DrugIngredientGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [DrugIngredientUpdate]
        Decoders.addDecoder(clazz: [DrugIngredientUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DrugIngredientUpdate]> in
            return Decoders.decode(clazz: [DrugIngredientUpdate].self, source: source)
        }

        // Decoder for DrugIngredientUpdate
        Decoders.addDecoder(clazz: DrugIngredientUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DrugIngredientUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DrugIngredientUpdate() : instance as! DrugIngredientUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["ingredient"] as AnyObject?) {
                case let .success(value): _result.ingredient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["strength"] as AnyObject?) {
                case let .success(value): _result.strength = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["units"] as AnyObject?) {
                case let .success(value): _result.units = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DrugIngredientUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [DrugUpdate]
        Decoders.addDecoder(clazz: [DrugUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DrugUpdate]> in
            return Decoders.decode(clazz: [DrugUpdate].self, source: source)
        }

        // Decoder for DrugUpdate
        Decoders.addDecoder(clazz: DrugUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DrugUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DrugUpdate() : instance as! DrugUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["combination"] as AnyObject?) {
                case let .success(value): _result.combination = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["doseStrength"] as AnyObject?) {
                case let .success(value): _result.doseStrength = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["maximumDailyDose"] as AnyObject?) {
                case let .success(value): _result.maximumDailyDose = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["minimumDailyDose"] as AnyObject?) {
                case let .success(value): _result.minimumDailyDose = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["units"] as AnyObject?) {
                case let .success(value): _result.units = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["dosageForm"] as AnyObject?) {
                case let .success(value): _result.dosageForm = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["route"] as AnyObject?) {
                case let .success(value): _result.route = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DrugUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterCreate]
        Decoders.addDecoder(clazz: [EncounterCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterCreate]> in
            return Decoders.decode(clazz: [EncounterCreate].self, source: source)
        }

        // Decoder for EncounterCreate
        Decoders.addDecoder(clazz: EncounterCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EncounterCreate() : instance as! EncounterCreate
                switch Decoders.decodeOptional(clazz: PatientCreate.self, source: sourceDictionary["patient"] as AnyObject?) {
                case let .success(value): _result.patient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: EncountertypeCreate.self, source: sourceDictionary["encounterType"] as AnyObject?) {
                case let .success(value): _result.encounterType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["encounterDatetime"] as AnyObject?) {
                case let .success(value): _result.encounterDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationCreate.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FormCreate.self, source: sourceDictionary["form"] as AnyObject?) {
                case let .success(value): _result.form = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["provider"] as AnyObject?) {
                case let .success(value): _result.provider = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [OrderCreate].self, source: sourceDictionary["orders"] as AnyObject?) {
                case let .success(value): _result.orders = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ObsCreate].self, source: sourceDictionary["obs"] as AnyObject?) {
                case let .success(value): _result.obs = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterCreate", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterCreateFull]
        Decoders.addDecoder(clazz: [EncounterCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterCreateFull]> in
            return Decoders.decode(clazz: [EncounterCreateFull].self, source: source)
        }

        // Decoder for EncounterCreateFull
        Decoders.addDecoder(clazz: EncounterCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EncounterCreateFull() : instance as! EncounterCreateFull
                switch Decoders.decodeOptional(clazz: PatientCreate.self, source: sourceDictionary["patient"] as AnyObject?) {
                case let .success(value): _result.patient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: EncountertypeCreate.self, source: sourceDictionary["encounterType"] as AnyObject?) {
                case let .success(value): _result.encounterType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["encounterDatetime"] as AnyObject?) {
                case let .success(value): _result.encounterDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationCreate.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FormCreate.self, source: sourceDictionary["form"] as AnyObject?) {
                case let .success(value): _result.form = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["provider"] as AnyObject?) {
                case let .success(value): _result.provider = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [OrderCreate].self, source: sourceDictionary["orders"] as AnyObject?) {
                case let .success(value): _result.orders = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ObsCreate].self, source: sourceDictionary["obs"] as AnyObject?) {
                case let .success(value): _result.obs = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterEncounterproviderCreate]
        Decoders.addDecoder(clazz: [EncounterEncounterproviderCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterEncounterproviderCreate]> in
            return Decoders.decode(clazz: [EncounterEncounterproviderCreate].self, source: source)
        }

        // Decoder for EncounterEncounterproviderCreate
        Decoders.addDecoder(clazz: EncounterEncounterproviderCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterEncounterproviderCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EncounterEncounterproviderCreate() : instance as! EncounterEncounterproviderCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["provider"] as AnyObject?) {
                case let .success(value): _result.provider = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["encounterRole"] as AnyObject?) {
                case let .success(value): _result.encounterRole = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["encounter"] as AnyObject?) {
                case let .success(value): _result.encounter = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterEncounterproviderCreate", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterEncounterproviderCreateFull]
        Decoders.addDecoder(clazz: [EncounterEncounterproviderCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterEncounterproviderCreateFull]> in
            return Decoders.decode(clazz: [EncounterEncounterproviderCreateFull].self, source: source)
        }

        // Decoder for EncounterEncounterproviderCreateFull
        Decoders.addDecoder(clazz: EncounterEncounterproviderCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterEncounterproviderCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EncounterEncounterproviderCreateFull() : instance as! EncounterEncounterproviderCreateFull
                switch Decoders.decodeOptional(clazz: ProviderCreate.self, source: sourceDictionary["provider"] as AnyObject?) {
                case let .success(value): _result.provider = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: EncounterroleCreate.self, source: sourceDictionary["encounterRole"] as AnyObject?) {
                case let .success(value): _result.encounterRole = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: EncounterCreate.self, source: sourceDictionary["encounter"] as AnyObject?) {
                case let .success(value): _result.encounter = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterEncounterproviderCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterEncounterproviderGet]
        Decoders.addDecoder(clazz: [EncounterEncounterproviderGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterEncounterproviderGet]> in
            return Decoders.decode(clazz: [EncounterEncounterproviderGet].self, source: source)
        }

        // Decoder for EncounterEncounterproviderGet
        Decoders.addDecoder(clazz: EncounterEncounterproviderGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterEncounterproviderGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EncounterEncounterproviderGet() : instance as! EncounterEncounterproviderGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ProviderGetRef.self, source: sourceDictionary["provider"] as AnyObject?) {
                case let .success(value): _result.provider = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: EncounterroleGetRef.self, source: sourceDictionary["encounterRole"] as AnyObject?) {
                case let .success(value): _result.encounterRole = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterEncounterproviderGet", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterEncounterproviderGetFull]
        Decoders.addDecoder(clazz: [EncounterEncounterproviderGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterEncounterproviderGetFull]> in
            return Decoders.decode(clazz: [EncounterEncounterproviderGetFull].self, source: source)
        }

        // Decoder for EncounterEncounterproviderGetFull
        Decoders.addDecoder(clazz: EncounterEncounterproviderGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterEncounterproviderGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EncounterEncounterproviderGetFull() : instance as! EncounterEncounterproviderGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ProviderGet.self, source: sourceDictionary["provider"] as AnyObject?) {
                case let .success(value): _result.provider = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: EncounterroleGet.self, source: sourceDictionary["encounterRole"] as AnyObject?) {
                case let .success(value): _result.encounterRole = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterEncounterproviderGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterEncounterproviderGetRef]
        Decoders.addDecoder(clazz: [EncounterEncounterproviderGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterEncounterproviderGetRef]> in
            return Decoders.decode(clazz: [EncounterEncounterproviderGetRef].self, source: source)
        }

        // Decoder for EncounterEncounterproviderGetRef
        Decoders.addDecoder(clazz: EncounterEncounterproviderGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterEncounterproviderGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EncounterEncounterproviderGetRef() : instance as! EncounterEncounterproviderGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterEncounterproviderGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterEncounterproviderUpdate]
        Decoders.addDecoder(clazz: [EncounterEncounterproviderUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterEncounterproviderUpdate]> in
            return Decoders.decode(clazz: [EncounterEncounterproviderUpdate].self, source: source)
        }

        // Decoder for EncounterEncounterproviderUpdate
        Decoders.addDecoder(clazz: EncounterEncounterproviderUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterEncounterproviderUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EncounterEncounterproviderUpdate() : instance as! EncounterEncounterproviderUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["encounterRole"] as AnyObject?) {
                case let .success(value): _result.encounterRole = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["voidReason"] as AnyObject?) {
                case let .success(value): _result.voidReason = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterEncounterproviderUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterGet]
        Decoders.addDecoder(clazz: [EncounterGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterGet]> in
            return Decoders.decode(clazz: [EncounterGet].self, source: source)
        }

        // Decoder for EncounterGet
        Decoders.addDecoder(clazz: EncounterGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EncounterGet() : instance as! EncounterGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["encounterDatetime"] as AnyObject?) {
                case let .success(value): _result.encounterDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["provider"] as AnyObject?) {
                case let .success(value): _result.provider = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientGetRef.self, source: sourceDictionary["patient"] as AnyObject?) {
                case let .success(value): _result.patient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationGetRef.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FormGetRef.self, source: sourceDictionary["form"] as AnyObject?) {
                case let .success(value): _result.form = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: EncountertypeGetRef.self, source: sourceDictionary["encounterType"] as AnyObject?) {
                case let .success(value): _result.encounterType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ObsGetRef].self, source: sourceDictionary["obs"] as AnyObject?) {
                case let .success(value): _result.obs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [OrderGetRef].self, source: sourceDictionary["orders"] as AnyObject?) {
                case let .success(value): _result.orders = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterGet", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterGetFull]
        Decoders.addDecoder(clazz: [EncounterGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterGetFull]> in
            return Decoders.decode(clazz: [EncounterGetFull].self, source: source)
        }

        // Decoder for EncounterGetFull
        Decoders.addDecoder(clazz: EncounterGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EncounterGetFull() : instance as! EncounterGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["encounterDatetime"] as AnyObject?) {
                case let .success(value): _result.encounterDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["provider"] as AnyObject?) {
                case let .success(value): _result.provider = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientGet.self, source: sourceDictionary["patient"] as AnyObject?) {
                case let .success(value): _result.patient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationGet.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FormGet.self, source: sourceDictionary["form"] as AnyObject?) {
                case let .success(value): _result.form = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: EncountertypeGet.self, source: sourceDictionary["encounterType"] as AnyObject?) {
                case let .success(value): _result.encounterType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ObsGet].self, source: sourceDictionary["obs"] as AnyObject?) {
                case let .success(value): _result.obs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [OrderGet].self, source: sourceDictionary["orders"] as AnyObject?) {
                case let .success(value): _result.orders = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterGetRef]
        Decoders.addDecoder(clazz: [EncounterGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterGetRef]> in
            return Decoders.decode(clazz: [EncounterGetRef].self, source: source)
        }

        // Decoder for EncounterGetRef
        Decoders.addDecoder(clazz: EncounterGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EncounterGetRef() : instance as! EncounterGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterUpdate]
        Decoders.addDecoder(clazz: [EncounterUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterUpdate]> in
            return Decoders.decode(clazz: [EncounterUpdate].self, source: source)
        }

        // Decoder for EncounterUpdate
        Decoders.addDecoder(clazz: EncounterUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EncounterUpdate() : instance as! EncounterUpdate
                switch Decoders.decodeOptional(clazz: PatientCreate.self, source: sourceDictionary["patient"] as AnyObject?) {
                case let .success(value): _result.patient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: EncountertypeCreate.self, source: sourceDictionary["encounterType"] as AnyObject?) {
                case let .success(value): _result.encounterType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["encounterDatetime"] as AnyObject?) {
                case let .success(value): _result.encounterDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationCreate.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FormCreate.self, source: sourceDictionary["form"] as AnyObject?) {
                case let .success(value): _result.form = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["provider"] as AnyObject?) {
                case let .success(value): _result.provider = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [OrderCreate].self, source: sourceDictionary["orders"] as AnyObject?) {
                case let .success(value): _result.orders = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ObsCreate].self, source: sourceDictionary["obs"] as AnyObject?) {
                case let .success(value): _result.obs = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterroleCreate]
        Decoders.addDecoder(clazz: [EncounterroleCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterroleCreate]> in
            return Decoders.decode(clazz: [EncounterroleCreate].self, source: source)
        }

        // Decoder for EncounterroleCreate
        Decoders.addDecoder(clazz: EncounterroleCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterroleCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EncounterroleCreate() : instance as! EncounterroleCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterroleCreate", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterroleCreateFull]
        Decoders.addDecoder(clazz: [EncounterroleCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterroleCreateFull]> in
            return Decoders.decode(clazz: [EncounterroleCreateFull].self, source: source)
        }

        // Decoder for EncounterroleCreateFull
        Decoders.addDecoder(clazz: EncounterroleCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterroleCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EncounterroleCreateFull() : instance as! EncounterroleCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterroleCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterroleGet]
        Decoders.addDecoder(clazz: [EncounterroleGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterroleGet]> in
            return Decoders.decode(clazz: [EncounterroleGet].self, source: source)
        }

        // Decoder for EncounterroleGet
        Decoders.addDecoder(clazz: EncounterroleGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterroleGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EncounterroleGet() : instance as! EncounterroleGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterroleGet", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterroleGetFull]
        Decoders.addDecoder(clazz: [EncounterroleGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterroleGetFull]> in
            return Decoders.decode(clazz: [EncounterroleGetFull].self, source: source)
        }

        // Decoder for EncounterroleGetFull
        Decoders.addDecoder(clazz: EncounterroleGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterroleGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EncounterroleGetFull() : instance as! EncounterroleGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterroleGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterroleGetRef]
        Decoders.addDecoder(clazz: [EncounterroleGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterroleGetRef]> in
            return Decoders.decode(clazz: [EncounterroleGetRef].self, source: source)
        }

        // Decoder for EncounterroleGetRef
        Decoders.addDecoder(clazz: EncounterroleGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterroleGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EncounterroleGetRef() : instance as! EncounterroleGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterroleGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [EncounterroleUpdate]
        Decoders.addDecoder(clazz: [EncounterroleUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncounterroleUpdate]> in
            return Decoders.decode(clazz: [EncounterroleUpdate].self, source: source)
        }

        // Decoder for EncounterroleUpdate
        Decoders.addDecoder(clazz: EncounterroleUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncounterroleUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EncounterroleUpdate() : instance as! EncounterroleUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncounterroleUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [EncountertypeCreate]
        Decoders.addDecoder(clazz: [EncountertypeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncountertypeCreate]> in
            return Decoders.decode(clazz: [EncountertypeCreate].self, source: source)
        }

        // Decoder for EncountertypeCreate
        Decoders.addDecoder(clazz: EncountertypeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncountertypeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EncountertypeCreate() : instance as! EncountertypeCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncountertypeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [EncountertypeCreateFull]
        Decoders.addDecoder(clazz: [EncountertypeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncountertypeCreateFull]> in
            return Decoders.decode(clazz: [EncountertypeCreateFull].self, source: source)
        }

        // Decoder for EncountertypeCreateFull
        Decoders.addDecoder(clazz: EncountertypeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncountertypeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EncountertypeCreateFull() : instance as! EncountertypeCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncountertypeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [EncountertypeGet]
        Decoders.addDecoder(clazz: [EncountertypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncountertypeGet]> in
            return Decoders.decode(clazz: [EncountertypeGet].self, source: source)
        }

        // Decoder for EncountertypeGet
        Decoders.addDecoder(clazz: EncountertypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncountertypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EncountertypeGet() : instance as! EncountertypeGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncountertypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [EncountertypeGetFull]
        Decoders.addDecoder(clazz: [EncountertypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncountertypeGetFull]> in
            return Decoders.decode(clazz: [EncountertypeGetFull].self, source: source)
        }

        // Decoder for EncountertypeGetFull
        Decoders.addDecoder(clazz: EncountertypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncountertypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EncountertypeGetFull() : instance as! EncountertypeGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncountertypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [EncountertypeGetRef]
        Decoders.addDecoder(clazz: [EncountertypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncountertypeGetRef]> in
            return Decoders.decode(clazz: [EncountertypeGetRef].self, source: source)
        }

        // Decoder for EncountertypeGetRef
        Decoders.addDecoder(clazz: EncountertypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncountertypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EncountertypeGetRef() : instance as! EncountertypeGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncountertypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [EncountertypeUpdate]
        Decoders.addDecoder(clazz: [EncountertypeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EncountertypeUpdate]> in
            return Decoders.decode(clazz: [EncountertypeUpdate].self, source: source)
        }

        // Decoder for EncountertypeUpdate
        Decoders.addDecoder(clazz: EncountertypeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EncountertypeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EncountertypeUpdate() : instance as! EncountertypeUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EncountertypeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ExtensionGet]
        Decoders.addDecoder(clazz: [ExtensionGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ExtensionGet]> in
            return Decoders.decode(clazz: [ExtensionGet].self, source: source)
        }

        // Decoder for ExtensionGet
        Decoders.addDecoder(clazz: ExtensionGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ExtensionGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ExtensionGet() : instance as! ExtensionGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["appId"] as AnyObject?) {
                case let .success(value): _result.appId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["extensionPointId"] as AnyObject?) {
                case let .success(value): _result.extensionPointId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                case let .success(value): _result.type = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["label"] as AnyObject?) {
                case let .success(value): _result.label = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["url"] as AnyObject?) {
                case let .success(value): _result.url = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["icon"] as AnyObject?) {
                case let .success(value): _result.icon = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["order"] as AnyObject?) {
                case let .success(value): _result.order = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["requiredPrivilege"] as AnyObject?) {
                case let .success(value): _result.requiredPrivilege = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["featureToggle"] as AnyObject?) {
                case let .success(value): _result.featureToggle = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["require"] as AnyObject?) {
                case let .success(value): _result.require = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["script"] as AnyObject?) {
                case let .success(value): _result.script = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String:String].self, source: sourceDictionary["extensionParams"] as AnyObject?) {
                case let .success(value): _result.extensionParams = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: AppGetRef.self, source: sourceDictionary["belongsTo"] as AnyObject?) {
                case let .success(value): _result.belongsTo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ExtensionGet", actual: "\(source)"))
            }
        }
        // Decoder for [ExtensionGetFull]
        Decoders.addDecoder(clazz: [ExtensionGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ExtensionGetFull]> in
            return Decoders.decode(clazz: [ExtensionGetFull].self, source: source)
        }

        // Decoder for ExtensionGetFull
        Decoders.addDecoder(clazz: ExtensionGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ExtensionGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ExtensionGetFull() : instance as! ExtensionGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ExtensionGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ExtensionGetRef]
        Decoders.addDecoder(clazz: [ExtensionGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ExtensionGetRef]> in
            return Decoders.decode(clazz: [ExtensionGetRef].self, source: source)
        }

        // Decoder for ExtensionGetRef
        Decoders.addDecoder(clazz: ExtensionGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ExtensionGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ExtensionGetRef() : instance as! ExtensionGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ExtensionGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [FetchAll]
        Decoders.addDecoder(clazz: [FetchAll].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FetchAll]> in
            return Decoders.decode(clazz: [FetchAll].self, source: source)
        }

        // Decoder for FetchAll
        Decoders.addDecoder(clazz: FetchAll.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FetchAll> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FetchAll() : instance as! FetchAll
                switch Decoders.decodeOptional(clazz: [Any].self, source: sourceDictionary["results"] as AnyObject?) {
                case let .success(value): _result.results = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FetchAll", actual: "\(source)"))
            }
        }
        // Decoder for [FieldAnswerCreate]
        Decoders.addDecoder(clazz: [FieldAnswerCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldAnswerCreate]> in
            return Decoders.decode(clazz: [FieldAnswerCreate].self, source: source)
        }

        // Decoder for FieldAnswerCreate
        Decoders.addDecoder(clazz: FieldAnswerCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldAnswerCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FieldAnswerCreate() : instance as! FieldAnswerCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["field"] as AnyObject?) {
                case let .success(value): _result.field = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldAnswerCreate", actual: "\(source)"))
            }
        }
        // Decoder for [FieldAnswerCreateFull]
        Decoders.addDecoder(clazz: [FieldAnswerCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldAnswerCreateFull]> in
            return Decoders.decode(clazz: [FieldAnswerCreateFull].self, source: source)
        }

        // Decoder for FieldAnswerCreateFull
        Decoders.addDecoder(clazz: FieldAnswerCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldAnswerCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FieldAnswerCreateFull() : instance as! FieldAnswerCreateFull
                switch Decoders.decodeOptional(clazz: ConceptCreate.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FieldCreate.self, source: sourceDictionary["field"] as AnyObject?) {
                case let .success(value): _result.field = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldAnswerCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [FieldAnswerGet]
        Decoders.addDecoder(clazz: [FieldAnswerGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldAnswerGet]> in
            return Decoders.decode(clazz: [FieldAnswerGet].self, source: source)
        }

        // Decoder for FieldAnswerGet
        Decoders.addDecoder(clazz: FieldAnswerGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldAnswerGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FieldAnswerGet() : instance as! FieldAnswerGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FieldGetRef.self, source: sourceDictionary["field"] as AnyObject?) {
                case let .success(value): _result.field = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldAnswerGet", actual: "\(source)"))
            }
        }
        // Decoder for [FieldAnswerGetFull]
        Decoders.addDecoder(clazz: [FieldAnswerGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldAnswerGetFull]> in
            return Decoders.decode(clazz: [FieldAnswerGetFull].self, source: source)
        }

        // Decoder for FieldAnswerGetFull
        Decoders.addDecoder(clazz: FieldAnswerGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldAnswerGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FieldAnswerGetFull() : instance as! FieldAnswerGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FieldGet.self, source: sourceDictionary["field"] as AnyObject?) {
                case let .success(value): _result.field = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldAnswerGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [FieldAnswerGetRef]
        Decoders.addDecoder(clazz: [FieldAnswerGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldAnswerGetRef]> in
            return Decoders.decode(clazz: [FieldAnswerGetRef].self, source: source)
        }

        // Decoder for FieldAnswerGetRef
        Decoders.addDecoder(clazz: FieldAnswerGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldAnswerGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FieldAnswerGetRef() : instance as! FieldAnswerGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldAnswerGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [FieldAnswerUpdate]
        Decoders.addDecoder(clazz: [FieldAnswerUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldAnswerUpdate]> in
            return Decoders.decode(clazz: [FieldAnswerUpdate].self, source: source)
        }

        // Decoder for FieldAnswerUpdate
        Decoders.addDecoder(clazz: FieldAnswerUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldAnswerUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FieldAnswerUpdate() : instance as! FieldAnswerUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["field"] as AnyObject?) {
                case let .success(value): _result.field = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldAnswerUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [FieldCreate]
        Decoders.addDecoder(clazz: [FieldCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldCreate]> in
            return Decoders.decode(clazz: [FieldCreate].self, source: source)
        }

        // Decoder for FieldCreate
        Decoders.addDecoder(clazz: FieldCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FieldCreate() : instance as! FieldCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FieldtypeCreate.self, source: sourceDictionary["fieldType"] as AnyObject?) {
                case let .success(value): _result.fieldType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["selectMultiple"] as AnyObject?) {
                case let .success(value): _result.selectMultiple = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptCreate.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["tableName"] as AnyObject?) {
                case let .success(value): _result.tableName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeName"] as AnyObject?) {
                case let .success(value): _result.attributeName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["defaultValue"] as AnyObject?) {
                case let .success(value): _result.defaultValue = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldCreate", actual: "\(source)"))
            }
        }
        // Decoder for [FieldCreateFull]
        Decoders.addDecoder(clazz: [FieldCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldCreateFull]> in
            return Decoders.decode(clazz: [FieldCreateFull].self, source: source)
        }

        // Decoder for FieldCreateFull
        Decoders.addDecoder(clazz: FieldCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FieldCreateFull() : instance as! FieldCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FieldtypeCreate.self, source: sourceDictionary["fieldType"] as AnyObject?) {
                case let .success(value): _result.fieldType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["selectMultiple"] as AnyObject?) {
                case let .success(value): _result.selectMultiple = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptCreate.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["tableName"] as AnyObject?) {
                case let .success(value): _result.tableName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeName"] as AnyObject?) {
                case let .success(value): _result.attributeName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["defaultValue"] as AnyObject?) {
                case let .success(value): _result.defaultValue = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [FieldGet]
        Decoders.addDecoder(clazz: [FieldGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldGet]> in
            return Decoders.decode(clazz: [FieldGet].self, source: source)
        }

        // Decoder for FieldGet
        Decoders.addDecoder(clazz: FieldGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FieldGet() : instance as! FieldGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["tableName"] as AnyObject?) {
                case let .success(value): _result.tableName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeName"] as AnyObject?) {
                case let .success(value): _result.attributeName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["defaultValue"] as AnyObject?) {
                case let .success(value): _result.defaultValue = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["selectMultiple"] as AnyObject?) {
                case let .success(value): _result.selectMultiple = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FieldtypeGetRef.self, source: sourceDictionary["fieldType"] as AnyObject?) {
                case let .success(value): _result.fieldType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldGet", actual: "\(source)"))
            }
        }
        // Decoder for [FieldGetFull]
        Decoders.addDecoder(clazz: [FieldGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldGetFull]> in
            return Decoders.decode(clazz: [FieldGetFull].self, source: source)
        }

        // Decoder for FieldGetFull
        Decoders.addDecoder(clazz: FieldGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FieldGetFull() : instance as! FieldGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["tableName"] as AnyObject?) {
                case let .success(value): _result.tableName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeName"] as AnyObject?) {
                case let .success(value): _result.attributeName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["defaultValue"] as AnyObject?) {
                case let .success(value): _result.defaultValue = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["selectMultiple"] as AnyObject?) {
                case let .success(value): _result.selectMultiple = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FieldtypeGet.self, source: sourceDictionary["fieldType"] as AnyObject?) {
                case let .success(value): _result.fieldType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [FieldGetRef]
        Decoders.addDecoder(clazz: [FieldGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldGetRef]> in
            return Decoders.decode(clazz: [FieldGetRef].self, source: source)
        }

        // Decoder for FieldGetRef
        Decoders.addDecoder(clazz: FieldGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FieldGetRef() : instance as! FieldGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [FieldUpdate]
        Decoders.addDecoder(clazz: [FieldUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldUpdate]> in
            return Decoders.decode(clazz: [FieldUpdate].self, source: source)
        }

        // Decoder for FieldUpdate
        Decoders.addDecoder(clazz: FieldUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FieldUpdate() : instance as! FieldUpdate
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [FieldtypeCreate]
        Decoders.addDecoder(clazz: [FieldtypeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldtypeCreate]> in
            return Decoders.decode(clazz: [FieldtypeCreate].self, source: source)
        }

        // Decoder for FieldtypeCreate
        Decoders.addDecoder(clazz: FieldtypeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldtypeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FieldtypeCreate() : instance as! FieldtypeCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldtypeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [FieldtypeCreateFull]
        Decoders.addDecoder(clazz: [FieldtypeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldtypeCreateFull]> in
            return Decoders.decode(clazz: [FieldtypeCreateFull].self, source: source)
        }

        // Decoder for FieldtypeCreateFull
        Decoders.addDecoder(clazz: FieldtypeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldtypeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FieldtypeCreateFull() : instance as! FieldtypeCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldtypeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [FieldtypeGet]
        Decoders.addDecoder(clazz: [FieldtypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldtypeGet]> in
            return Decoders.decode(clazz: [FieldtypeGet].self, source: source)
        }

        // Decoder for FieldtypeGet
        Decoders.addDecoder(clazz: FieldtypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldtypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FieldtypeGet() : instance as! FieldtypeGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["isSet"] as AnyObject?) {
                case let .success(value): _result.isSet = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldtypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [FieldtypeGetFull]
        Decoders.addDecoder(clazz: [FieldtypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldtypeGetFull]> in
            return Decoders.decode(clazz: [FieldtypeGetFull].self, source: source)
        }

        // Decoder for FieldtypeGetFull
        Decoders.addDecoder(clazz: FieldtypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldtypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FieldtypeGetFull() : instance as! FieldtypeGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["isSet"] as AnyObject?) {
                case let .success(value): _result.isSet = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldtypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [FieldtypeGetRef]
        Decoders.addDecoder(clazz: [FieldtypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldtypeGetRef]> in
            return Decoders.decode(clazz: [FieldtypeGetRef].self, source: source)
        }

        // Decoder for FieldtypeGetRef
        Decoders.addDecoder(clazz: FieldtypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldtypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FieldtypeGetRef() : instance as! FieldtypeGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldtypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [FieldtypeUpdate]
        Decoders.addDecoder(clazz: [FieldtypeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldtypeUpdate]> in
            return Decoders.decode(clazz: [FieldtypeUpdate].self, source: source)
        }

        // Decoder for FieldtypeUpdate
        Decoders.addDecoder(clazz: FieldtypeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldtypeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FieldtypeUpdate() : instance as! FieldtypeUpdate
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldtypeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [FormCreate]
        Decoders.addDecoder(clazz: [FormCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormCreate]> in
            return Decoders.decode(clazz: [FormCreate].self, source: source)
        }

        // Decoder for FormCreate
        Decoders.addDecoder(clazz: FormCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FormCreate() : instance as! FormCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["version"] as AnyObject?) {
                case let .success(value): _result.version = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["encounterType"] as AnyObject?) {
                case let .success(value): _result.encounterType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["build"] as AnyObject?) {
                case let .success(value): _result.build = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["published"] as AnyObject?) {
                case let .success(value): _result.published = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["formFields"] as AnyObject?) {
                case let .success(value): _result.formFields = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["xslt"] as AnyObject?) {
                case let .success(value): _result.xslt = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["template"] as AnyObject?) {
                case let .success(value): _result.template = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormCreate", actual: "\(source)"))
            }
        }
        // Decoder for [FormCreateFull]
        Decoders.addDecoder(clazz: [FormCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormCreateFull]> in
            return Decoders.decode(clazz: [FormCreateFull].self, source: source)
        }

        // Decoder for FormCreateFull
        Decoders.addDecoder(clazz: FormCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FormCreateFull() : instance as! FormCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["version"] as AnyObject?) {
                case let .success(value): _result.version = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: EncountertypeCreate.self, source: sourceDictionary["encounterType"] as AnyObject?) {
                case let .success(value): _result.encounterType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["build"] as AnyObject?) {
                case let .success(value): _result.build = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["published"] as AnyObject?) {
                case let .success(value): _result.published = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [FormFormfieldCreate].self, source: sourceDictionary["formFields"] as AnyObject?) {
                case let .success(value): _result.formFields = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["xslt"] as AnyObject?) {
                case let .success(value): _result.xslt = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["template"] as AnyObject?) {
                case let .success(value): _result.template = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [FormFormfieldCreate]
        Decoders.addDecoder(clazz: [FormFormfieldCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormFormfieldCreate]> in
            return Decoders.decode(clazz: [FormFormfieldCreate].self, source: source)
        }

        // Decoder for FormFormfieldCreate
        Decoders.addDecoder(clazz: FormFormfieldCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormFormfieldCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FormFormfieldCreate() : instance as! FormFormfieldCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["form"] as AnyObject?) {
                case let .success(value): _result.form = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["field"] as AnyObject?) {
                case let .success(value): _result.field = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                case let .success(value): _result._required = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["parent"] as AnyObject?) {
                case let .success(value): _result.parent = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["fieldNumber"] as AnyObject?) {
                case let .success(value): _result.fieldNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fieldPart"] as AnyObject?) {
                case let .success(value): _result.fieldPart = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pageNumber"] as AnyObject?) {
                case let .success(value): _result.pageNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["sortWeight"] as AnyObject?) {
                case let .success(value): _result.sortWeight = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormFormfieldCreate", actual: "\(source)"))
            }
        }
        // Decoder for [FormFormfieldCreateFull]
        Decoders.addDecoder(clazz: [FormFormfieldCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormFormfieldCreateFull]> in
            return Decoders.decode(clazz: [FormFormfieldCreateFull].self, source: source)
        }

        // Decoder for FormFormfieldCreateFull
        Decoders.addDecoder(clazz: FormFormfieldCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormFormfieldCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FormFormfieldCreateFull() : instance as! FormFormfieldCreateFull
                switch Decoders.decodeOptional(clazz: FormCreate.self, source: sourceDictionary["form"] as AnyObject?) {
                case let .success(value): _result.form = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FieldCreate.self, source: sourceDictionary["field"] as AnyObject?) {
                case let .success(value): _result.field = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                case let .success(value): _result._required = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FormFormfieldCreate.self, source: sourceDictionary["parent"] as AnyObject?) {
                case let .success(value): _result.parent = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["fieldNumber"] as AnyObject?) {
                case let .success(value): _result.fieldNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fieldPart"] as AnyObject?) {
                case let .success(value): _result.fieldPart = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pageNumber"] as AnyObject?) {
                case let .success(value): _result.pageNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["sortWeight"] as AnyObject?) {
                case let .success(value): _result.sortWeight = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormFormfieldCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [FormFormfieldGet]
        Decoders.addDecoder(clazz: [FormFormfieldGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormFormfieldGet]> in
            return Decoders.decode(clazz: [FormFormfieldGet].self, source: source)
        }

        // Decoder for FormFormfieldGet
        Decoders.addDecoder(clazz: FormFormfieldGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormFormfieldGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FormFormfieldGet() : instance as! FormFormfieldGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["fieldNumber"] as AnyObject?) {
                case let .success(value): _result.fieldNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fieldPart"] as AnyObject?) {
                case let .success(value): _result.fieldPart = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pageNumber"] as AnyObject?) {
                case let .success(value): _result.pageNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                case let .success(value): _result._required = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["sortWeight"] as AnyObject?) {
                case let .success(value): _result.sortWeight = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FormFormfieldGetRef.self, source: sourceDictionary["parent"] as AnyObject?) {
                case let .success(value): _result.parent = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FormGetRef.self, source: sourceDictionary["form"] as AnyObject?) {
                case let .success(value): _result.form = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FieldGetRef.self, source: sourceDictionary["field"] as AnyObject?) {
                case let .success(value): _result.field = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormFormfieldGet", actual: "\(source)"))
            }
        }
        // Decoder for [FormFormfieldGetFull]
        Decoders.addDecoder(clazz: [FormFormfieldGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormFormfieldGetFull]> in
            return Decoders.decode(clazz: [FormFormfieldGetFull].self, source: source)
        }

        // Decoder for FormFormfieldGetFull
        Decoders.addDecoder(clazz: FormFormfieldGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormFormfieldGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FormFormfieldGetFull() : instance as! FormFormfieldGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["fieldNumber"] as AnyObject?) {
                case let .success(value): _result.fieldNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fieldPart"] as AnyObject?) {
                case let .success(value): _result.fieldPart = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pageNumber"] as AnyObject?) {
                case let .success(value): _result.pageNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                case let .success(value): _result._required = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["sortWeight"] as AnyObject?) {
                case let .success(value): _result.sortWeight = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FormFormfieldGet.self, source: sourceDictionary["parent"] as AnyObject?) {
                case let .success(value): _result.parent = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FormGet.self, source: sourceDictionary["form"] as AnyObject?) {
                case let .success(value): _result.form = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: FieldGet.self, source: sourceDictionary["field"] as AnyObject?) {
                case let .success(value): _result.field = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormFormfieldGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [FormFormfieldGetRef]
        Decoders.addDecoder(clazz: [FormFormfieldGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormFormfieldGetRef]> in
            return Decoders.decode(clazz: [FormFormfieldGetRef].self, source: source)
        }

        // Decoder for FormFormfieldGetRef
        Decoders.addDecoder(clazz: FormFormfieldGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormFormfieldGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FormFormfieldGetRef() : instance as! FormFormfieldGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormFormfieldGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [FormFormfieldUpdate]
        Decoders.addDecoder(clazz: [FormFormfieldUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormFormfieldUpdate]> in
            return Decoders.decode(clazz: [FormFormfieldUpdate].self, source: source)
        }

        // Decoder for FormFormfieldUpdate
        Decoders.addDecoder(clazz: FormFormfieldUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormFormfieldUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FormFormfieldUpdate() : instance as! FormFormfieldUpdate
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormFormfieldUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [FormGet]
        Decoders.addDecoder(clazz: [FormGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormGet]> in
            return Decoders.decode(clazz: [FormGet].self, source: source)
        }

        // Decoder for FormGet
        Decoders.addDecoder(clazz: FormGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FormGet() : instance as! FormGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["version"] as AnyObject?) {
                case let .success(value): _result.version = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["build"] as AnyObject?) {
                case let .success(value): _result.build = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["published"] as AnyObject?) {
                case let .success(value): _result.published = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: EncountertypeGetRef.self, source: sourceDictionary["encounterType"] as AnyObject?) {
                case let .success(value): _result.encounterType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [FormFormfieldGetRef].self, source: sourceDictionary["formFields"] as AnyObject?) {
                case let .success(value): _result.formFields = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormGet", actual: "\(source)"))
            }
        }
        // Decoder for [FormGetFull]
        Decoders.addDecoder(clazz: [FormGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormGetFull]> in
            return Decoders.decode(clazz: [FormGetFull].self, source: source)
        }

        // Decoder for FormGetFull
        Decoders.addDecoder(clazz: FormGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FormGetFull() : instance as! FormGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["version"] as AnyObject?) {
                case let .success(value): _result.version = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["build"] as AnyObject?) {
                case let .success(value): _result.build = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["published"] as AnyObject?) {
                case let .success(value): _result.published = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: EncountertypeGet.self, source: sourceDictionary["encounterType"] as AnyObject?) {
                case let .success(value): _result.encounterType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [FormFormfieldGet].self, source: sourceDictionary["formFields"] as AnyObject?) {
                case let .success(value): _result.formFields = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [FormGetRef]
        Decoders.addDecoder(clazz: [FormGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormGetRef]> in
            return Decoders.decode(clazz: [FormGetRef].self, source: source)
        }

        // Decoder for FormGetRef
        Decoders.addDecoder(clazz: FormGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FormGetRef() : instance as! FormGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [FormResourceCreate]
        Decoders.addDecoder(clazz: [FormResourceCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormResourceCreate]> in
            return Decoders.decode(clazz: [FormResourceCreate].self, source: source)
        }

        // Decoder for FormResourceCreate
        Decoders.addDecoder(clazz: FormResourceCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormResourceCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FormResourceCreate() : instance as! FormResourceCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["form"] as AnyObject?) {
                case let .success(value): _result.form = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["dataType"] as AnyObject?) {
                case let .success(value): _result.dataType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handler"] as AnyObject?) {
                case let .success(value): _result.handler = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["valueReference"] as AnyObject?) {
                case let .success(value): _result.valueReference = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormResourceCreate", actual: "\(source)"))
            }
        }
        // Decoder for [FormResourceCreateFull]
        Decoders.addDecoder(clazz: [FormResourceCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormResourceCreateFull]> in
            return Decoders.decode(clazz: [FormResourceCreateFull].self, source: source)
        }

        // Decoder for FormResourceCreateFull
        Decoders.addDecoder(clazz: FormResourceCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormResourceCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FormResourceCreateFull() : instance as! FormResourceCreateFull
                switch Decoders.decodeOptional(clazz: FormCreate.self, source: sourceDictionary["form"] as AnyObject?) {
                case let .success(value): _result.form = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["dataType"] as AnyObject?) {
                case let .success(value): _result.dataType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handler"] as AnyObject?) {
                case let .success(value): _result.handler = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["valueReference"] as AnyObject?) {
                case let .success(value): _result.valueReference = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormResourceCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [FormResourceGet]
        Decoders.addDecoder(clazz: [FormResourceGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormResourceGet]> in
            return Decoders.decode(clazz: [FormResourceGet].self, source: source)
        }

        // Decoder for FormResourceGet
        Decoders.addDecoder(clazz: FormResourceGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormResourceGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FormResourceGet() : instance as! FormResourceGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["valueReference"] as AnyObject?) {
                case let .success(value): _result.valueReference = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormResourceGet", actual: "\(source)"))
            }
        }
        // Decoder for [FormResourceGetFull]
        Decoders.addDecoder(clazz: [FormResourceGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormResourceGetFull]> in
            return Decoders.decode(clazz: [FormResourceGetFull].self, source: source)
        }

        // Decoder for FormResourceGetFull
        Decoders.addDecoder(clazz: FormResourceGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormResourceGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FormResourceGetFull() : instance as! FormResourceGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["valueReference"] as AnyObject?) {
                case let .success(value): _result.valueReference = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["dataType"] as AnyObject?) {
                case let .success(value): _result.dataType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handler"] as AnyObject?) {
                case let .success(value): _result.handler = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormResourceGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [FormResourceGetRef]
        Decoders.addDecoder(clazz: [FormResourceGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormResourceGetRef]> in
            return Decoders.decode(clazz: [FormResourceGetRef].self, source: source)
        }

        // Decoder for FormResourceGetRef
        Decoders.addDecoder(clazz: FormResourceGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormResourceGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FormResourceGetRef() : instance as! FormResourceGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormResourceGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [FormResourceUpdate]
        Decoders.addDecoder(clazz: [FormResourceUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormResourceUpdate]> in
            return Decoders.decode(clazz: [FormResourceUpdate].self, source: source)
        }

        // Decoder for FormResourceUpdate
        Decoders.addDecoder(clazz: FormResourceUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormResourceUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FormResourceUpdate() : instance as! FormResourceUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["form"] as AnyObject?) {
                case let .success(value): _result.form = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["dataType"] as AnyObject?) {
                case let .success(value): _result.dataType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handler"] as AnyObject?) {
                case let .success(value): _result.handler = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["valueReference"] as AnyObject?) {
                case let .success(value): _result.valueReference = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormResourceUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [FormUpdate]
        Decoders.addDecoder(clazz: [FormUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FormUpdate]> in
            return Decoders.decode(clazz: [FormUpdate].self, source: source)
        }

        // Decoder for FormUpdate
        Decoders.addDecoder(clazz: FormUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FormUpdate() : instance as! FormUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["version"] as AnyObject?) {
                case let .success(value): _result.version = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["encounterType"] as AnyObject?) {
                case let .success(value): _result.encounterType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["build"] as AnyObject?) {
                case let .success(value): _result.build = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["published"] as AnyObject?) {
                case let .success(value): _result.published = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["formFields"] as AnyObject?) {
                case let .success(value): _result.formFields = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["xslt"] as AnyObject?) {
                case let .success(value): _result.xslt = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["template"] as AnyObject?) {
                case let .success(value): _result.template = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FormUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [Hl7Create]
        Decoders.addDecoder(clazz: [Hl7Create].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Hl7Create]> in
            return Decoders.decode(clazz: [Hl7Create].self, source: source)
        }

        // Decoder for Hl7Create
        Decoders.addDecoder(clazz: Hl7Create.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Hl7Create> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Hl7Create() : instance as! Hl7Create
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hl7"] as AnyObject?) {
                case let .success(value): _result.hl7 = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Hl7Create", actual: "\(source)"))
            }
        }
        // Decoder for [Hl7CreateFull]
        Decoders.addDecoder(clazz: [Hl7CreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Hl7CreateFull]> in
            return Decoders.decode(clazz: [Hl7CreateFull].self, source: source)
        }

        // Decoder for Hl7CreateFull
        Decoders.addDecoder(clazz: Hl7CreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Hl7CreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Hl7CreateFull() : instance as! Hl7CreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hl7"] as AnyObject?) {
                case let .success(value): _result.hl7 = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Hl7CreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [Hl7sourceCreate]
        Decoders.addDecoder(clazz: [Hl7sourceCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Hl7sourceCreate]> in
            return Decoders.decode(clazz: [Hl7sourceCreate].self, source: source)
        }

        // Decoder for Hl7sourceCreate
        Decoders.addDecoder(clazz: Hl7sourceCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Hl7sourceCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Hl7sourceCreate() : instance as! Hl7sourceCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Hl7sourceCreate", actual: "\(source)"))
            }
        }
        // Decoder for [Hl7sourceCreateFull]
        Decoders.addDecoder(clazz: [Hl7sourceCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Hl7sourceCreateFull]> in
            return Decoders.decode(clazz: [Hl7sourceCreateFull].self, source: source)
        }

        // Decoder for Hl7sourceCreateFull
        Decoders.addDecoder(clazz: Hl7sourceCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Hl7sourceCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Hl7sourceCreateFull() : instance as! Hl7sourceCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Hl7sourceCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [Hl7sourceGet]
        Decoders.addDecoder(clazz: [Hl7sourceGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Hl7sourceGet]> in
            return Decoders.decode(clazz: [Hl7sourceGet].self, source: source)
        }

        // Decoder for Hl7sourceGet
        Decoders.addDecoder(clazz: Hl7sourceGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Hl7sourceGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Hl7sourceGet() : instance as! Hl7sourceGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Hl7sourceGet", actual: "\(source)"))
            }
        }
        // Decoder for [Hl7sourceGetFull]
        Decoders.addDecoder(clazz: [Hl7sourceGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Hl7sourceGetFull]> in
            return Decoders.decode(clazz: [Hl7sourceGetFull].self, source: source)
        }

        // Decoder for Hl7sourceGetFull
        Decoders.addDecoder(clazz: Hl7sourceGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Hl7sourceGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Hl7sourceGetFull() : instance as! Hl7sourceGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Hl7sourceGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [Hl7sourceGetRef]
        Decoders.addDecoder(clazz: [Hl7sourceGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Hl7sourceGetRef]> in
            return Decoders.decode(clazz: [Hl7sourceGetRef].self, source: source)
        }

        // Decoder for Hl7sourceGetRef
        Decoders.addDecoder(clazz: Hl7sourceGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Hl7sourceGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Hl7sourceGetRef() : instance as! Hl7sourceGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Hl7sourceGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [Hl7sourceUpdate]
        Decoders.addDecoder(clazz: [Hl7sourceUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Hl7sourceUpdate]> in
            return Decoders.decode(clazz: [Hl7sourceUpdate].self, source: source)
        }

        // Decoder for Hl7sourceUpdate
        Decoders.addDecoder(clazz: Hl7sourceUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Hl7sourceUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Hl7sourceUpdate() : instance as! Hl7sourceUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Hl7sourceUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [IdgenAutogenerationoptionGet]
        Decoders.addDecoder(clazz: [IdgenAutogenerationoptionGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[IdgenAutogenerationoptionGet]> in
            return Decoders.decode(clazz: [IdgenAutogenerationoptionGet].self, source: source)
        }

        // Decoder for IdgenAutogenerationoptionGet
        Decoders.addDecoder(clazz: IdgenAutogenerationoptionGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IdgenAutogenerationoptionGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? IdgenAutogenerationoptionGet() : instance as! IdgenAutogenerationoptionGet
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "IdgenAutogenerationoptionGet", actual: "\(source)"))
            }
        }
        // Decoder for [IdgenAutogenerationoptionGetFull]
        Decoders.addDecoder(clazz: [IdgenAutogenerationoptionGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[IdgenAutogenerationoptionGetFull]> in
            return Decoders.decode(clazz: [IdgenAutogenerationoptionGetFull].self, source: source)
        }

        // Decoder for IdgenAutogenerationoptionGetFull
        Decoders.addDecoder(clazz: IdgenAutogenerationoptionGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IdgenAutogenerationoptionGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? IdgenAutogenerationoptionGetFull() : instance as! IdgenAutogenerationoptionGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "IdgenAutogenerationoptionGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [IdgenAutogenerationoptionGetRef]
        Decoders.addDecoder(clazz: [IdgenAutogenerationoptionGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[IdgenAutogenerationoptionGetRef]> in
            return Decoders.decode(clazz: [IdgenAutogenerationoptionGetRef].self, source: source)
        }

        // Decoder for IdgenAutogenerationoptionGetRef
        Decoders.addDecoder(clazz: IdgenAutogenerationoptionGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IdgenAutogenerationoptionGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? IdgenAutogenerationoptionGetRef() : instance as! IdgenAutogenerationoptionGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "IdgenAutogenerationoptionGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [IdgenIdentifiersourceGet]
        Decoders.addDecoder(clazz: [IdgenIdentifiersourceGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[IdgenIdentifiersourceGet]> in
            return Decoders.decode(clazz: [IdgenIdentifiersourceGet].self, source: source)
        }

        // Decoder for IdgenIdentifiersourceGet
        Decoders.addDecoder(clazz: IdgenIdentifiersourceGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IdgenIdentifiersourceGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? IdgenIdentifiersourceGet() : instance as! IdgenIdentifiersourceGet
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "IdgenIdentifiersourceGet", actual: "\(source)"))
            }
        }
        // Decoder for [IdgenIdentifiersourceGetFull]
        Decoders.addDecoder(clazz: [IdgenIdentifiersourceGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[IdgenIdentifiersourceGetFull]> in
            return Decoders.decode(clazz: [IdgenIdentifiersourceGetFull].self, source: source)
        }

        // Decoder for IdgenIdentifiersourceGetFull
        Decoders.addDecoder(clazz: IdgenIdentifiersourceGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IdgenIdentifiersourceGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? IdgenIdentifiersourceGetFull() : instance as! IdgenIdentifiersourceGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "IdgenIdentifiersourceGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [IdgenIdentifiersourceGetRef]
        Decoders.addDecoder(clazz: [IdgenIdentifiersourceGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[IdgenIdentifiersourceGetRef]> in
            return Decoders.decode(clazz: [IdgenIdentifiersourceGetRef].self, source: source)
        }

        // Decoder for IdgenIdentifiersourceGetRef
        Decoders.addDecoder(clazz: IdgenIdentifiersourceGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IdgenIdentifiersourceGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? IdgenIdentifiersourceGetRef() : instance as! IdgenIdentifiersourceGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "IdgenIdentifiersourceGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [IdgenLogentryGet]
        Decoders.addDecoder(clazz: [IdgenLogentryGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[IdgenLogentryGet]> in
            return Decoders.decode(clazz: [IdgenLogentryGet].self, source: source)
        }

        // Decoder for IdgenLogentryGet
        Decoders.addDecoder(clazz: IdgenLogentryGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IdgenLogentryGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? IdgenLogentryGet() : instance as! IdgenLogentryGet
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "IdgenLogentryGet", actual: "\(source)"))
            }
        }
        // Decoder for [IdgenLogentryGetFull]
        Decoders.addDecoder(clazz: [IdgenLogentryGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[IdgenLogentryGetFull]> in
            return Decoders.decode(clazz: [IdgenLogentryGetFull].self, source: source)
        }

        // Decoder for IdgenLogentryGetFull
        Decoders.addDecoder(clazz: IdgenLogentryGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IdgenLogentryGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? IdgenLogentryGetFull() : instance as! IdgenLogentryGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "IdgenLogentryGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [IdgenLogentryGetRef]
        Decoders.addDecoder(clazz: [IdgenLogentryGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[IdgenLogentryGetRef]> in
            return Decoders.decode(clazz: [IdgenLogentryGetRef].self, source: source)
        }

        // Decoder for IdgenLogentryGetRef
        Decoders.addDecoder(clazz: IdgenLogentryGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IdgenLogentryGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? IdgenLogentryGetRef() : instance as! IdgenLogentryGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "IdgenLogentryGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [LocationAttributeCreate]
        Decoders.addDecoder(clazz: [LocationAttributeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationAttributeCreate]> in
            return Decoders.decode(clazz: [LocationAttributeCreate].self, source: source)
        }

        // Decoder for LocationAttributeCreate
        Decoders.addDecoder(clazz: LocationAttributeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationAttributeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? LocationAttributeCreate() : instance as! LocationAttributeCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationAttributeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [LocationAttributeCreateFull]
        Decoders.addDecoder(clazz: [LocationAttributeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationAttributeCreateFull]> in
            return Decoders.decode(clazz: [LocationAttributeCreateFull].self, source: source)
        }

        // Decoder for LocationAttributeCreateFull
        Decoders.addDecoder(clazz: LocationAttributeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationAttributeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? LocationAttributeCreateFull() : instance as! LocationAttributeCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationAttributeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [LocationAttributeGet]
        Decoders.addDecoder(clazz: [LocationAttributeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationAttributeGet]> in
            return Decoders.decode(clazz: [LocationAttributeGet].self, source: source)
        }

        // Decoder for LocationAttributeGet
        Decoders.addDecoder(clazz: LocationAttributeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationAttributeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? LocationAttributeGet() : instance as! LocationAttributeGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationAttributeGet", actual: "\(source)"))
            }
        }
        // Decoder for [LocationAttributeGetFull]
        Decoders.addDecoder(clazz: [LocationAttributeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationAttributeGetFull]> in
            return Decoders.decode(clazz: [LocationAttributeGetFull].self, source: source)
        }

        // Decoder for LocationAttributeGetFull
        Decoders.addDecoder(clazz: LocationAttributeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationAttributeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? LocationAttributeGetFull() : instance as! LocationAttributeGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationAttributeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [LocationAttributeGetRef]
        Decoders.addDecoder(clazz: [LocationAttributeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationAttributeGetRef]> in
            return Decoders.decode(clazz: [LocationAttributeGetRef].self, source: source)
        }

        // Decoder for LocationAttributeGetRef
        Decoders.addDecoder(clazz: LocationAttributeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationAttributeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? LocationAttributeGetRef() : instance as! LocationAttributeGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationAttributeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [LocationAttributeUpdate]
        Decoders.addDecoder(clazz: [LocationAttributeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationAttributeUpdate]> in
            return Decoders.decode(clazz: [LocationAttributeUpdate].self, source: source)
        }

        // Decoder for LocationAttributeUpdate
        Decoders.addDecoder(clazz: LocationAttributeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationAttributeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? LocationAttributeUpdate() : instance as! LocationAttributeUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationAttributeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [LocationCreate]
        Decoders.addDecoder(clazz: [LocationCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationCreate]> in
            return Decoders.decode(clazz: [LocationCreate].self, source: source)
        }

        // Decoder for LocationCreate
        Decoders.addDecoder(clazz: LocationCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? LocationCreate() : instance as! LocationCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address1"] as AnyObject?) {
                case let .success(value): _result.address1 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address2"] as AnyObject?) {
                case let .success(value): _result.address2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["cityVillage"] as AnyObject?) {
                case let .success(value): _result.cityVillage = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stateProvince"] as AnyObject?) {
                case let .success(value): _result.stateProvince = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country"] as AnyObject?) {
                case let .success(value): _result.country = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["postalCode"] as AnyObject?) {
                case let .success(value): _result.postalCode = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["latitude"] as AnyObject?) {
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["longitude"] as AnyObject?) {
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["countyDistrict"] as AnyObject?) {
                case let .success(value): _result.countyDistrict = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address3"] as AnyObject?) {
                case let .success(value): _result.address3 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address4"] as AnyObject?) {
                case let .success(value): _result.address4 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address5"] as AnyObject?) {
                case let .success(value): _result.address5 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address6"] as AnyObject?) {
                case let .success(value): _result.address6 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["tags"] as AnyObject?) {
                case let .success(value): _result.tags = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["parentLocation"] as AnyObject?) {
                case let .success(value): _result.parentLocation = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["childLocations"] as AnyObject?) {
                case let .success(value): _result.childLocations = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationCreate", actual: "\(source)"))
            }
        }
        // Decoder for [LocationCreateFull]
        Decoders.addDecoder(clazz: [LocationCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationCreateFull]> in
            return Decoders.decode(clazz: [LocationCreateFull].self, source: source)
        }

        // Decoder for LocationCreateFull
        Decoders.addDecoder(clazz: LocationCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? LocationCreateFull() : instance as! LocationCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address1"] as AnyObject?) {
                case let .success(value): _result.address1 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address2"] as AnyObject?) {
                case let .success(value): _result.address2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["cityVillage"] as AnyObject?) {
                case let .success(value): _result.cityVillage = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stateProvince"] as AnyObject?) {
                case let .success(value): _result.stateProvince = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country"] as AnyObject?) {
                case let .success(value): _result.country = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["postalCode"] as AnyObject?) {
                case let .success(value): _result.postalCode = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["latitude"] as AnyObject?) {
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["longitude"] as AnyObject?) {
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["countyDistrict"] as AnyObject?) {
                case let .success(value): _result.countyDistrict = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address3"] as AnyObject?) {
                case let .success(value): _result.address3 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address4"] as AnyObject?) {
                case let .success(value): _result.address4 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address5"] as AnyObject?) {
                case let .success(value): _result.address5 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address6"] as AnyObject?) {
                case let .success(value): _result.address6 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["tags"] as AnyObject?) {
                case let .success(value): _result.tags = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["parentLocation"] as AnyObject?) {
                case let .success(value): _result.parentLocation = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["childLocations"] as AnyObject?) {
                case let .success(value): _result.childLocations = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [LocationGet]
        Decoders.addDecoder(clazz: [LocationGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationGet]> in
            return Decoders.decode(clazz: [LocationGet].self, source: source)
        }

        // Decoder for LocationGet
        Decoders.addDecoder(clazz: LocationGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? LocationGet() : instance as! LocationGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address1"] as AnyObject?) {
                case let .success(value): _result.address1 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address2"] as AnyObject?) {
                case let .success(value): _result.address2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["cityVillage"] as AnyObject?) {
                case let .success(value): _result.cityVillage = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stateProvince"] as AnyObject?) {
                case let .success(value): _result.stateProvince = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country"] as AnyObject?) {
                case let .success(value): _result.country = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["postalCode"] as AnyObject?) {
                case let .success(value): _result.postalCode = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["latitude"] as AnyObject?) {
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["longitude"] as AnyObject?) {
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["countyDistrict"] as AnyObject?) {
                case let .success(value): _result.countyDistrict = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address3"] as AnyObject?) {
                case let .success(value): _result.address3 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address4"] as AnyObject?) {
                case let .success(value): _result.address4 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address5"] as AnyObject?) {
                case let .success(value): _result.address5 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address6"] as AnyObject?) {
                case let .success(value): _result.address6 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [LocationtagGetRef].self, source: sourceDictionary["tags"] as AnyObject?) {
                case let .success(value): _result.tags = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationGetRef.self, source: sourceDictionary["parentLocation"] as AnyObject?) {
                case let .success(value): _result.parentLocation = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [LocationGetRef].self, source: sourceDictionary["childLocations"] as AnyObject?) {
                case let .success(value): _result.childLocations = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationGet", actual: "\(source)"))
            }
        }
        // Decoder for [LocationGetFull]
        Decoders.addDecoder(clazz: [LocationGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationGetFull]> in
            return Decoders.decode(clazz: [LocationGetFull].self, source: source)
        }

        // Decoder for LocationGetFull
        Decoders.addDecoder(clazz: LocationGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? LocationGetFull() : instance as! LocationGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address1"] as AnyObject?) {
                case let .success(value): _result.address1 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address2"] as AnyObject?) {
                case let .success(value): _result.address2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["cityVillage"] as AnyObject?) {
                case let .success(value): _result.cityVillage = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stateProvince"] as AnyObject?) {
                case let .success(value): _result.stateProvince = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country"] as AnyObject?) {
                case let .success(value): _result.country = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["postalCode"] as AnyObject?) {
                case let .success(value): _result.postalCode = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["latitude"] as AnyObject?) {
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["longitude"] as AnyObject?) {
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["countyDistrict"] as AnyObject?) {
                case let .success(value): _result.countyDistrict = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address3"] as AnyObject?) {
                case let .success(value): _result.address3 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address4"] as AnyObject?) {
                case let .success(value): _result.address4 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address5"] as AnyObject?) {
                case let .success(value): _result.address5 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address6"] as AnyObject?) {
                case let .success(value): _result.address6 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [LocationtagGet].self, source: sourceDictionary["tags"] as AnyObject?) {
                case let .success(value): _result.tags = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationGet.self, source: sourceDictionary["parentLocation"] as AnyObject?) {
                case let .success(value): _result.parentLocation = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [LocationGet].self, source: sourceDictionary["childLocations"] as AnyObject?) {
                case let .success(value): _result.childLocations = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [LocationGetRef]
        Decoders.addDecoder(clazz: [LocationGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationGetRef]> in
            return Decoders.decode(clazz: [LocationGetRef].self, source: source)
        }

        // Decoder for LocationGetRef
        Decoders.addDecoder(clazz: LocationGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? LocationGetRef() : instance as! LocationGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [LocationUpdate]
        Decoders.addDecoder(clazz: [LocationUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationUpdate]> in
            return Decoders.decode(clazz: [LocationUpdate].self, source: source)
        }

        // Decoder for LocationUpdate
        Decoders.addDecoder(clazz: LocationUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? LocationUpdate() : instance as! LocationUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address1"] as AnyObject?) {
                case let .success(value): _result.address1 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address2"] as AnyObject?) {
                case let .success(value): _result.address2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["cityVillage"] as AnyObject?) {
                case let .success(value): _result.cityVillage = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stateProvince"] as AnyObject?) {
                case let .success(value): _result.stateProvince = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country"] as AnyObject?) {
                case let .success(value): _result.country = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["postalCode"] as AnyObject?) {
                case let .success(value): _result.postalCode = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["latitude"] as AnyObject?) {
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["longitude"] as AnyObject?) {
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["countyDistrict"] as AnyObject?) {
                case let .success(value): _result.countyDistrict = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address3"] as AnyObject?) {
                case let .success(value): _result.address3 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address4"] as AnyObject?) {
                case let .success(value): _result.address4 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address5"] as AnyObject?) {
                case let .success(value): _result.address5 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address6"] as AnyObject?) {
                case let .success(value): _result.address6 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["tags"] as AnyObject?) {
                case let .success(value): _result.tags = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["parentLocation"] as AnyObject?) {
                case let .success(value): _result.parentLocation = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["childLocations"] as AnyObject?) {
                case let .success(value): _result.childLocations = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [LocationattributetypeCreate]
        Decoders.addDecoder(clazz: [LocationattributetypeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationattributetypeCreate]> in
            return Decoders.decode(clazz: [LocationattributetypeCreate].self, source: source)
        }

        // Decoder for LocationattributetypeCreate
        Decoders.addDecoder(clazz: LocationattributetypeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationattributetypeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? LocationattributetypeCreate() : instance as! LocationattributetypeCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationattributetypeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [LocationattributetypeCreateFull]
        Decoders.addDecoder(clazz: [LocationattributetypeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationattributetypeCreateFull]> in
            return Decoders.decode(clazz: [LocationattributetypeCreateFull].self, source: source)
        }

        // Decoder for LocationattributetypeCreateFull
        Decoders.addDecoder(clazz: LocationattributetypeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationattributetypeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? LocationattributetypeCreateFull() : instance as! LocationattributetypeCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationattributetypeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [LocationattributetypeGet]
        Decoders.addDecoder(clazz: [LocationattributetypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationattributetypeGet]> in
            return Decoders.decode(clazz: [LocationattributetypeGet].self, source: source)
        }

        // Decoder for LocationattributetypeGet
        Decoders.addDecoder(clazz: LocationattributetypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationattributetypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? LocationattributetypeGet() : instance as! LocationattributetypeGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationattributetypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [LocationattributetypeGetFull]
        Decoders.addDecoder(clazz: [LocationattributetypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationattributetypeGetFull]> in
            return Decoders.decode(clazz: [LocationattributetypeGetFull].self, source: source)
        }

        // Decoder for LocationattributetypeGetFull
        Decoders.addDecoder(clazz: LocationattributetypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationattributetypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? LocationattributetypeGetFull() : instance as! LocationattributetypeGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationattributetypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [LocationattributetypeGetRef]
        Decoders.addDecoder(clazz: [LocationattributetypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationattributetypeGetRef]> in
            return Decoders.decode(clazz: [LocationattributetypeGetRef].self, source: source)
        }

        // Decoder for LocationattributetypeGetRef
        Decoders.addDecoder(clazz: LocationattributetypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationattributetypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? LocationattributetypeGetRef() : instance as! LocationattributetypeGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationattributetypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [LocationattributetypeUpdate]
        Decoders.addDecoder(clazz: [LocationattributetypeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationattributetypeUpdate]> in
            return Decoders.decode(clazz: [LocationattributetypeUpdate].self, source: source)
        }

        // Decoder for LocationattributetypeUpdate
        Decoders.addDecoder(clazz: LocationattributetypeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationattributetypeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? LocationattributetypeUpdate() : instance as! LocationattributetypeUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationattributetypeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [LocationtagCreate]
        Decoders.addDecoder(clazz: [LocationtagCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationtagCreate]> in
            return Decoders.decode(clazz: [LocationtagCreate].self, source: source)
        }

        // Decoder for LocationtagCreate
        Decoders.addDecoder(clazz: LocationtagCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationtagCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? LocationtagCreate() : instance as! LocationtagCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["retiredReason"] as AnyObject?) {
                case let .success(value): _result.retiredReason = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationtagCreate", actual: "\(source)"))
            }
        }
        // Decoder for [LocationtagCreateFull]
        Decoders.addDecoder(clazz: [LocationtagCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationtagCreateFull]> in
            return Decoders.decode(clazz: [LocationtagCreateFull].self, source: source)
        }

        // Decoder for LocationtagCreateFull
        Decoders.addDecoder(clazz: LocationtagCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationtagCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? LocationtagCreateFull() : instance as! LocationtagCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["retiredReason"] as AnyObject?) {
                case let .success(value): _result.retiredReason = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationtagCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [LocationtagGet]
        Decoders.addDecoder(clazz: [LocationtagGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationtagGet]> in
            return Decoders.decode(clazz: [LocationtagGet].self, source: source)
        }

        // Decoder for LocationtagGet
        Decoders.addDecoder(clazz: LocationtagGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationtagGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? LocationtagGet() : instance as! LocationtagGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationtagGet", actual: "\(source)"))
            }
        }
        // Decoder for [LocationtagGetFull]
        Decoders.addDecoder(clazz: [LocationtagGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationtagGetFull]> in
            return Decoders.decode(clazz: [LocationtagGetFull].self, source: source)
        }

        // Decoder for LocationtagGetFull
        Decoders.addDecoder(clazz: LocationtagGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationtagGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? LocationtagGetFull() : instance as! LocationtagGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationtagGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [LocationtagGetRef]
        Decoders.addDecoder(clazz: [LocationtagGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationtagGetRef]> in
            return Decoders.decode(clazz: [LocationtagGetRef].self, source: source)
        }

        // Decoder for LocationtagGetRef
        Decoders.addDecoder(clazz: LocationtagGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationtagGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? LocationtagGetRef() : instance as! LocationtagGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationtagGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [LocationtagUpdate]
        Decoders.addDecoder(clazz: [LocationtagUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[LocationtagUpdate]> in
            return Decoders.decode(clazz: [LocationtagUpdate].self, source: source)
        }

        // Decoder for LocationtagUpdate
        Decoders.addDecoder(clazz: LocationtagUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationtagUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? LocationtagUpdate() : instance as! LocationtagUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["retiredReason"] as AnyObject?) {
                case let .success(value): _result.retiredReason = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "LocationtagUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ModuleGet]
        Decoders.addDecoder(clazz: [ModuleGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ModuleGet]> in
            return Decoders.decode(clazz: [ModuleGet].self, source: source)
        }

        // Decoder for ModuleGet
        Decoders.addDecoder(clazz: ModuleGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ModuleGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ModuleGet() : instance as! ModuleGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["started"] as AnyObject?) {
                case let .success(value): _result.started = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["startupErrorMessage"] as AnyObject?) {
                case let .success(value): _result.startupErrorMessage = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ModuleGet", actual: "\(source)"))
            }
        }
        // Decoder for [ModuleGetFull]
        Decoders.addDecoder(clazz: [ModuleGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ModuleGetFull]> in
            return Decoders.decode(clazz: [ModuleGetFull].self, source: source)
        }

        // Decoder for ModuleGetFull
        Decoders.addDecoder(clazz: ModuleGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ModuleGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ModuleGetFull() : instance as! ModuleGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["started"] as AnyObject?) {
                case let .success(value): _result.started = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["startupErrorMessage"] as AnyObject?) {
                case let .success(value): _result.startupErrorMessage = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["packageName"] as AnyObject?) {
                case let .success(value): _result.packageName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["author"] as AnyObject?) {
                case let .success(value): _result.author = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["version"] as AnyObject?) {
                case let .success(value): _result.version = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["requireOpenmrsVersion"] as AnyObject?) {
                case let .success(value): _result.requireOpenmrsVersion = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["awareOfModules"] as AnyObject?) {
                case let .success(value): _result.awareOfModules = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["requiredModules"] as AnyObject?) {
                case let .success(value): _result.requiredModules = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ModuleGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ModuleGetRef]
        Decoders.addDecoder(clazz: [ModuleGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ModuleGetRef]> in
            return Decoders.decode(clazz: [ModuleGetRef].self, source: source)
        }

        // Decoder for ModuleGetRef
        Decoders.addDecoder(clazz: ModuleGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ModuleGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ModuleGetRef() : instance as! ModuleGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ModuleGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ModuleactionCreate]
        Decoders.addDecoder(clazz: [ModuleactionCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ModuleactionCreate]> in
            return Decoders.decode(clazz: [ModuleactionCreate].self, source: source)
        }

        // Decoder for ModuleactionCreate
        Decoders.addDecoder(clazz: ModuleactionCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ModuleactionCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ModuleactionCreate() : instance as! ModuleactionCreate
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["modules"] as AnyObject?) {
                case let .success(value): _result.modules = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["allModules"] as AnyObject?) {
                case let .success(value): _result.allModules = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ModuleactionCreate.Action.self, source: sourceDictionary["action"] as AnyObject?) {
                case let .success(value): _result.action = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["installUri"] as AnyObject?) {
                case let .success(value): _result.installUri = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ModuleactionCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ModuleactionCreateFull]
        Decoders.addDecoder(clazz: [ModuleactionCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ModuleactionCreateFull]> in
            return Decoders.decode(clazz: [ModuleactionCreateFull].self, source: source)
        }

        // Decoder for ModuleactionCreateFull
        Decoders.addDecoder(clazz: ModuleactionCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ModuleactionCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ModuleactionCreateFull() : instance as! ModuleactionCreateFull
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["modules"] as AnyObject?) {
                case let .success(value): _result.modules = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["allModules"] as AnyObject?) {
                case let .success(value): _result.allModules = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ModuleactionCreateFull.Action.self, source: sourceDictionary["action"] as AnyObject?) {
                case let .success(value): _result.action = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["installUri"] as AnyObject?) {
                case let .success(value): _result.installUri = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ModuleactionCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ObsCreate]
        Decoders.addDecoder(clazz: [ObsCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ObsCreate]> in
            return Decoders.decode(clazz: [ObsCreate].self, source: source)
        }

        // Decoder for ObsCreate
        Decoders.addDecoder(clazz: ObsCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ObsCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ObsCreate() : instance as! ObsCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["person"] as AnyObject?) {
                case let .success(value): _result.person = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["obsDatetime"] as AnyObject?) {
                case let .success(value): _result.obsDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["order"] as AnyObject?) {
                case let .success(value): _result.order = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["encounter"] as AnyObject?) {
                case let .success(value): _result.encounter = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["accessionNumber"] as AnyObject?) {
                case let .success(value): _result.accessionNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["groupMembers"] as AnyObject?) {
                case let .success(value): _result.groupMembers = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["valueCodedName"] as AnyObject?) {
                case let .success(value): _result.valueCodedName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["comment"] as AnyObject?) {
                case let .success(value): _result.comment = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["valueModifier"] as AnyObject?) {
                case let .success(value): _result.valueModifier = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formFieldPath"] as AnyObject?) {
                case let .success(value): _result.formFieldPath = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formFieldNamespace"] as AnyObject?) {
                case let .success(value): _result.formFieldNamespace = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ObsCreate.Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ObsCreate.Interpretation.self, source: sourceDictionary["interpretation"] as AnyObject?) {
                case let .success(value): _result.interpretation = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ObsCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ObsCreateFull]
        Decoders.addDecoder(clazz: [ObsCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ObsCreateFull]> in
            return Decoders.decode(clazz: [ObsCreateFull].self, source: source)
        }

        // Decoder for ObsCreateFull
        Decoders.addDecoder(clazz: ObsCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ObsCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ObsCreateFull() : instance as! ObsCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["person"] as AnyObject?) {
                case let .success(value): _result.person = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["obsDatetime"] as AnyObject?) {
                case let .success(value): _result.obsDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["order"] as AnyObject?) {
                case let .success(value): _result.order = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["encounter"] as AnyObject?) {
                case let .success(value): _result.encounter = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["accessionNumber"] as AnyObject?) {
                case let .success(value): _result.accessionNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["groupMembers"] as AnyObject?) {
                case let .success(value): _result.groupMembers = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["valueCodedName"] as AnyObject?) {
                case let .success(value): _result.valueCodedName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["comment"] as AnyObject?) {
                case let .success(value): _result.comment = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["valueModifier"] as AnyObject?) {
                case let .success(value): _result.valueModifier = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formFieldPath"] as AnyObject?) {
                case let .success(value): _result.formFieldPath = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formFieldNamespace"] as AnyObject?) {
                case let .success(value): _result.formFieldNamespace = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ObsCreateFull.Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ObsCreateFull.Interpretation.self, source: sourceDictionary["interpretation"] as AnyObject?) {
                case let .success(value): _result.interpretation = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ObsCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ObsGet]
        Decoders.addDecoder(clazz: [ObsGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ObsGet]> in
            return Decoders.decode(clazz: [ObsGet].self, source: source)
        }

        // Decoder for ObsGet
        Decoders.addDecoder(clazz: ObsGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ObsGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ObsGet() : instance as! ObsGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["obsDatetime"] as AnyObject?) {
                case let .success(value): _result.obsDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["accessionNumber"] as AnyObject?) {
                case let .success(value): _result.accessionNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["comment"] as AnyObject?) {
                case let .success(value): _result.comment = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["valueModifier"] as AnyObject?) {
                case let .success(value): _result.valueModifier = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonGetRef.self, source: sourceDictionary["person"] as AnyObject?) {
                case let .success(value): _result.person = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ObsGetRef.self, source: sourceDictionary["obsGroup"] as AnyObject?) {
                case let .success(value): _result.obsGroup = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ObsGetRef].self, source: sourceDictionary["groupMembers"] as AnyObject?) {
                case let .success(value): _result.groupMembers = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptNameGetRef.self, source: sourceDictionary["valueCodedName"] as AnyObject?) {
                case let .success(value): _result.valueCodedName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationGetRef.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrderGetRef.self, source: sourceDictionary["order"] as AnyObject?) {
                case let .success(value): _result.order = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: EncounterGetRef.self, source: sourceDictionary["encounter"] as AnyObject?) {
                case let .success(value): _result.encounter = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formFieldPath"] as AnyObject?) {
                case let .success(value): _result.formFieldPath = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formFieldNamespace"] as AnyObject?) {
                case let .success(value): _result.formFieldNamespace = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ObsGet.Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ObsGet.Interpretation.self, source: sourceDictionary["interpretation"] as AnyObject?) {
                case let .success(value): _result.interpretation = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ObsGet", actual: "\(source)"))
            }
        }
        // Decoder for [ObsGetFull]
        Decoders.addDecoder(clazz: [ObsGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ObsGetFull]> in
            return Decoders.decode(clazz: [ObsGetFull].self, source: source)
        }

        // Decoder for ObsGetFull
        Decoders.addDecoder(clazz: ObsGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ObsGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ObsGetFull() : instance as! ObsGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["obsDatetime"] as AnyObject?) {
                case let .success(value): _result.obsDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["accessionNumber"] as AnyObject?) {
                case let .success(value): _result.accessionNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["comment"] as AnyObject?) {
                case let .success(value): _result.comment = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["valueModifier"] as AnyObject?) {
                case let .success(value): _result.valueModifier = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonGet.self, source: sourceDictionary["person"] as AnyObject?) {
                case let .success(value): _result.person = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ObsGet.self, source: sourceDictionary["obsGroup"] as AnyObject?) {
                case let .success(value): _result.obsGroup = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ObsGet].self, source: sourceDictionary["groupMembers"] as AnyObject?) {
                case let .success(value): _result.groupMembers = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptNameGet.self, source: sourceDictionary["valueCodedName"] as AnyObject?) {
                case let .success(value): _result.valueCodedName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationGet.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrderGet.self, source: sourceDictionary["order"] as AnyObject?) {
                case let .success(value): _result.order = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: EncounterGet.self, source: sourceDictionary["encounter"] as AnyObject?) {
                case let .success(value): _result.encounter = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formFieldPath"] as AnyObject?) {
                case let .success(value): _result.formFieldPath = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formFieldNamespace"] as AnyObject?) {
                case let .success(value): _result.formFieldNamespace = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ObsGetFull.Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ObsGetFull.Interpretation.self, source: sourceDictionary["interpretation"] as AnyObject?) {
                case let .success(value): _result.interpretation = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ObsGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ObsGetRef]
        Decoders.addDecoder(clazz: [ObsGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ObsGetRef]> in
            return Decoders.decode(clazz: [ObsGetRef].self, source: source)
        }

        // Decoder for ObsGetRef
        Decoders.addDecoder(clazz: ObsGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ObsGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ObsGetRef() : instance as! ObsGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formFieldPath"] as AnyObject?) {
                case let .success(value): _result.formFieldPath = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formFieldNamespace"] as AnyObject?) {
                case let .success(value): _result.formFieldNamespace = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ObsGetRef.Status.self, source: sourceDictionary["status"] as AnyObject?) {
                case let .success(value): _result.status = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ObsGetRef.Interpretation.self, source: sourceDictionary["interpretation"] as AnyObject?) {
                case let .success(value): _result.interpretation = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ObsGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ObsUpdate]
        Decoders.addDecoder(clazz: [ObsUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ObsUpdate]> in
            return Decoders.decode(clazz: [ObsUpdate].self, source: source)
        }

        // Decoder for ObsUpdate
        Decoders.addDecoder(clazz: ObsUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ObsUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ObsUpdate() : instance as! ObsUpdate
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ObsUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [OrderCreate]
        Decoders.addDecoder(clazz: [OrderCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrderCreate]> in
            return Decoders.decode(clazz: [OrderCreate].self, source: source)
        }

        // Decoder for OrderCreate
        Decoders.addDecoder(clazz: OrderCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrderCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrderCreate() : instance as! OrderCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["encounter"] as AnyObject?) {
                case let .success(value): _result.encounter = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["orderType"] as AnyObject?) {
                case let .success(value): _result.orderType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrderCreate.Action.self, source: sourceDictionary["action"] as AnyObject?) {
                case let .success(value): _result.action = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["accessionNumber"] as AnyObject?) {
                case let .success(value): _result.accessionNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["dateActivated"] as AnyObject?) {
                case let .success(value): _result.dateActivated = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["scheduledDate"] as AnyObject?) {
                case let .success(value): _result.scheduledDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["patient"] as AnyObject?) {
                case let .success(value): _result.patient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["careSetting"] as AnyObject?) {
                case let .success(value): _result.careSetting = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["dateStopped"] as AnyObject?) {
                case let .success(value): _result.dateStopped = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["autoExpireDate"] as AnyObject?) {
                case let .success(value): _result.autoExpireDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["orderer"] as AnyObject?) {
                case let .success(value): _result.orderer = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["previousOrder"] as AnyObject?) {
                case let .success(value): _result.previousOrder = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrderCreate.Urgency.self, source: sourceDictionary["urgency"] as AnyObject?) {
                case let .success(value): _result.urgency = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["orderReason"] as AnyObject?) {
                case let .success(value): _result.orderReason = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["orderReasonNonCoded"] as AnyObject?) {
                case let .success(value): _result.orderReasonNonCoded = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["instructions"] as AnyObject?) {
                case let .success(value): _result.instructions = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["commentToFulfiller"] as AnyObject?) {
                case let .success(value): _result.commentToFulfiller = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrderCreate", actual: "\(source)"))
            }
        }
        // Decoder for [OrderCreateFull]
        Decoders.addDecoder(clazz: [OrderCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrderCreateFull]> in
            return Decoders.decode(clazz: [OrderCreateFull].self, source: source)
        }

        // Decoder for OrderCreateFull
        Decoders.addDecoder(clazz: OrderCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrderCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrderCreateFull() : instance as! OrderCreateFull
                switch Decoders.decodeOptional(clazz: EncounterCreate.self, source: sourceDictionary["encounter"] as AnyObject?) {
                case let .success(value): _result.encounter = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["orderType"] as AnyObject?) {
                case let .success(value): _result.orderType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrderCreateFull.Action.self, source: sourceDictionary["action"] as AnyObject?) {
                case let .success(value): _result.action = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["accessionNumber"] as AnyObject?) {
                case let .success(value): _result.accessionNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["dateActivated"] as AnyObject?) {
                case let .success(value): _result.dateActivated = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["scheduledDate"] as AnyObject?) {
                case let .success(value): _result.scheduledDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientCreate.self, source: sourceDictionary["patient"] as AnyObject?) {
                case let .success(value): _result.patient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptCreate.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["careSetting"] as AnyObject?) {
                case let .success(value): _result.careSetting = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["dateStopped"] as AnyObject?) {
                case let .success(value): _result.dateStopped = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["autoExpireDate"] as AnyObject?) {
                case let .success(value): _result.autoExpireDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: UserCreate.self, source: sourceDictionary["orderer"] as AnyObject?) {
                case let .success(value): _result.orderer = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrderCreate.self, source: sourceDictionary["previousOrder"] as AnyObject?) {
                case let .success(value): _result.previousOrder = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrderCreateFull.Urgency.self, source: sourceDictionary["urgency"] as AnyObject?) {
                case let .success(value): _result.urgency = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptCreate.self, source: sourceDictionary["orderReason"] as AnyObject?) {
                case let .success(value): _result.orderReason = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["orderReasonNonCoded"] as AnyObject?) {
                case let .success(value): _result.orderReasonNonCoded = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["instructions"] as AnyObject?) {
                case let .success(value): _result.instructions = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["commentToFulfiller"] as AnyObject?) {
                case let .success(value): _result.commentToFulfiller = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrderCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [OrderGet]
        Decoders.addDecoder(clazz: [OrderGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrderGet]> in
            return Decoders.decode(clazz: [OrderGet].self, source: source)
        }

        // Decoder for OrderGet
        Decoders.addDecoder(clazz: OrderGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrderGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrderGet() : instance as! OrderGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["instructions"] as AnyObject?) {
                case let .success(value): _result.instructions = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["autoExpireDate"] as AnyObject?) {
                case let .success(value): _result.autoExpireDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["accessionNumber"] as AnyObject?) {
                case let .success(value): _result.accessionNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["discontinuedDate"] as AnyObject?) {
                case let .success(value): _result.discontinuedDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["discontinuedReasonNonCoded"] as AnyObject?) {
                case let .success(value): _result.discontinuedReasonNonCoded = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrdertypeGetRef.self, source: sourceDictionary["orderType"] as AnyObject?) {
                case let .success(value): _result.orderType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientGetRef.self, source: sourceDictionary["patient"] as AnyObject?) {
                case let .success(value): _result.patient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: EncounterGetRef.self, source: sourceDictionary["encounter"] as AnyObject?) {
                case let .success(value): _result.encounter = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: UserGetRef.self, source: sourceDictionary["orderer"] as AnyObject?) {
                case let .success(value): _result.orderer = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: UserGetRef.self, source: sourceDictionary["discontinuedBy"] as AnyObject?) {
                case let .success(value): _result.discontinuedBy = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["discontinuedReason"] as AnyObject?) {
                case let .success(value): _result.discontinuedReason = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrderGet", actual: "\(source)"))
            }
        }
        // Decoder for [OrderGetFull]
        Decoders.addDecoder(clazz: [OrderGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrderGetFull]> in
            return Decoders.decode(clazz: [OrderGetFull].self, source: source)
        }

        // Decoder for OrderGetFull
        Decoders.addDecoder(clazz: OrderGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrderGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrderGetFull() : instance as! OrderGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["instructions"] as AnyObject?) {
                case let .success(value): _result.instructions = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["autoExpireDate"] as AnyObject?) {
                case let .success(value): _result.autoExpireDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["accessionNumber"] as AnyObject?) {
                case let .success(value): _result.accessionNumber = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["discontinuedDate"] as AnyObject?) {
                case let .success(value): _result.discontinuedDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["discontinuedReasonNonCoded"] as AnyObject?) {
                case let .success(value): _result.discontinuedReasonNonCoded = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrdertypeGet.self, source: sourceDictionary["orderType"] as AnyObject?) {
                case let .success(value): _result.orderType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientGet.self, source: sourceDictionary["patient"] as AnyObject?) {
                case let .success(value): _result.patient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: EncounterGet.self, source: sourceDictionary["encounter"] as AnyObject?) {
                case let .success(value): _result.encounter = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: UserGet.self, source: sourceDictionary["orderer"] as AnyObject?) {
                case let .success(value): _result.orderer = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: UserGet.self, source: sourceDictionary["discontinuedBy"] as AnyObject?) {
                case let .success(value): _result.discontinuedBy = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["discontinuedReason"] as AnyObject?) {
                case let .success(value): _result.discontinuedReason = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrderGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [OrderGetRef]
        Decoders.addDecoder(clazz: [OrderGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrderGetRef]> in
            return Decoders.decode(clazz: [OrderGetRef].self, source: source)
        }

        // Decoder for OrderGetRef
        Decoders.addDecoder(clazz: OrderGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrderGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrderGetRef() : instance as! OrderGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrderGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [OrderfrequencyGet]
        Decoders.addDecoder(clazz: [OrderfrequencyGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrderfrequencyGet]> in
            return Decoders.decode(clazz: [OrderfrequencyGet].self, source: source)
        }

        // Decoder for OrderfrequencyGet
        Decoders.addDecoder(clazz: OrderfrequencyGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrderfrequencyGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrderfrequencyGet() : instance as! OrderfrequencyGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrderfrequencyGet", actual: "\(source)"))
            }
        }
        // Decoder for [OrderfrequencyGetFull]
        Decoders.addDecoder(clazz: [OrderfrequencyGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrderfrequencyGetFull]> in
            return Decoders.decode(clazz: [OrderfrequencyGetFull].self, source: source)
        }

        // Decoder for OrderfrequencyGetFull
        Decoders.addDecoder(clazz: OrderfrequencyGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrderfrequencyGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrderfrequencyGetFull() : instance as! OrderfrequencyGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrderfrequencyGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [OrderfrequencyGetRef]
        Decoders.addDecoder(clazz: [OrderfrequencyGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrderfrequencyGetRef]> in
            return Decoders.decode(clazz: [OrderfrequencyGetRef].self, source: source)
        }

        // Decoder for OrderfrequencyGetRef
        Decoders.addDecoder(clazz: OrderfrequencyGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrderfrequencyGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrderfrequencyGetRef() : instance as! OrderfrequencyGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrderfrequencyGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [OrderfrequencyUpdate]
        Decoders.addDecoder(clazz: [OrderfrequencyUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrderfrequencyUpdate]> in
            return Decoders.decode(clazz: [OrderfrequencyUpdate].self, source: source)
        }

        // Decoder for OrderfrequencyUpdate
        Decoders.addDecoder(clazz: OrderfrequencyUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrderfrequencyUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrderfrequencyUpdate() : instance as! OrderfrequencyUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrderfrequencyUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [OrdersetCreate]
        Decoders.addDecoder(clazz: [OrdersetCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdersetCreate]> in
            return Decoders.decode(clazz: [OrdersetCreate].self, source: source)
        }

        // Decoder for OrdersetCreate
        Decoders.addDecoder(clazz: OrdersetCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdersetCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrdersetCreate() : instance as! OrdersetCreate
                switch Decoders.decodeOptional(clazz: OrdersetCreate.Operator.self, source: sourceDictionary["operator"] as AnyObject?) {
                case let .success(value): _result._operator = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [OrdersetOrdersetmemberCreate].self, source: sourceDictionary["orderSetMembers"] as AnyObject?) {
                case let .success(value): _result.orderSetMembers = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdersetCreate", actual: "\(source)"))
            }
        }
        // Decoder for [OrdersetCreateFull]
        Decoders.addDecoder(clazz: [OrdersetCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdersetCreateFull]> in
            return Decoders.decode(clazz: [OrdersetCreateFull].self, source: source)
        }

        // Decoder for OrdersetCreateFull
        Decoders.addDecoder(clazz: OrdersetCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdersetCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrdersetCreateFull() : instance as! OrdersetCreateFull
                switch Decoders.decodeOptional(clazz: OrdersetCreateFull.Operator.self, source: sourceDictionary["operator"] as AnyObject?) {
                case let .success(value): _result._operator = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [OrdersetOrdersetmemberCreate].self, source: sourceDictionary["orderSetMembers"] as AnyObject?) {
                case let .success(value): _result.orderSetMembers = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdersetCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [OrdersetGet]
        Decoders.addDecoder(clazz: [OrdersetGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdersetGet]> in
            return Decoders.decode(clazz: [OrdersetGet].self, source: source)
        }

        // Decoder for OrdersetGet
        Decoders.addDecoder(clazz: OrdersetGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdersetGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrdersetGet() : instance as! OrdersetGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrdersetGet.Operator.self, source: sourceDictionary["operator"] as AnyObject?) {
                case let .success(value): _result._operator = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [OrdersetOrdersetmemberGetRef].self, source: sourceDictionary["orderSetMembers"] as AnyObject?) {
                case let .success(value): _result.orderSetMembers = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdersetGet", actual: "\(source)"))
            }
        }
        // Decoder for [OrdersetGetFull]
        Decoders.addDecoder(clazz: [OrdersetGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdersetGetFull]> in
            return Decoders.decode(clazz: [OrdersetGetFull].self, source: source)
        }

        // Decoder for OrdersetGetFull
        Decoders.addDecoder(clazz: OrdersetGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdersetGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrdersetGetFull() : instance as! OrdersetGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrdersetGetFull.Operator.self, source: sourceDictionary["operator"] as AnyObject?) {
                case let .success(value): _result._operator = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [OrdersetOrdersetmemberGet].self, source: sourceDictionary["orderSetMembers"] as AnyObject?) {
                case let .success(value): _result.orderSetMembers = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdersetGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [OrdersetGetRef]
        Decoders.addDecoder(clazz: [OrdersetGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdersetGetRef]> in
            return Decoders.decode(clazz: [OrdersetGetRef].self, source: source)
        }

        // Decoder for OrdersetGetRef
        Decoders.addDecoder(clazz: OrdersetGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdersetGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrdersetGetRef() : instance as! OrdersetGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdersetGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [OrdersetOrdersetmemberCreate]
        Decoders.addDecoder(clazz: [OrdersetOrdersetmemberCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdersetOrdersetmemberCreate]> in
            return Decoders.decode(clazz: [OrdersetOrdersetmemberCreate].self, source: source)
        }

        // Decoder for OrdersetOrdersetmemberCreate
        Decoders.addDecoder(clazz: OrdersetOrdersetmemberCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdersetOrdersetmemberCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrdersetOrdersetmemberCreate() : instance as! OrdersetOrdersetmemberCreate
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["orderType"] as AnyObject?) {
                case let .success(value): _result.orderType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["orderTemplate"] as AnyObject?) {
                case let .success(value): _result.orderTemplate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdersetOrdersetmemberCreate", actual: "\(source)"))
            }
        }
        // Decoder for [OrdersetOrdersetmemberCreateFull]
        Decoders.addDecoder(clazz: [OrdersetOrdersetmemberCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdersetOrdersetmemberCreateFull]> in
            return Decoders.decode(clazz: [OrdersetOrdersetmemberCreateFull].self, source: source)
        }

        // Decoder for OrdersetOrdersetmemberCreateFull
        Decoders.addDecoder(clazz: OrdersetOrdersetmemberCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdersetOrdersetmemberCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrdersetOrdersetmemberCreateFull() : instance as! OrdersetOrdersetmemberCreateFull
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["orderType"] as AnyObject?) {
                case let .success(value): _result.orderType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["orderTemplate"] as AnyObject?) {
                case let .success(value): _result.orderTemplate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdersetOrdersetmemberCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [OrdersetOrdersetmemberGet]
        Decoders.addDecoder(clazz: [OrdersetOrdersetmemberGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdersetOrdersetmemberGet]> in
            return Decoders.decode(clazz: [OrdersetOrdersetmemberGet].self, source: source)
        }

        // Decoder for OrdersetOrdersetmemberGet
        Decoders.addDecoder(clazz: OrdersetOrdersetmemberGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdersetOrdersetmemberGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrdersetOrdersetmemberGet() : instance as! OrdersetOrdersetmemberGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["orderTemplate"] as AnyObject?) {
                case let .success(value): _result.orderTemplate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["orderTemplateType"] as AnyObject?) {
                case let .success(value): _result.orderTemplateType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrdertypeGetRef.self, source: sourceDictionary["orderType"] as AnyObject?) {
                case let .success(value): _result.orderType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdersetOrdersetmemberGet", actual: "\(source)"))
            }
        }
        // Decoder for [OrdersetOrdersetmemberGetFull]
        Decoders.addDecoder(clazz: [OrdersetOrdersetmemberGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdersetOrdersetmemberGetFull]> in
            return Decoders.decode(clazz: [OrdersetOrdersetmemberGetFull].self, source: source)
        }

        // Decoder for OrdersetOrdersetmemberGetFull
        Decoders.addDecoder(clazz: OrdersetOrdersetmemberGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdersetOrdersetmemberGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrdersetOrdersetmemberGetFull() : instance as! OrdersetOrdersetmemberGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["orderTemplate"] as AnyObject?) {
                case let .success(value): _result.orderTemplate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["orderTemplateType"] as AnyObject?) {
                case let .success(value): _result.orderTemplateType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrdertypeGet.self, source: sourceDictionary["orderType"] as AnyObject?) {
                case let .success(value): _result.orderType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdersetOrdersetmemberGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [OrdersetOrdersetmemberGetRef]
        Decoders.addDecoder(clazz: [OrdersetOrdersetmemberGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdersetOrdersetmemberGetRef]> in
            return Decoders.decode(clazz: [OrdersetOrdersetmemberGetRef].self, source: source)
        }

        // Decoder for OrdersetOrdersetmemberGetRef
        Decoders.addDecoder(clazz: OrdersetOrdersetmemberGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdersetOrdersetmemberGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrdersetOrdersetmemberGetRef() : instance as! OrdersetOrdersetmemberGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdersetOrdersetmemberGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [OrdersetOrdersetmemberUpdate]
        Decoders.addDecoder(clazz: [OrdersetOrdersetmemberUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdersetOrdersetmemberUpdate]> in
            return Decoders.decode(clazz: [OrdersetOrdersetmemberUpdate].self, source: source)
        }

        // Decoder for OrdersetOrdersetmemberUpdate
        Decoders.addDecoder(clazz: OrdersetOrdersetmemberUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdersetOrdersetmemberUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrdersetOrdersetmemberUpdate() : instance as! OrdersetOrdersetmemberUpdate
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["orderType"] as AnyObject?) {
                case let .success(value): _result.orderType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["orderTemplate"] as AnyObject?) {
                case let .success(value): _result.orderTemplate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdersetOrdersetmemberUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [OrdersetUpdate]
        Decoders.addDecoder(clazz: [OrdersetUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdersetUpdate]> in
            return Decoders.decode(clazz: [OrdersetUpdate].self, source: source)
        }

        // Decoder for OrdersetUpdate
        Decoders.addDecoder(clazz: OrdersetUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdersetUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrdersetUpdate() : instance as! OrdersetUpdate
                switch Decoders.decodeOptional(clazz: OrdersetUpdate.Operator.self, source: sourceDictionary["operator"] as AnyObject?) {
                case let .success(value): _result._operator = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [OrdersetOrdersetmemberCreate].self, source: sourceDictionary["orderSetMembers"] as AnyObject?) {
                case let .success(value): _result.orderSetMembers = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdersetUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [OrdertypeCreate]
        Decoders.addDecoder(clazz: [OrdertypeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdertypeCreate]> in
            return Decoders.decode(clazz: [OrdertypeCreate].self, source: source)
        }

        // Decoder for OrdertypeCreate
        Decoders.addDecoder(clazz: OrdertypeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdertypeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrdertypeCreate() : instance as! OrdertypeCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["javaClassName"] as AnyObject?) {
                case let .success(value): _result.javaClassName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["parent"] as AnyObject?) {
                case let .success(value): _result.parent = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["conceptClasses"] as AnyObject?) {
                case let .success(value): _result.conceptClasses = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdertypeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [OrdertypeCreateFull]
        Decoders.addDecoder(clazz: [OrdertypeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdertypeCreateFull]> in
            return Decoders.decode(clazz: [OrdertypeCreateFull].self, source: source)
        }

        // Decoder for OrdertypeCreateFull
        Decoders.addDecoder(clazz: OrdertypeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdertypeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrdertypeCreateFull() : instance as! OrdertypeCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["javaClassName"] as AnyObject?) {
                case let .success(value): _result.javaClassName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["parent"] as AnyObject?) {
                case let .success(value): _result.parent = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["conceptClasses"] as AnyObject?) {
                case let .success(value): _result.conceptClasses = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdertypeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [OrdertypeGet]
        Decoders.addDecoder(clazz: [OrdertypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdertypeGet]> in
            return Decoders.decode(clazz: [OrdertypeGet].self, source: source)
        }

        // Decoder for OrdertypeGet
        Decoders.addDecoder(clazz: OrdertypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdertypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrdertypeGet() : instance as! OrdertypeGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["javaClassName"] as AnyObject?) {
                case let .success(value): _result.javaClassName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ConceptclassGetRef].self, source: sourceDictionary["conceptClasses"] as AnyObject?) {
                case let .success(value): _result.conceptClasses = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrdertypeGetRef.self, source: sourceDictionary["parent"] as AnyObject?) {
                case let .success(value): _result.parent = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdertypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [OrdertypeGetFull]
        Decoders.addDecoder(clazz: [OrdertypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdertypeGetFull]> in
            return Decoders.decode(clazz: [OrdertypeGetFull].self, source: source)
        }

        // Decoder for OrdertypeGetFull
        Decoders.addDecoder(clazz: OrdertypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdertypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrdertypeGetFull() : instance as! OrdertypeGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["javaClassName"] as AnyObject?) {
                case let .success(value): _result.javaClassName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ConceptclassGet].self, source: sourceDictionary["conceptClasses"] as AnyObject?) {
                case let .success(value): _result.conceptClasses = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: OrdertypeGet.self, source: sourceDictionary["parent"] as AnyObject?) {
                case let .success(value): _result.parent = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdertypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [OrdertypeGetRef]
        Decoders.addDecoder(clazz: [OrdertypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdertypeGetRef]> in
            return Decoders.decode(clazz: [OrdertypeGetRef].self, source: source)
        }

        // Decoder for OrdertypeGetRef
        Decoders.addDecoder(clazz: OrdertypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdertypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrdertypeGetRef() : instance as! OrdertypeGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdertypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [OrdertypeUpdate]
        Decoders.addDecoder(clazz: [OrdertypeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrdertypeUpdate]> in
            return Decoders.decode(clazz: [OrdertypeUpdate].self, source: source)
        }

        // Decoder for OrdertypeUpdate
        Decoders.addDecoder(clazz: OrdertypeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrdertypeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrdertypeUpdate() : instance as! OrdertypeUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["javaClassName"] as AnyObject?) {
                case let .success(value): _result.javaClassName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["parent"] as AnyObject?) {
                case let .success(value): _result.parent = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["conceptClasses"] as AnyObject?) {
                case let .success(value): _result.conceptClasses = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrdertypeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [PatientAllergyCreate]
        Decoders.addDecoder(clazz: [PatientAllergyCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientAllergyCreate]> in
            return Decoders.decode(clazz: [PatientAllergyCreate].self, source: source)
        }

        // Decoder for PatientAllergyCreate
        Decoders.addDecoder(clazz: PatientAllergyCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientAllergyCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PatientAllergyCreate() : instance as! PatientAllergyCreate
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["allergen"] as AnyObject?) {
                case let .success(value): _result.allergen = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["severity"] as AnyObject?) {
                case let .success(value): _result.severity = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["comment"] as AnyObject?) {
                case let .success(value): _result.comment = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Any].self, source: sourceDictionary["reactions"] as AnyObject?) {
                case let .success(value): _result.reactions = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientAllergyCreate", actual: "\(source)"))
            }
        }
        // Decoder for [PatientAllergyCreateFull]
        Decoders.addDecoder(clazz: [PatientAllergyCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientAllergyCreateFull]> in
            return Decoders.decode(clazz: [PatientAllergyCreateFull].self, source: source)
        }

        // Decoder for PatientAllergyCreateFull
        Decoders.addDecoder(clazz: PatientAllergyCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientAllergyCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PatientAllergyCreateFull() : instance as! PatientAllergyCreateFull
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["allergen"] as AnyObject?) {
                case let .success(value): _result.allergen = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["severity"] as AnyObject?) {
                case let .success(value): _result.severity = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["comment"] as AnyObject?) {
                case let .success(value): _result.comment = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Any].self, source: sourceDictionary["reactions"] as AnyObject?) {
                case let .success(value): _result.reactions = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientAllergyCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [PatientAllergyGet]
        Decoders.addDecoder(clazz: [PatientAllergyGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientAllergyGet]> in
            return Decoders.decode(clazz: [PatientAllergyGet].self, source: source)
        }

        // Decoder for PatientAllergyGet
        Decoders.addDecoder(clazz: PatientAllergyGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientAllergyGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PatientAllergyGet() : instance as! PatientAllergyGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["allergen"] as AnyObject?) {
                case let .success(value): _result.allergen = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["severity"] as AnyObject?) {
                case let .success(value): _result.severity = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["comment"] as AnyObject?) {
                case let .success(value): _result.comment = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ConceptGetRef].self, source: sourceDictionary["reactions"] as AnyObject?) {
                case let .success(value): _result.reactions = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientGetRef.self, source: sourceDictionary["patient"] as AnyObject?) {
                case let .success(value): _result.patient = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientAllergyGet", actual: "\(source)"))
            }
        }
        // Decoder for [PatientAllergyGetFull]
        Decoders.addDecoder(clazz: [PatientAllergyGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientAllergyGetFull]> in
            return Decoders.decode(clazz: [PatientAllergyGetFull].self, source: source)
        }

        // Decoder for PatientAllergyGetFull
        Decoders.addDecoder(clazz: PatientAllergyGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientAllergyGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PatientAllergyGetFull() : instance as! PatientAllergyGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["allergen"] as AnyObject?) {
                case let .success(value): _result.allergen = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["severity"] as AnyObject?) {
                case let .success(value): _result.severity = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["comment"] as AnyObject?) {
                case let .success(value): _result.comment = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ConceptGet].self, source: sourceDictionary["reactions"] as AnyObject?) {
                case let .success(value): _result.reactions = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientGet.self, source: sourceDictionary["patient"] as AnyObject?) {
                case let .success(value): _result.patient = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientAllergyGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [PatientAllergyGetRef]
        Decoders.addDecoder(clazz: [PatientAllergyGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientAllergyGetRef]> in
            return Decoders.decode(clazz: [PatientAllergyGetRef].self, source: source)
        }

        // Decoder for PatientAllergyGetRef
        Decoders.addDecoder(clazz: PatientAllergyGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientAllergyGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PatientAllergyGetRef() : instance as! PatientAllergyGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientAllergyGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [PatientAllergyUpdate]
        Decoders.addDecoder(clazz: [PatientAllergyUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientAllergyUpdate]> in
            return Decoders.decode(clazz: [PatientAllergyUpdate].self, source: source)
        }

        // Decoder for PatientAllergyUpdate
        Decoders.addDecoder(clazz: PatientAllergyUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientAllergyUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PatientAllergyUpdate() : instance as! PatientAllergyUpdate
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["allergen"] as AnyObject?) {
                case let .success(value): _result.allergen = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["severity"] as AnyObject?) {
                case let .success(value): _result.severity = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["comment"] as AnyObject?) {
                case let .success(value): _result.comment = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Any].self, source: sourceDictionary["reactions"] as AnyObject?) {
                case let .success(value): _result.reactions = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientAllergyUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [PatientCreate]
        Decoders.addDecoder(clazz: [PatientCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientCreate]> in
            return Decoders.decode(clazz: [PatientCreate].self, source: source)
        }

        // Decoder for PatientCreate
        Decoders.addDecoder(clazz: PatientCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PatientCreate() : instance as! PatientCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["person"] as AnyObject?) {
                case let .success(value): _result.person = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PatientIdentifierCreate].self, source: sourceDictionary["identifiers"] as AnyObject?) {
                case let .success(value): _result.identifiers = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientCreate", actual: "\(source)"))
            }
        }
        // Decoder for [PatientCreateFull]
        Decoders.addDecoder(clazz: [PatientCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientCreateFull]> in
            return Decoders.decode(clazz: [PatientCreateFull].self, source: source)
        }

        // Decoder for PatientCreateFull
        Decoders.addDecoder(clazz: PatientCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PatientCreateFull() : instance as! PatientCreateFull
                switch Decoders.decodeOptional(clazz: PersonCreate.self, source: sourceDictionary["person"] as AnyObject?) {
                case let .success(value): _result.person = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PatientIdentifierCreate].self, source: sourceDictionary["identifiers"] as AnyObject?) {
                case let .success(value): _result.identifiers = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [PatientGet]
        Decoders.addDecoder(clazz: [PatientGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientGet]> in
            return Decoders.decode(clazz: [PatientGet].self, source: source)
        }

        // Decoder for PatientGet
        Decoders.addDecoder(clazz: PatientGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PatientGet() : instance as! PatientGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PatientIdentifierGetRef].self, source: sourceDictionary["identifiers"] as AnyObject?) {
                case let .success(value): _result.identifiers = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonGetRef.self, source: sourceDictionary["person"] as AnyObject?) {
                case let .success(value): _result.person = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientGet", actual: "\(source)"))
            }
        }
        // Decoder for [PatientGetFull]
        Decoders.addDecoder(clazz: [PatientGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientGetFull]> in
            return Decoders.decode(clazz: [PatientGetFull].self, source: source)
        }

        // Decoder for PatientGetFull
        Decoders.addDecoder(clazz: PatientGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PatientGetFull() : instance as! PatientGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PatientIdentifierGetRef].self, source: sourceDictionary["identifiers"] as AnyObject?) {
                case let .success(value): _result.identifiers = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonGet.self, source: sourceDictionary["person"] as AnyObject?) {
                case let .success(value): _result.person = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [PatientGetRef]
        Decoders.addDecoder(clazz: [PatientGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientGetRef]> in
            return Decoders.decode(clazz: [PatientGetRef].self, source: source)
        }

        // Decoder for PatientGetRef
        Decoders.addDecoder(clazz: PatientGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PatientGetRef() : instance as! PatientGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [PatientIdentifierCreate]
        Decoders.addDecoder(clazz: [PatientIdentifierCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientIdentifierCreate]> in
            return Decoders.decode(clazz: [PatientIdentifierCreate].self, source: source)
        }

        // Decoder for PatientIdentifierCreate
        Decoders.addDecoder(clazz: PatientIdentifierCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientIdentifierCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PatientIdentifierCreate() : instance as! PatientIdentifierCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["identifier"] as AnyObject?) {
                case let .success(value): _result.identifier = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["identifierType"] as AnyObject?) {
                case let .success(value): _result.identifierType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientIdentifierCreate", actual: "\(source)"))
            }
        }
        // Decoder for [PatientIdentifierCreateFull]
        Decoders.addDecoder(clazz: [PatientIdentifierCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientIdentifierCreateFull]> in
            return Decoders.decode(clazz: [PatientIdentifierCreateFull].self, source: source)
        }

        // Decoder for PatientIdentifierCreateFull
        Decoders.addDecoder(clazz: PatientIdentifierCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientIdentifierCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PatientIdentifierCreateFull() : instance as! PatientIdentifierCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["identifier"] as AnyObject?) {
                case let .success(value): _result.identifier = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientidentifiertypeCreate.self, source: sourceDictionary["identifierType"] as AnyObject?) {
                case let .success(value): _result.identifierType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationCreate.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientIdentifierCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [PatientIdentifierGet]
        Decoders.addDecoder(clazz: [PatientIdentifierGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientIdentifierGet]> in
            return Decoders.decode(clazz: [PatientIdentifierGet].self, source: source)
        }

        // Decoder for PatientIdentifierGet
        Decoders.addDecoder(clazz: PatientIdentifierGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientIdentifierGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PatientIdentifierGet() : instance as! PatientIdentifierGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["identifier"] as AnyObject?) {
                case let .success(value): _result.identifier = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientidentifiertypeGetRef.self, source: sourceDictionary["identifierType"] as AnyObject?) {
                case let .success(value): _result.identifierType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationGetRef.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientIdentifierGet", actual: "\(source)"))
            }
        }
        // Decoder for [PatientIdentifierGetFull]
        Decoders.addDecoder(clazz: [PatientIdentifierGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientIdentifierGetFull]> in
            return Decoders.decode(clazz: [PatientIdentifierGetFull].self, source: source)
        }

        // Decoder for PatientIdentifierGetFull
        Decoders.addDecoder(clazz: PatientIdentifierGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientIdentifierGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PatientIdentifierGetFull() : instance as! PatientIdentifierGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["identifier"] as AnyObject?) {
                case let .success(value): _result.identifier = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientidentifiertypeGet.self, source: sourceDictionary["identifierType"] as AnyObject?) {
                case let .success(value): _result.identifierType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationGet.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientIdentifierGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [PatientIdentifierGetRef]
        Decoders.addDecoder(clazz: [PatientIdentifierGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientIdentifierGetRef]> in
            return Decoders.decode(clazz: [PatientIdentifierGetRef].self, source: source)
        }

        // Decoder for PatientIdentifierGetRef
        Decoders.addDecoder(clazz: PatientIdentifierGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientIdentifierGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PatientIdentifierGetRef() : instance as! PatientIdentifierGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientIdentifierGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [PatientIdentifierUpdate]
        Decoders.addDecoder(clazz: [PatientIdentifierUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientIdentifierUpdate]> in
            return Decoders.decode(clazz: [PatientIdentifierUpdate].self, source: source)
        }

        // Decoder for PatientIdentifierUpdate
        Decoders.addDecoder(clazz: PatientIdentifierUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientIdentifierUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PatientIdentifierUpdate() : instance as! PatientIdentifierUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["identifier"] as AnyObject?) {
                case let .success(value): _result.identifier = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["identifierType"] as AnyObject?) {
                case let .success(value): _result.identifierType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientIdentifierUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [PatientUpdate]
        Decoders.addDecoder(clazz: [PatientUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientUpdate]> in
            return Decoders.decode(clazz: [PatientUpdate].self, source: source)
        }

        // Decoder for PatientUpdate
        Decoders.addDecoder(clazz: PatientUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PatientUpdate() : instance as! PatientUpdate
                switch Decoders.decodeOptional(clazz: PersonGet.self, source: sourceDictionary["person"] as AnyObject?) {
                case let .success(value): _result.person = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [PatientidentifiertypeCreate]
        Decoders.addDecoder(clazz: [PatientidentifiertypeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientidentifiertypeCreate]> in
            return Decoders.decode(clazz: [PatientidentifiertypeCreate].self, source: source)
        }

        // Decoder for PatientidentifiertypeCreate
        Decoders.addDecoder(clazz: PatientidentifiertypeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientidentifiertypeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PatientidentifiertypeCreate() : instance as! PatientidentifiertypeCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["format"] as AnyObject?) {
                case let .success(value): _result.format = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formatDescription"] as AnyObject?) {
                case let .success(value): _result.formatDescription = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                case let .success(value): _result._required = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["checkDigit"] as AnyObject?) {
                case let .success(value): _result.checkDigit = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["validator"] as AnyObject?) {
                case let .success(value): _result.validator = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientidentifiertypeCreate.LocationBehavior.self, source: sourceDictionary["locationBehavior"] as AnyObject?) {
                case let .success(value): _result.locationBehavior = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uniquenessBehavior"] as AnyObject?) {
                case let .success(value): _result.uniquenessBehavior = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientidentifiertypeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [PatientidentifiertypeCreateFull]
        Decoders.addDecoder(clazz: [PatientidentifiertypeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientidentifiertypeCreateFull]> in
            return Decoders.decode(clazz: [PatientidentifiertypeCreateFull].self, source: source)
        }

        // Decoder for PatientidentifiertypeCreateFull
        Decoders.addDecoder(clazz: PatientidentifiertypeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientidentifiertypeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PatientidentifiertypeCreateFull() : instance as! PatientidentifiertypeCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["format"] as AnyObject?) {
                case let .success(value): _result.format = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formatDescription"] as AnyObject?) {
                case let .success(value): _result.formatDescription = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                case let .success(value): _result._required = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["checkDigit"] as AnyObject?) {
                case let .success(value): _result.checkDigit = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["validator"] as AnyObject?) {
                case let .success(value): _result.validator = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientidentifiertypeCreateFull.LocationBehavior.self, source: sourceDictionary["locationBehavior"] as AnyObject?) {
                case let .success(value): _result.locationBehavior = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uniquenessBehavior"] as AnyObject?) {
                case let .success(value): _result.uniquenessBehavior = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientidentifiertypeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [PatientidentifiertypeGet]
        Decoders.addDecoder(clazz: [PatientidentifiertypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientidentifiertypeGet]> in
            return Decoders.decode(clazz: [PatientidentifiertypeGet].self, source: source)
        }

        // Decoder for PatientidentifiertypeGet
        Decoders.addDecoder(clazz: PatientidentifiertypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientidentifiertypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PatientidentifiertypeGet() : instance as! PatientidentifiertypeGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["format"] as AnyObject?) {
                case let .success(value): _result.format = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formatDescription"] as AnyObject?) {
                case let .success(value): _result.formatDescription = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                case let .success(value): _result._required = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["checkDigit"] as AnyObject?) {
                case let .success(value): _result.checkDigit = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["validator"] as AnyObject?) {
                case let .success(value): _result.validator = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientidentifiertypeGet.LocationBehavior.self, source: sourceDictionary["locationBehavior"] as AnyObject?) {
                case let .success(value): _result.locationBehavior = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uniquenessBehavior"] as AnyObject?) {
                case let .success(value): _result.uniquenessBehavior = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientidentifiertypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [PatientidentifiertypeGetFull]
        Decoders.addDecoder(clazz: [PatientidentifiertypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientidentifiertypeGetFull]> in
            return Decoders.decode(clazz: [PatientidentifiertypeGetFull].self, source: source)
        }

        // Decoder for PatientidentifiertypeGetFull
        Decoders.addDecoder(clazz: PatientidentifiertypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientidentifiertypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PatientidentifiertypeGetFull() : instance as! PatientidentifiertypeGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["format"] as AnyObject?) {
                case let .success(value): _result.format = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formatDescription"] as AnyObject?) {
                case let .success(value): _result.formatDescription = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                case let .success(value): _result._required = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["checkDigit"] as AnyObject?) {
                case let .success(value): _result.checkDigit = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["validator"] as AnyObject?) {
                case let .success(value): _result.validator = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientidentifiertypeGetFull.LocationBehavior.self, source: sourceDictionary["locationBehavior"] as AnyObject?) {
                case let .success(value): _result.locationBehavior = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uniquenessBehavior"] as AnyObject?) {
                case let .success(value): _result.uniquenessBehavior = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientidentifiertypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [PatientidentifiertypeGetRef]
        Decoders.addDecoder(clazz: [PatientidentifiertypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientidentifiertypeGetRef]> in
            return Decoders.decode(clazz: [PatientidentifiertypeGetRef].self, source: source)
        }

        // Decoder for PatientidentifiertypeGetRef
        Decoders.addDecoder(clazz: PatientidentifiertypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientidentifiertypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PatientidentifiertypeGetRef() : instance as! PatientidentifiertypeGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientidentifiertypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [PatientidentifiertypeUpdate]
        Decoders.addDecoder(clazz: [PatientidentifiertypeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PatientidentifiertypeUpdate]> in
            return Decoders.decode(clazz: [PatientidentifiertypeUpdate].self, source: source)
        }

        // Decoder for PatientidentifiertypeUpdate
        Decoders.addDecoder(clazz: PatientidentifiertypeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PatientidentifiertypeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PatientidentifiertypeUpdate() : instance as! PatientidentifiertypeUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["format"] as AnyObject?) {
                case let .success(value): _result.format = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formatDescription"] as AnyObject?) {
                case let .success(value): _result.formatDescription = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                case let .success(value): _result._required = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["checkDigit"] as AnyObject?) {
                case let .success(value): _result.checkDigit = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["validator"] as AnyObject?) {
                case let .success(value): _result.validator = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientidentifiertypeUpdate.LocationBehavior.self, source: sourceDictionary["locationBehavior"] as AnyObject?) {
                case let .success(value): _result.locationBehavior = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uniquenessBehavior"] as AnyObject?) {
                case let .success(value): _result.uniquenessBehavior = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PatientidentifiertypeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [PersonAddressCreate]
        Decoders.addDecoder(clazz: [PersonAddressCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonAddressCreate]> in
            return Decoders.decode(clazz: [PersonAddressCreate].self, source: source)
        }

        // Decoder for PersonAddressCreate
        Decoders.addDecoder(clazz: PersonAddressCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonAddressCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonAddressCreate() : instance as! PersonAddressCreate
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address1"] as AnyObject?) {
                case let .success(value): _result.address1 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address2"] as AnyObject?) {
                case let .success(value): _result.address2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["cityVillage"] as AnyObject?) {
                case let .success(value): _result.cityVillage = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stateProvince"] as AnyObject?) {
                case let .success(value): _result.stateProvince = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country"] as AnyObject?) {
                case let .success(value): _result.country = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["postalCode"] as AnyObject?) {
                case let .success(value): _result.postalCode = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["countyDistrict"] as AnyObject?) {
                case let .success(value): _result.countyDistrict = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address3"] as AnyObject?) {
                case let .success(value): _result.address3 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address4"] as AnyObject?) {
                case let .success(value): _result.address4 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address5"] as AnyObject?) {
                case let .success(value): _result.address5 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address6"] as AnyObject?) {
                case let .success(value): _result.address6 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["latitude"] as AnyObject?) {
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["longitude"] as AnyObject?) {
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonAddressCreate", actual: "\(source)"))
            }
        }
        // Decoder for [PersonAddressCreateFull]
        Decoders.addDecoder(clazz: [PersonAddressCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonAddressCreateFull]> in
            return Decoders.decode(clazz: [PersonAddressCreateFull].self, source: source)
        }

        // Decoder for PersonAddressCreateFull
        Decoders.addDecoder(clazz: PersonAddressCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonAddressCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonAddressCreateFull() : instance as! PersonAddressCreateFull
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address1"] as AnyObject?) {
                case let .success(value): _result.address1 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address2"] as AnyObject?) {
                case let .success(value): _result.address2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["cityVillage"] as AnyObject?) {
                case let .success(value): _result.cityVillage = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stateProvince"] as AnyObject?) {
                case let .success(value): _result.stateProvince = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country"] as AnyObject?) {
                case let .success(value): _result.country = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["postalCode"] as AnyObject?) {
                case let .success(value): _result.postalCode = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["countyDistrict"] as AnyObject?) {
                case let .success(value): _result.countyDistrict = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address3"] as AnyObject?) {
                case let .success(value): _result.address3 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address4"] as AnyObject?) {
                case let .success(value): _result.address4 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address5"] as AnyObject?) {
                case let .success(value): _result.address5 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address6"] as AnyObject?) {
                case let .success(value): _result.address6 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["latitude"] as AnyObject?) {
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["longitude"] as AnyObject?) {
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonAddressCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [PersonAddressGet]
        Decoders.addDecoder(clazz: [PersonAddressGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonAddressGet]> in
            return Decoders.decode(clazz: [PersonAddressGet].self, source: source)
        }

        // Decoder for PersonAddressGet
        Decoders.addDecoder(clazz: PersonAddressGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonAddressGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonAddressGet() : instance as! PersonAddressGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address1"] as AnyObject?) {
                case let .success(value): _result.address1 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address2"] as AnyObject?) {
                case let .success(value): _result.address2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["cityVillage"] as AnyObject?) {
                case let .success(value): _result.cityVillage = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stateProvince"] as AnyObject?) {
                case let .success(value): _result.stateProvince = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country"] as AnyObject?) {
                case let .success(value): _result.country = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["postalCode"] as AnyObject?) {
                case let .success(value): _result.postalCode = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["countyDistrict"] as AnyObject?) {
                case let .success(value): _result.countyDistrict = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address3"] as AnyObject?) {
                case let .success(value): _result.address3 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address4"] as AnyObject?) {
                case let .success(value): _result.address4 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address5"] as AnyObject?) {
                case let .success(value): _result.address5 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address6"] as AnyObject?) {
                case let .success(value): _result.address6 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["latitude"] as AnyObject?) {
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["longitude"] as AnyObject?) {
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonAddressGet", actual: "\(source)"))
            }
        }
        // Decoder for [PersonAddressGetFull]
        Decoders.addDecoder(clazz: [PersonAddressGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonAddressGetFull]> in
            return Decoders.decode(clazz: [PersonAddressGetFull].self, source: source)
        }

        // Decoder for PersonAddressGetFull
        Decoders.addDecoder(clazz: PersonAddressGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonAddressGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonAddressGetFull() : instance as! PersonAddressGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address1"] as AnyObject?) {
                case let .success(value): _result.address1 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address2"] as AnyObject?) {
                case let .success(value): _result.address2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["cityVillage"] as AnyObject?) {
                case let .success(value): _result.cityVillage = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stateProvince"] as AnyObject?) {
                case let .success(value): _result.stateProvince = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country"] as AnyObject?) {
                case let .success(value): _result.country = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["postalCode"] as AnyObject?) {
                case let .success(value): _result.postalCode = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["countyDistrict"] as AnyObject?) {
                case let .success(value): _result.countyDistrict = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address3"] as AnyObject?) {
                case let .success(value): _result.address3 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address4"] as AnyObject?) {
                case let .success(value): _result.address4 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address5"] as AnyObject?) {
                case let .success(value): _result.address5 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address6"] as AnyObject?) {
                case let .success(value): _result.address6 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["latitude"] as AnyObject?) {
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["longitude"] as AnyObject?) {
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonAddressGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [PersonAddressGetRef]
        Decoders.addDecoder(clazz: [PersonAddressGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonAddressGetRef]> in
            return Decoders.decode(clazz: [PersonAddressGetRef].self, source: source)
        }

        // Decoder for PersonAddressGetRef
        Decoders.addDecoder(clazz: PersonAddressGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonAddressGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonAddressGetRef() : instance as! PersonAddressGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonAddressGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [PersonAddressUpdate]
        Decoders.addDecoder(clazz: [PersonAddressUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonAddressUpdate]> in
            return Decoders.decode(clazz: [PersonAddressUpdate].self, source: source)
        }

        // Decoder for PersonAddressUpdate
        Decoders.addDecoder(clazz: PersonAddressUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonAddressUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonAddressUpdate() : instance as! PersonAddressUpdate
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address1"] as AnyObject?) {
                case let .success(value): _result.address1 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address2"] as AnyObject?) {
                case let .success(value): _result.address2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["cityVillage"] as AnyObject?) {
                case let .success(value): _result.cityVillage = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stateProvince"] as AnyObject?) {
                case let .success(value): _result.stateProvince = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country"] as AnyObject?) {
                case let .success(value): _result.country = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["postalCode"] as AnyObject?) {
                case let .success(value): _result.postalCode = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["countyDistrict"] as AnyObject?) {
                case let .success(value): _result.countyDistrict = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address3"] as AnyObject?) {
                case let .success(value): _result.address3 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address4"] as AnyObject?) {
                case let .success(value): _result.address4 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address5"] as AnyObject?) {
                case let .success(value): _result.address5 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address6"] as AnyObject?) {
                case let .success(value): _result.address6 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["latitude"] as AnyObject?) {
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["longitude"] as AnyObject?) {
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonAddressUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [PersonAttributeCreate]
        Decoders.addDecoder(clazz: [PersonAttributeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonAttributeCreate]> in
            return Decoders.decode(clazz: [PersonAttributeCreate].self, source: source)
        }

        // Decoder for PersonAttributeCreate
        Decoders.addDecoder(clazz: PersonAttributeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonAttributeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonAttributeCreate() : instance as! PersonAttributeCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hydratedObject"] as AnyObject?) {
                case let .success(value): _result.hydratedObject = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonAttributeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [PersonAttributeCreateFull]
        Decoders.addDecoder(clazz: [PersonAttributeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonAttributeCreateFull]> in
            return Decoders.decode(clazz: [PersonAttributeCreateFull].self, source: source)
        }

        // Decoder for PersonAttributeCreateFull
        Decoders.addDecoder(clazz: PersonAttributeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonAttributeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonAttributeCreateFull() : instance as! PersonAttributeCreateFull
                switch Decoders.decodeOptional(clazz: PersonattributetypeCreate.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hydratedObject"] as AnyObject?) {
                case let .success(value): _result.hydratedObject = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonAttributeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [PersonAttributeGet]
        Decoders.addDecoder(clazz: [PersonAttributeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonAttributeGet]> in
            return Decoders.decode(clazz: [PersonAttributeGet].self, source: source)
        }

        // Decoder for PersonAttributeGet
        Decoders.addDecoder(clazz: PersonAttributeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonAttributeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonAttributeGet() : instance as! PersonAttributeGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonattributetypeGetRef.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonAttributeGet", actual: "\(source)"))
            }
        }
        // Decoder for [PersonAttributeGetFull]
        Decoders.addDecoder(clazz: [PersonAttributeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonAttributeGetFull]> in
            return Decoders.decode(clazz: [PersonAttributeGetFull].self, source: source)
        }

        // Decoder for PersonAttributeGetFull
        Decoders.addDecoder(clazz: PersonAttributeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonAttributeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonAttributeGetFull() : instance as! PersonAttributeGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonattributetypeGetRef.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hydratedObject"] as AnyObject?) {
                case let .success(value): _result.hydratedObject = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonAttributeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [PersonAttributeGetRef]
        Decoders.addDecoder(clazz: [PersonAttributeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonAttributeGetRef]> in
            return Decoders.decode(clazz: [PersonAttributeGetRef].self, source: source)
        }

        // Decoder for PersonAttributeGetRef
        Decoders.addDecoder(clazz: PersonAttributeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonAttributeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonAttributeGetRef() : instance as! PersonAttributeGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonAttributeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [PersonAttributeUpdate]
        Decoders.addDecoder(clazz: [PersonAttributeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonAttributeUpdate]> in
            return Decoders.decode(clazz: [PersonAttributeUpdate].self, source: source)
        }

        // Decoder for PersonAttributeUpdate
        Decoders.addDecoder(clazz: PersonAttributeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonAttributeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonAttributeUpdate() : instance as! PersonAttributeUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hydratedObject"] as AnyObject?) {
                case let .success(value): _result.hydratedObject = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonAttributeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [PersonCreate]
        Decoders.addDecoder(clazz: [PersonCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonCreate]> in
            return Decoders.decode(clazz: [PersonCreate].self, source: source)
        }

        // Decoder for PersonCreate
        Decoders.addDecoder(clazz: PersonCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonCreate() : instance as! PersonCreate
                switch Decoders.decodeOptional(clazz: [PersonNameCreate].self, source: sourceDictionary["names"] as AnyObject?) {
                case let .success(value): _result.names = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonCreate.Gender.self, source: sourceDictionary["gender"] as AnyObject?) {
                case let .success(value): _result.gender = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["age"] as AnyObject?) {
                case let .success(value): _result.age = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["birthdate"] as AnyObject?) {
                case let .success(value): _result.birthdate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["birthdateEstimated"] as AnyObject?) {
                case let .success(value): _result.birthdateEstimated = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["dead"] as AnyObject?) {
                case let .success(value): _result.dead = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["deathDate"] as AnyObject?) {
                case let .success(value): _result.deathDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["causeOfDeath"] as AnyObject?) {
                case let .success(value): _result.causeOfDeath = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PersonAddressCreate].self, source: sourceDictionary["addresses"] as AnyObject?) {
                case let .success(value): _result.addresses = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PersonAttributeCreate].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["deathdateEstimated"] as AnyObject?) {
                case let .success(value): _result.deathdateEstimated = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["birthtime"] as AnyObject?) {
                case let .success(value): _result.birthtime = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonCreate", actual: "\(source)"))
            }
        }
        // Decoder for [PersonCreateFull]
        Decoders.addDecoder(clazz: [PersonCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonCreateFull]> in
            return Decoders.decode(clazz: [PersonCreateFull].self, source: source)
        }

        // Decoder for PersonCreateFull
        Decoders.addDecoder(clazz: PersonCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonCreateFull() : instance as! PersonCreateFull
                switch Decoders.decodeOptional(clazz: [PersonNameCreate].self, source: sourceDictionary["names"] as AnyObject?) {
                case let .success(value): _result.names = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonCreateFull.Gender.self, source: sourceDictionary["gender"] as AnyObject?) {
                case let .success(value): _result.gender = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["age"] as AnyObject?) {
                case let .success(value): _result.age = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["birthdate"] as AnyObject?) {
                case let .success(value): _result.birthdate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["birthdateEstimated"] as AnyObject?) {
                case let .success(value): _result.birthdateEstimated = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["dead"] as AnyObject?) {
                case let .success(value): _result.dead = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["deathDate"] as AnyObject?) {
                case let .success(value): _result.deathDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["causeOfDeath"] as AnyObject?) {
                case let .success(value): _result.causeOfDeath = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PersonAddressCreate].self, source: sourceDictionary["addresses"] as AnyObject?) {
                case let .success(value): _result.addresses = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PersonAttributeCreate].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["deathdateEstimated"] as AnyObject?) {
                case let .success(value): _result.deathdateEstimated = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["birthtime"] as AnyObject?) {
                case let .success(value): _result.birthtime = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [PersonGet]
        Decoders.addDecoder(clazz: [PersonGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonGet]> in
            return Decoders.decode(clazz: [PersonGet].self, source: source)
        }

        // Decoder for PersonGet
        Decoders.addDecoder(clazz: PersonGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonGet() : instance as! PersonGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonGet.Gender.self, source: sourceDictionary["gender"] as AnyObject?) {
                case let .success(value): _result.gender = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["age"] as AnyObject?) {
                case let .success(value): _result.age = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["birthdate"] as AnyObject?) {
                case let .success(value): _result.birthdate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["birthdateEstimated"] as AnyObject?) {
                case let .success(value): _result.birthdateEstimated = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["dead"] as AnyObject?) {
                case let .success(value): _result.dead = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["deathDate"] as AnyObject?) {
                case let .success(value): _result.deathDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["causeOfDeath"] as AnyObject?) {
                case let .success(value): _result.causeOfDeath = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PersonAttributeGetRef].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonNameGetRef.self, source: sourceDictionary["preferredName"] as AnyObject?) {
                case let .success(value): _result.preferredName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonAddressGetRef.self, source: sourceDictionary["preferredAddress"] as AnyObject?) {
                case let .success(value): _result.preferredAddress = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["deathdateEstimated"] as AnyObject?) {
                case let .success(value): _result.deathdateEstimated = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["birthtime"] as AnyObject?) {
                case let .success(value): _result.birthtime = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonGet", actual: "\(source)"))
            }
        }
        // Decoder for [PersonGetFull]
        Decoders.addDecoder(clazz: [PersonGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonGetFull]> in
            return Decoders.decode(clazz: [PersonGetFull].self, source: source)
        }

        // Decoder for PersonGetFull
        Decoders.addDecoder(clazz: PersonGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonGetFull() : instance as! PersonGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonGetFull.Gender.self, source: sourceDictionary["gender"] as AnyObject?) {
                case let .success(value): _result.gender = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["age"] as AnyObject?) {
                case let .success(value): _result.age = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["birthdate"] as AnyObject?) {
                case let .success(value): _result.birthdate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["birthdateEstimated"] as AnyObject?) {
                case let .success(value): _result.birthdateEstimated = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["dead"] as AnyObject?) {
                case let .success(value): _result.dead = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["deathDate"] as AnyObject?) {
                case let .success(value): _result.deathDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["causeOfDeath"] as AnyObject?) {
                case let .success(value): _result.causeOfDeath = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PersonAttributeGetRef].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonNameGet.self, source: sourceDictionary["preferredName"] as AnyObject?) {
                case let .success(value): _result.preferredName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonAddressGet.self, source: sourceDictionary["preferredAddress"] as AnyObject?) {
                case let .success(value): _result.preferredAddress = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PersonNameGet].self, source: sourceDictionary["names"] as AnyObject?) {
                case let .success(value): _result.names = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PersonAddressGet].self, source: sourceDictionary["addresses"] as AnyObject?) {
                case let .success(value): _result.addresses = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["deathdateEstimated"] as AnyObject?) {
                case let .success(value): _result.deathdateEstimated = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["birthtime"] as AnyObject?) {
                case let .success(value): _result.birthtime = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [PersonGetRef]
        Decoders.addDecoder(clazz: [PersonGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonGetRef]> in
            return Decoders.decode(clazz: [PersonGetRef].self, source: source)
        }

        // Decoder for PersonGetRef
        Decoders.addDecoder(clazz: PersonGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonGetRef() : instance as! PersonGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [PersonNameCreate]
        Decoders.addDecoder(clazz: [PersonNameCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonNameCreate]> in
            return Decoders.decode(clazz: [PersonNameCreate].self, source: source)
        }

        // Decoder for PersonNameCreate
        Decoders.addDecoder(clazz: PersonNameCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonNameCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonNameCreate() : instance as! PersonNameCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["givenName"] as AnyObject?) {
                case let .success(value): _result.givenName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["middleName"] as AnyObject?) {
                case let .success(value): _result.middleName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyName"] as AnyObject?) {
                case let .success(value): _result.familyName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyName2"] as AnyObject?) {
                case let .success(value): _result.familyName2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["prefix"] as AnyObject?) {
                case let .success(value): _result._prefix = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyNamePrefix"] as AnyObject?) {
                case let .success(value): _result.familyNamePrefix = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyNameSuffix"] as AnyObject?) {
                case let .success(value): _result.familyNameSuffix = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["degree"] as AnyObject?) {
                case let .success(value): _result.degree = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonNameCreate", actual: "\(source)"))
            }
        }
        // Decoder for [PersonNameCreateFull]
        Decoders.addDecoder(clazz: [PersonNameCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonNameCreateFull]> in
            return Decoders.decode(clazz: [PersonNameCreateFull].self, source: source)
        }

        // Decoder for PersonNameCreateFull
        Decoders.addDecoder(clazz: PersonNameCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonNameCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonNameCreateFull() : instance as! PersonNameCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["givenName"] as AnyObject?) {
                case let .success(value): _result.givenName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["middleName"] as AnyObject?) {
                case let .success(value): _result.middleName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyName"] as AnyObject?) {
                case let .success(value): _result.familyName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyName2"] as AnyObject?) {
                case let .success(value): _result.familyName2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["prefix"] as AnyObject?) {
                case let .success(value): _result._prefix = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyNamePrefix"] as AnyObject?) {
                case let .success(value): _result.familyNamePrefix = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyNameSuffix"] as AnyObject?) {
                case let .success(value): _result.familyNameSuffix = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["degree"] as AnyObject?) {
                case let .success(value): _result.degree = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonNameCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [PersonNameGet]
        Decoders.addDecoder(clazz: [PersonNameGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonNameGet]> in
            return Decoders.decode(clazz: [PersonNameGet].self, source: source)
        }

        // Decoder for PersonNameGet
        Decoders.addDecoder(clazz: PersonNameGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonNameGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonNameGet() : instance as! PersonNameGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["givenName"] as AnyObject?) {
                case let .success(value): _result.givenName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["middleName"] as AnyObject?) {
                case let .success(value): _result.middleName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyName"] as AnyObject?) {
                case let .success(value): _result.familyName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyName2"] as AnyObject?) {
                case let .success(value): _result.familyName2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonNameGet", actual: "\(source)"))
            }
        }
        // Decoder for [PersonNameGetFull]
        Decoders.addDecoder(clazz: [PersonNameGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonNameGetFull]> in
            return Decoders.decode(clazz: [PersonNameGetFull].self, source: source)
        }

        // Decoder for PersonNameGetFull
        Decoders.addDecoder(clazz: PersonNameGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonNameGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonNameGetFull() : instance as! PersonNameGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["givenName"] as AnyObject?) {
                case let .success(value): _result.givenName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["middleName"] as AnyObject?) {
                case let .success(value): _result.middleName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyName"] as AnyObject?) {
                case let .success(value): _result.familyName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyName2"] as AnyObject?) {
                case let .success(value): _result.familyName2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["prefix"] as AnyObject?) {
                case let .success(value): _result._prefix = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyNamePrefix"] as AnyObject?) {
                case let .success(value): _result.familyNamePrefix = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyNameSuffix"] as AnyObject?) {
                case let .success(value): _result.familyNameSuffix = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["degree"] as AnyObject?) {
                case let .success(value): _result.degree = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonNameGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [PersonNameGetRef]
        Decoders.addDecoder(clazz: [PersonNameGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonNameGetRef]> in
            return Decoders.decode(clazz: [PersonNameGetRef].self, source: source)
        }

        // Decoder for PersonNameGetRef
        Decoders.addDecoder(clazz: PersonNameGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonNameGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonNameGetRef() : instance as! PersonNameGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonNameGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [PersonNameUpdate]
        Decoders.addDecoder(clazz: [PersonNameUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonNameUpdate]> in
            return Decoders.decode(clazz: [PersonNameUpdate].self, source: source)
        }

        // Decoder for PersonNameUpdate
        Decoders.addDecoder(clazz: PersonNameUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonNameUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonNameUpdate() : instance as! PersonNameUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["givenName"] as AnyObject?) {
                case let .success(value): _result.givenName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["middleName"] as AnyObject?) {
                case let .success(value): _result.middleName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyName"] as AnyObject?) {
                case let .success(value): _result.familyName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyName2"] as AnyObject?) {
                case let .success(value): _result.familyName2 = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["preferred"] as AnyObject?) {
                case let .success(value): _result.preferred = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["prefix"] as AnyObject?) {
                case let .success(value): _result._prefix = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyNamePrefix"] as AnyObject?) {
                case let .success(value): _result.familyNamePrefix = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["familyNameSuffix"] as AnyObject?) {
                case let .success(value): _result.familyNameSuffix = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["degree"] as AnyObject?) {
                case let .success(value): _result.degree = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonNameUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [PersonUpdate]
        Decoders.addDecoder(clazz: [PersonUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonUpdate]> in
            return Decoders.decode(clazz: [PersonUpdate].self, source: source)
        }

        // Decoder for PersonUpdate
        Decoders.addDecoder(clazz: PersonUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonUpdate() : instance as! PersonUpdate
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["dead"] as AnyObject?) {
                case let .success(value): _result.dead = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["causeOfDeath"] as AnyObject?) {
                case let .success(value): _result.causeOfDeath = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["deathDate"] as AnyObject?) {
                case let .success(value): _result.deathDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["age"] as AnyObject?) {
                case let .success(value): _result.age = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonUpdate.Gender.self, source: sourceDictionary["gender"] as AnyObject?) {
                case let .success(value): _result.gender = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["birthdate"] as AnyObject?) {
                case let .success(value): _result.birthdate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["birthdateEstimated"] as AnyObject?) {
                case let .success(value): _result.birthdateEstimated = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredName"] as AnyObject?) {
                case let .success(value): _result.preferredName = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredAddress"] as AnyObject?) {
                case let .success(value): _result.preferredAddress = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PersonAttributeCreate].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["deathdateEstimated"] as AnyObject?) {
                case let .success(value): _result.deathdateEstimated = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["birthtime"] as AnyObject?) {
                case let .success(value): _result.birthtime = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [PersonattributetypeCreate]
        Decoders.addDecoder(clazz: [PersonattributetypeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonattributetypeCreate]> in
            return Decoders.decode(clazz: [PersonattributetypeCreate].self, source: source)
        }

        // Decoder for PersonattributetypeCreate
        Decoders.addDecoder(clazz: PersonattributetypeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonattributetypeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonattributetypeCreate() : instance as! PersonattributetypeCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["format"] as AnyObject?) {
                case let .success(value): _result.format = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["foreignKey"] as AnyObject?) {
                case let .success(value): _result.foreignKey = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["sortWeight"] as AnyObject?) {
                case let .success(value): _result.sortWeight = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["searchable"] as AnyObject?) {
                case let .success(value): _result.searchable = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PrivilegeCreate.self, source: sourceDictionary["editPrivilege"] as AnyObject?) {
                case let .success(value): _result.editPrivilege = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonattributetypeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [PersonattributetypeCreateFull]
        Decoders.addDecoder(clazz: [PersonattributetypeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonattributetypeCreateFull]> in
            return Decoders.decode(clazz: [PersonattributetypeCreateFull].self, source: source)
        }

        // Decoder for PersonattributetypeCreateFull
        Decoders.addDecoder(clazz: PersonattributetypeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonattributetypeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonattributetypeCreateFull() : instance as! PersonattributetypeCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["format"] as AnyObject?) {
                case let .success(value): _result.format = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["foreignKey"] as AnyObject?) {
                case let .success(value): _result.foreignKey = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["sortWeight"] as AnyObject?) {
                case let .success(value): _result.sortWeight = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["searchable"] as AnyObject?) {
                case let .success(value): _result.searchable = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PrivilegeCreate.self, source: sourceDictionary["editPrivilege"] as AnyObject?) {
                case let .success(value): _result.editPrivilege = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonattributetypeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [PersonattributetypeGet]
        Decoders.addDecoder(clazz: [PersonattributetypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonattributetypeGet]> in
            return Decoders.decode(clazz: [PersonattributetypeGet].self, source: source)
        }

        // Decoder for PersonattributetypeGet
        Decoders.addDecoder(clazz: PersonattributetypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonattributetypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonattributetypeGet() : instance as! PersonattributetypeGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["format"] as AnyObject?) {
                case let .success(value): _result.format = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["foreignKey"] as AnyObject?) {
                case let .success(value): _result.foreignKey = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["sortWeight"] as AnyObject?) {
                case let .success(value): _result.sortWeight = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["searchable"] as AnyObject?) {
                case let .success(value): _result.searchable = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PrivilegeGetRef.self, source: sourceDictionary["editPrivilege"] as AnyObject?) {
                case let .success(value): _result.editPrivilege = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonattributetypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [PersonattributetypeGetFull]
        Decoders.addDecoder(clazz: [PersonattributetypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonattributetypeGetFull]> in
            return Decoders.decode(clazz: [PersonattributetypeGetFull].self, source: source)
        }

        // Decoder for PersonattributetypeGetFull
        Decoders.addDecoder(clazz: PersonattributetypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonattributetypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonattributetypeGetFull() : instance as! PersonattributetypeGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["format"] as AnyObject?) {
                case let .success(value): _result.format = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["foreignKey"] as AnyObject?) {
                case let .success(value): _result.foreignKey = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["sortWeight"] as AnyObject?) {
                case let .success(value): _result.sortWeight = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["searchable"] as AnyObject?) {
                case let .success(value): _result.searchable = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PrivilegeGet.self, source: sourceDictionary["editPrivilege"] as AnyObject?) {
                case let .success(value): _result.editPrivilege = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonattributetypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [PersonattributetypeGetRef]
        Decoders.addDecoder(clazz: [PersonattributetypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonattributetypeGetRef]> in
            return Decoders.decode(clazz: [PersonattributetypeGetRef].self, source: source)
        }

        // Decoder for PersonattributetypeGetRef
        Decoders.addDecoder(clazz: PersonattributetypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonattributetypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonattributetypeGetRef() : instance as! PersonattributetypeGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonattributetypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [PersonattributetypeUpdate]
        Decoders.addDecoder(clazz: [PersonattributetypeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonattributetypeUpdate]> in
            return Decoders.decode(clazz: [PersonattributetypeUpdate].self, source: source)
        }

        // Decoder for PersonattributetypeUpdate
        Decoders.addDecoder(clazz: PersonattributetypeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonattributetypeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonattributetypeUpdate() : instance as! PersonattributetypeUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["format"] as AnyObject?) {
                case let .success(value): _result.format = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["foreignKey"] as AnyObject?) {
                case let .success(value): _result.foreignKey = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["sortWeight"] as AnyObject?) {
                case let .success(value): _result.sortWeight = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["searchable"] as AnyObject?) {
                case let .success(value): _result.searchable = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PrivilegeCreate.self, source: sourceDictionary["editPrivilege"] as AnyObject?) {
                case let .success(value): _result.editPrivilege = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonattributetypeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [PersonimageGet]
        Decoders.addDecoder(clazz: [PersonimageGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonimageGet]> in
            return Decoders.decode(clazz: [PersonimageGet].self, source: source)
        }

        // Decoder for PersonimageGet
        Decoders.addDecoder(clazz: PersonimageGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonimageGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonimageGet() : instance as! PersonimageGet
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonimageGet", actual: "\(source)"))
            }
        }
        // Decoder for [PersonimageGetFull]
        Decoders.addDecoder(clazz: [PersonimageGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonimageGetFull]> in
            return Decoders.decode(clazz: [PersonimageGetFull].self, source: source)
        }

        // Decoder for PersonimageGetFull
        Decoders.addDecoder(clazz: PersonimageGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonimageGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonimageGetFull() : instance as! PersonimageGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonimageGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [PersonimageGetRef]
        Decoders.addDecoder(clazz: [PersonimageGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PersonimageGetRef]> in
            return Decoders.decode(clazz: [PersonimageGetRef].self, source: source)
        }

        // Decoder for PersonimageGetRef
        Decoders.addDecoder(clazz: PersonimageGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PersonimageGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PersonimageGetRef() : instance as! PersonimageGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PersonimageGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [PrivilegeCreate]
        Decoders.addDecoder(clazz: [PrivilegeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PrivilegeCreate]> in
            return Decoders.decode(clazz: [PrivilegeCreate].self, source: source)
        }

        // Decoder for PrivilegeCreate
        Decoders.addDecoder(clazz: PrivilegeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PrivilegeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PrivilegeCreate() : instance as! PrivilegeCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PrivilegeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [PrivilegeCreateFull]
        Decoders.addDecoder(clazz: [PrivilegeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PrivilegeCreateFull]> in
            return Decoders.decode(clazz: [PrivilegeCreateFull].self, source: source)
        }

        // Decoder for PrivilegeCreateFull
        Decoders.addDecoder(clazz: PrivilegeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PrivilegeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PrivilegeCreateFull() : instance as! PrivilegeCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PrivilegeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [PrivilegeGet]
        Decoders.addDecoder(clazz: [PrivilegeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PrivilegeGet]> in
            return Decoders.decode(clazz: [PrivilegeGet].self, source: source)
        }

        // Decoder for PrivilegeGet
        Decoders.addDecoder(clazz: PrivilegeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PrivilegeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PrivilegeGet() : instance as! PrivilegeGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PrivilegeGet", actual: "\(source)"))
            }
        }
        // Decoder for [PrivilegeGetFull]
        Decoders.addDecoder(clazz: [PrivilegeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PrivilegeGetFull]> in
            return Decoders.decode(clazz: [PrivilegeGetFull].self, source: source)
        }

        // Decoder for PrivilegeGetFull
        Decoders.addDecoder(clazz: PrivilegeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PrivilegeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PrivilegeGetFull() : instance as! PrivilegeGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PrivilegeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [PrivilegeGetRef]
        Decoders.addDecoder(clazz: [PrivilegeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PrivilegeGetRef]> in
            return Decoders.decode(clazz: [PrivilegeGetRef].self, source: source)
        }

        // Decoder for PrivilegeGetRef
        Decoders.addDecoder(clazz: PrivilegeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PrivilegeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PrivilegeGetRef() : instance as! PrivilegeGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PrivilegeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [PrivilegeUpdate]
        Decoders.addDecoder(clazz: [PrivilegeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PrivilegeUpdate]> in
            return Decoders.decode(clazz: [PrivilegeUpdate].self, source: source)
        }

        // Decoder for PrivilegeUpdate
        Decoders.addDecoder(clazz: PrivilegeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PrivilegeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PrivilegeUpdate() : instance as! PrivilegeUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PrivilegeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramCreate]
        Decoders.addDecoder(clazz: [ProgramCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramCreate]> in
            return Decoders.decode(clazz: [ProgramCreate].self, source: source)
        }

        // Decoder for ProgramCreate
        Decoders.addDecoder(clazz: ProgramCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProgramCreate() : instance as! ProgramCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["outcomesConcept"] as AnyObject?) {
                case let .success(value): _result.outcomesConcept = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramCreateFull]
        Decoders.addDecoder(clazz: [ProgramCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramCreateFull]> in
            return Decoders.decode(clazz: [ProgramCreateFull].self, source: source)
        }

        // Decoder for ProgramCreateFull
        Decoders.addDecoder(clazz: ProgramCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProgramCreateFull() : instance as! ProgramCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptCreate.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptCreate.self, source: sourceDictionary["outcomesConcept"] as AnyObject?) {
                case let .success(value): _result.outcomesConcept = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramGet]
        Decoders.addDecoder(clazz: [ProgramGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramGet]> in
            return Decoders.decode(clazz: [ProgramGet].self, source: source)
        }

        // Decoder for ProgramGet
        Decoders.addDecoder(clazz: ProgramGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProgramGet() : instance as! ProgramGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [WorkflowGetRef].self, source: sourceDictionary["allWorkflows"] as AnyObject?) {
                case let .success(value): _result.allWorkflows = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramGet", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramGetFull]
        Decoders.addDecoder(clazz: [ProgramGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramGetFull]> in
            return Decoders.decode(clazz: [ProgramGetFull].self, source: source)
        }

        // Decoder for ProgramGetFull
        Decoders.addDecoder(clazz: ProgramGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProgramGetFull() : instance as! ProgramGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [WorkflowGet].self, source: sourceDictionary["allWorkflows"] as AnyObject?) {
                case let .success(value): _result.allWorkflows = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramGetRef]
        Decoders.addDecoder(clazz: [ProgramGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramGetRef]> in
            return Decoders.decode(clazz: [ProgramGetRef].self, source: source)
        }

        // Decoder for ProgramGetRef
        Decoders.addDecoder(clazz: ProgramGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProgramGetRef() : instance as! ProgramGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [WorkflowGetRef].self, source: sourceDictionary["allWorkflows"] as AnyObject?) {
                case let .success(value): _result.allWorkflows = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramUpdate]
        Decoders.addDecoder(clazz: [ProgramUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramUpdate]> in
            return Decoders.decode(clazz: [ProgramUpdate].self, source: source)
        }

        // Decoder for ProgramUpdate
        Decoders.addDecoder(clazz: ProgramUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProgramUpdate() : instance as! ProgramUpdate
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramenrollmentCreate]
        Decoders.addDecoder(clazz: [ProgramenrollmentCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramenrollmentCreate]> in
            return Decoders.decode(clazz: [ProgramenrollmentCreate].self, source: source)
        }

        // Decoder for ProgramenrollmentCreate
        Decoders.addDecoder(clazz: ProgramenrollmentCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramenrollmentCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProgramenrollmentCreate() : instance as! ProgramenrollmentCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["patient"] as AnyObject?) {
                case let .success(value): _result.patient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["program"] as AnyObject?) {
                case let .success(value): _result.program = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["dateEnrolled"] as AnyObject?) {
                case let .success(value): _result.dateEnrolled = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["dateCompleted"] as AnyObject?) {
                case let .success(value): _result.dateCompleted = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ProgramenrollmentStateCreate].self, source: sourceDictionary["states"] as AnyObject?) {
                case let .success(value): _result.states = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptCreate.self, source: sourceDictionary["outcome"] as AnyObject?) {
                case let .success(value): _result.outcome = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramenrollmentCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramenrollmentCreateFull]
        Decoders.addDecoder(clazz: [ProgramenrollmentCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramenrollmentCreateFull]> in
            return Decoders.decode(clazz: [ProgramenrollmentCreateFull].self, source: source)
        }

        // Decoder for ProgramenrollmentCreateFull
        Decoders.addDecoder(clazz: ProgramenrollmentCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramenrollmentCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProgramenrollmentCreateFull() : instance as! ProgramenrollmentCreateFull
                switch Decoders.decodeOptional(clazz: PatientCreate.self, source: sourceDictionary["patient"] as AnyObject?) {
                case let .success(value): _result.patient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ProgramCreate.self, source: sourceDictionary["program"] as AnyObject?) {
                case let .success(value): _result.program = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["dateEnrolled"] as AnyObject?) {
                case let .success(value): _result.dateEnrolled = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["dateCompleted"] as AnyObject?) {
                case let .success(value): _result.dateCompleted = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationCreate.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ProgramenrollmentStateCreate].self, source: sourceDictionary["states"] as AnyObject?) {
                case let .success(value): _result.states = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptCreate.self, source: sourceDictionary["outcome"] as AnyObject?) {
                case let .success(value): _result.outcome = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramenrollmentCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramenrollmentGet]
        Decoders.addDecoder(clazz: [ProgramenrollmentGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramenrollmentGet]> in
            return Decoders.decode(clazz: [ProgramenrollmentGet].self, source: source)
        }

        // Decoder for ProgramenrollmentGet
        Decoders.addDecoder(clazz: ProgramenrollmentGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramenrollmentGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProgramenrollmentGet() : instance as! ProgramenrollmentGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["dateEnrolled"] as AnyObject?) {
                case let .success(value): _result.dateEnrolled = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["dateCompleted"] as AnyObject?) {
                case let .success(value): _result.dateCompleted = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientGetRef.self, source: sourceDictionary["patient"] as AnyObject?) {
                case let .success(value): _result.patient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ProgramGetRef.self, source: sourceDictionary["program"] as AnyObject?) {
                case let .success(value): _result.program = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationGetRef.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramenrollmentGet", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramenrollmentGetFull]
        Decoders.addDecoder(clazz: [ProgramenrollmentGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramenrollmentGetFull]> in
            return Decoders.decode(clazz: [ProgramenrollmentGetFull].self, source: source)
        }

        // Decoder for ProgramenrollmentGetFull
        Decoders.addDecoder(clazz: ProgramenrollmentGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramenrollmentGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProgramenrollmentGetFull() : instance as! ProgramenrollmentGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["dateEnrolled"] as AnyObject?) {
                case let .success(value): _result.dateEnrolled = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["dateCompleted"] as AnyObject?) {
                case let .success(value): _result.dateCompleted = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientGet.self, source: sourceDictionary["patient"] as AnyObject?) {
                case let .success(value): _result.patient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ProgramGet.self, source: sourceDictionary["program"] as AnyObject?) {
                case let .success(value): _result.program = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationGet.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramenrollmentGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramenrollmentGetRef]
        Decoders.addDecoder(clazz: [ProgramenrollmentGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramenrollmentGetRef]> in
            return Decoders.decode(clazz: [ProgramenrollmentGetRef].self, source: source)
        }

        // Decoder for ProgramenrollmentGetRef
        Decoders.addDecoder(clazz: ProgramenrollmentGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramenrollmentGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProgramenrollmentGetRef() : instance as! ProgramenrollmentGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramenrollmentGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramenrollmentStateCreate]
        Decoders.addDecoder(clazz: [ProgramenrollmentStateCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramenrollmentStateCreate]> in
            return Decoders.decode(clazz: [ProgramenrollmentStateCreate].self, source: source)
        }

        // Decoder for ProgramenrollmentStateCreate
        Decoders.addDecoder(clazz: ProgramenrollmentStateCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramenrollmentStateCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProgramenrollmentStateCreate() : instance as! ProgramenrollmentStateCreate
                switch Decoders.decodeOptional(clazz: WorkflowStateCreate.self, source: sourceDictionary["state"] as AnyObject?) {
                case let .success(value): _result.state = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramenrollmentStateCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramenrollmentStateCreateFull]
        Decoders.addDecoder(clazz: [ProgramenrollmentStateCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramenrollmentStateCreateFull]> in
            return Decoders.decode(clazz: [ProgramenrollmentStateCreateFull].self, source: source)
        }

        // Decoder for ProgramenrollmentStateCreateFull
        Decoders.addDecoder(clazz: ProgramenrollmentStateCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramenrollmentStateCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProgramenrollmentStateCreateFull() : instance as! ProgramenrollmentStateCreateFull
                switch Decoders.decodeOptional(clazz: WorkflowStateCreate.self, source: sourceDictionary["state"] as AnyObject?) {
                case let .success(value): _result.state = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramenrollmentStateCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramenrollmentStateGet]
        Decoders.addDecoder(clazz: [ProgramenrollmentStateGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramenrollmentStateGet]> in
            return Decoders.decode(clazz: [ProgramenrollmentStateGet].self, source: source)
        }

        // Decoder for ProgramenrollmentStateGet
        Decoders.addDecoder(clazz: ProgramenrollmentStateGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramenrollmentStateGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProgramenrollmentStateGet() : instance as! ProgramenrollmentStateGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: WorkflowStateGet.self, source: sourceDictionary["state"] as AnyObject?) {
                case let .success(value): _result.state = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramenrollmentStateGet", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramenrollmentStateGetFull]
        Decoders.addDecoder(clazz: [ProgramenrollmentStateGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramenrollmentStateGetFull]> in
            return Decoders.decode(clazz: [ProgramenrollmentStateGetFull].self, source: source)
        }

        // Decoder for ProgramenrollmentStateGetFull
        Decoders.addDecoder(clazz: ProgramenrollmentStateGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramenrollmentStateGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProgramenrollmentStateGetFull() : instance as! ProgramenrollmentStateGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: WorkflowStateGetRef.self, source: sourceDictionary["state"] as AnyObject?) {
                case let .success(value): _result.state = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["patientProgram"] as AnyObject?) {
                case let .success(value): _result.patientProgram = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramenrollmentStateGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramenrollmentStateGetRef]
        Decoders.addDecoder(clazz: [ProgramenrollmentStateGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramenrollmentStateGetRef]> in
            return Decoders.decode(clazz: [ProgramenrollmentStateGetRef].self, source: source)
        }

        // Decoder for ProgramenrollmentStateGetRef
        Decoders.addDecoder(clazz: ProgramenrollmentStateGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramenrollmentStateGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProgramenrollmentStateGetRef() : instance as! ProgramenrollmentStateGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: WorkflowStateGetRef.self, source: sourceDictionary["state"] as AnyObject?) {
                case let .success(value): _result.state = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["patientProgram"] as AnyObject?) {
                case let .success(value): _result.patientProgram = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramenrollmentStateGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramenrollmentStateUpdate]
        Decoders.addDecoder(clazz: [ProgramenrollmentStateUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramenrollmentStateUpdate]> in
            return Decoders.decode(clazz: [ProgramenrollmentStateUpdate].self, source: source)
        }

        // Decoder for ProgramenrollmentStateUpdate
        Decoders.addDecoder(clazz: ProgramenrollmentStateUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramenrollmentStateUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProgramenrollmentStateUpdate() : instance as! ProgramenrollmentStateUpdate
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramenrollmentStateUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ProgramenrollmentUpdate]
        Decoders.addDecoder(clazz: [ProgramenrollmentUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProgramenrollmentUpdate]> in
            return Decoders.decode(clazz: [ProgramenrollmentUpdate].self, source: source)
        }

        // Decoder for ProgramenrollmentUpdate
        Decoders.addDecoder(clazz: ProgramenrollmentUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProgramenrollmentUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProgramenrollmentUpdate() : instance as! ProgramenrollmentUpdate
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["dateEnrolled"] as AnyObject?) {
                case let .success(value): _result.dateEnrolled = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ProgramenrollmentStateCreate].self, source: sourceDictionary["states"] as AnyObject?) {
                case let .success(value): _result.states = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptCreate.self, source: sourceDictionary["outcome"] as AnyObject?) {
                case let .success(value): _result.outcome = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationCreate.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["dateCompleted"] as AnyObject?) {
                case let .success(value): _result.dateCompleted = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProgramenrollmentUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderAttributeCreate]
        Decoders.addDecoder(clazz: [ProviderAttributeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderAttributeCreate]> in
            return Decoders.decode(clazz: [ProviderAttributeCreate].self, source: source)
        }

        // Decoder for ProviderAttributeCreate
        Decoders.addDecoder(clazz: ProviderAttributeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderAttributeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProviderAttributeCreate() : instance as! ProviderAttributeCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderAttributeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderAttributeCreateFull]
        Decoders.addDecoder(clazz: [ProviderAttributeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderAttributeCreateFull]> in
            return Decoders.decode(clazz: [ProviderAttributeCreateFull].self, source: source)
        }

        // Decoder for ProviderAttributeCreateFull
        Decoders.addDecoder(clazz: ProviderAttributeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderAttributeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProviderAttributeCreateFull() : instance as! ProviderAttributeCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderAttributeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderAttributeGet]
        Decoders.addDecoder(clazz: [ProviderAttributeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderAttributeGet]> in
            return Decoders.decode(clazz: [ProviderAttributeGet].self, source: source)
        }

        // Decoder for ProviderAttributeGet
        Decoders.addDecoder(clazz: ProviderAttributeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderAttributeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProviderAttributeGet() : instance as! ProviderAttributeGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderAttributeGet", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderAttributeGetFull]
        Decoders.addDecoder(clazz: [ProviderAttributeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderAttributeGetFull]> in
            return Decoders.decode(clazz: [ProviderAttributeGetFull].self, source: source)
        }

        // Decoder for ProviderAttributeGetFull
        Decoders.addDecoder(clazz: ProviderAttributeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderAttributeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProviderAttributeGetFull() : instance as! ProviderAttributeGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderAttributeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderAttributeGetRef]
        Decoders.addDecoder(clazz: [ProviderAttributeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderAttributeGetRef]> in
            return Decoders.decode(clazz: [ProviderAttributeGetRef].self, source: source)
        }

        // Decoder for ProviderAttributeGetRef
        Decoders.addDecoder(clazz: ProviderAttributeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderAttributeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProviderAttributeGetRef() : instance as! ProviderAttributeGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderAttributeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderAttributeUpdate]
        Decoders.addDecoder(clazz: [ProviderAttributeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderAttributeUpdate]> in
            return Decoders.decode(clazz: [ProviderAttributeUpdate].self, source: source)
        }

        // Decoder for ProviderAttributeUpdate
        Decoders.addDecoder(clazz: ProviderAttributeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderAttributeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProviderAttributeUpdate() : instance as! ProviderAttributeUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderAttributeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderCreate]
        Decoders.addDecoder(clazz: [ProviderCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderCreate]> in
            return Decoders.decode(clazz: [ProviderCreate].self, source: source)
        }

        // Decoder for ProviderCreate
        Decoders.addDecoder(clazz: ProviderCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProviderCreate() : instance as! ProviderCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["person"] as AnyObject?) {
                case let .success(value): _result.person = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["identifier"] as AnyObject?) {
                case let .success(value): _result.identifier = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ProviderAttributeCreate].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderCreateFull]
        Decoders.addDecoder(clazz: [ProviderCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderCreateFull]> in
            return Decoders.decode(clazz: [ProviderCreateFull].self, source: source)
        }

        // Decoder for ProviderCreateFull
        Decoders.addDecoder(clazz: ProviderCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProviderCreateFull() : instance as! ProviderCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonCreate.self, source: sourceDictionary["person"] as AnyObject?) {
                case let .success(value): _result.person = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["identifier"] as AnyObject?) {
                case let .success(value): _result.identifier = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ProviderAttributeCreate].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderGet]
        Decoders.addDecoder(clazz: [ProviderGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderGet]> in
            return Decoders.decode(clazz: [ProviderGet].self, source: source)
        }

        // Decoder for ProviderGet
        Decoders.addDecoder(clazz: ProviderGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProviderGet() : instance as! ProviderGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonGetRef.self, source: sourceDictionary["person"] as AnyObject?) {
                case let .success(value): _result.person = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["identifier"] as AnyObject?) {
                case let .success(value): _result.identifier = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ProviderAttributeGetRef].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderGet", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderGetFull]
        Decoders.addDecoder(clazz: [ProviderGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderGetFull]> in
            return Decoders.decode(clazz: [ProviderGetFull].self, source: source)
        }

        // Decoder for ProviderGetFull
        Decoders.addDecoder(clazz: ProviderGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProviderGetFull() : instance as! ProviderGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonGet.self, source: sourceDictionary["person"] as AnyObject?) {
                case let .success(value): _result.person = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["identifier"] as AnyObject?) {
                case let .success(value): _result.identifier = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ProviderAttributeGet].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderGetRef]
        Decoders.addDecoder(clazz: [ProviderGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderGetRef]> in
            return Decoders.decode(clazz: [ProviderGetRef].self, source: source)
        }

        // Decoder for ProviderGetRef
        Decoders.addDecoder(clazz: ProviderGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProviderGetRef() : instance as! ProviderGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderUpdate]
        Decoders.addDecoder(clazz: [ProviderUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderUpdate]> in
            return Decoders.decode(clazz: [ProviderUpdate].self, source: source)
        }

        // Decoder for ProviderUpdate
        Decoders.addDecoder(clazz: ProviderUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProviderUpdate() : instance as! ProviderUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["person"] as AnyObject?) {
                case let .success(value): _result.person = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["identifier"] as AnyObject?) {
                case let .success(value): _result.identifier = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [ProviderAttributeCreate].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderattributetypeCreate]
        Decoders.addDecoder(clazz: [ProviderattributetypeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderattributetypeCreate]> in
            return Decoders.decode(clazz: [ProviderattributetypeCreate].self, source: source)
        }

        // Decoder for ProviderattributetypeCreate
        Decoders.addDecoder(clazz: ProviderattributetypeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderattributetypeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProviderattributetypeCreate() : instance as! ProviderattributetypeCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderattributetypeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderattributetypeCreateFull]
        Decoders.addDecoder(clazz: [ProviderattributetypeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderattributetypeCreateFull]> in
            return Decoders.decode(clazz: [ProviderattributetypeCreateFull].self, source: source)
        }

        // Decoder for ProviderattributetypeCreateFull
        Decoders.addDecoder(clazz: ProviderattributetypeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderattributetypeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProviderattributetypeCreateFull() : instance as! ProviderattributetypeCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderattributetypeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderattributetypeGet]
        Decoders.addDecoder(clazz: [ProviderattributetypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderattributetypeGet]> in
            return Decoders.decode(clazz: [ProviderattributetypeGet].self, source: source)
        }

        // Decoder for ProviderattributetypeGet
        Decoders.addDecoder(clazz: ProviderattributetypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderattributetypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProviderattributetypeGet() : instance as! ProviderattributetypeGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderattributetypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderattributetypeGetFull]
        Decoders.addDecoder(clazz: [ProviderattributetypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderattributetypeGetFull]> in
            return Decoders.decode(clazz: [ProviderattributetypeGetFull].self, source: source)
        }

        // Decoder for ProviderattributetypeGetFull
        Decoders.addDecoder(clazz: ProviderattributetypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderattributetypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProviderattributetypeGetFull() : instance as! ProviderattributetypeGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderattributetypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderattributetypeGetRef]
        Decoders.addDecoder(clazz: [ProviderattributetypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderattributetypeGetRef]> in
            return Decoders.decode(clazz: [ProviderattributetypeGetRef].self, source: source)
        }

        // Decoder for ProviderattributetypeGetRef
        Decoders.addDecoder(clazz: ProviderattributetypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderattributetypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProviderattributetypeGetRef() : instance as! ProviderattributetypeGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderattributetypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ProviderattributetypeUpdate]
        Decoders.addDecoder(clazz: [ProviderattributetypeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ProviderattributetypeUpdate]> in
            return Decoders.decode(clazz: [ProviderattributetypeUpdate].self, source: source)
        }

        // Decoder for ProviderattributetypeUpdate
        Decoders.addDecoder(clazz: ProviderattributetypeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ProviderattributetypeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ProviderattributetypeUpdate() : instance as! ProviderattributetypeUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ProviderattributetypeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [RelationshipCreate]
        Decoders.addDecoder(clazz: [RelationshipCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RelationshipCreate]> in
            return Decoders.decode(clazz: [RelationshipCreate].self, source: source)
        }

        // Decoder for RelationshipCreate
        Decoders.addDecoder(clazz: RelationshipCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RelationshipCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RelationshipCreate() : instance as! RelationshipCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["personA"] as AnyObject?) {
                case let .success(value): _result.personA = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["relationshipType"] as AnyObject?) {
                case let .success(value): _result.relationshipType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["personB"] as AnyObject?) {
                case let .success(value): _result.personB = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RelationshipCreate", actual: "\(source)"))
            }
        }
        // Decoder for [RelationshipCreateFull]
        Decoders.addDecoder(clazz: [RelationshipCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RelationshipCreateFull]> in
            return Decoders.decode(clazz: [RelationshipCreateFull].self, source: source)
        }

        // Decoder for RelationshipCreateFull
        Decoders.addDecoder(clazz: RelationshipCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RelationshipCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RelationshipCreateFull() : instance as! RelationshipCreateFull
                switch Decoders.decodeOptional(clazz: PersonCreate.self, source: sourceDictionary["personA"] as AnyObject?) {
                case let .success(value): _result.personA = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: RelationshiptypeCreate.self, source: sourceDictionary["relationshipType"] as AnyObject?) {
                case let .success(value): _result.relationshipType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonCreate.self, source: sourceDictionary["personB"] as AnyObject?) {
                case let .success(value): _result.personB = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDate"] as AnyObject?) {
                case let .success(value): _result.startDate = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["endDate"] as AnyObject?) {
                case let .success(value): _result.endDate = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RelationshipCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [RelationshipGet]
        Decoders.addDecoder(clazz: [RelationshipGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RelationshipGet]> in
            return Decoders.decode(clazz: [RelationshipGet].self, source: source)
        }

        // Decoder for RelationshipGet
        Decoders.addDecoder(clazz: RelationshipGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RelationshipGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RelationshipGet() : instance as! RelationshipGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonGetRef.self, source: sourceDictionary["personA"] as AnyObject?) {
                case let .success(value): _result.personA = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: RelationshiptypeGetRef.self, source: sourceDictionary["relationshipType"] as AnyObject?) {
                case let .success(value): _result.relationshipType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonGetRef.self, source: sourceDictionary["personB"] as AnyObject?) {
                case let .success(value): _result.personB = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RelationshipGet", actual: "\(source)"))
            }
        }
        // Decoder for [RelationshipGetFull]
        Decoders.addDecoder(clazz: [RelationshipGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RelationshipGetFull]> in
            return Decoders.decode(clazz: [RelationshipGetFull].self, source: source)
        }

        // Decoder for RelationshipGetFull
        Decoders.addDecoder(clazz: RelationshipGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RelationshipGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RelationshipGetFull() : instance as! RelationshipGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonGet.self, source: sourceDictionary["personA"] as AnyObject?) {
                case let .success(value): _result.personA = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: RelationshiptypeGet.self, source: sourceDictionary["relationshipType"] as AnyObject?) {
                case let .success(value): _result.relationshipType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonGet.self, source: sourceDictionary["personB"] as AnyObject?) {
                case let .success(value): _result.personB = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RelationshipGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [RelationshipGetRef]
        Decoders.addDecoder(clazz: [RelationshipGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RelationshipGetRef]> in
            return Decoders.decode(clazz: [RelationshipGetRef].self, source: source)
        }

        // Decoder for RelationshipGetRef
        Decoders.addDecoder(clazz: RelationshipGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RelationshipGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RelationshipGetRef() : instance as! RelationshipGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RelationshipGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [RelationshipUpdate]
        Decoders.addDecoder(clazz: [RelationshipUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RelationshipUpdate]> in
            return Decoders.decode(clazz: [RelationshipUpdate].self, source: source)
        }

        // Decoder for RelationshipUpdate
        Decoders.addDecoder(clazz: RelationshipUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RelationshipUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RelationshipUpdate() : instance as! RelationshipUpdate
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RelationshipUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [RelationshiptypeCreate]
        Decoders.addDecoder(clazz: [RelationshiptypeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RelationshiptypeCreate]> in
            return Decoders.decode(clazz: [RelationshiptypeCreate].self, source: source)
        }

        // Decoder for RelationshiptypeCreate
        Decoders.addDecoder(clazz: RelationshiptypeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RelationshiptypeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RelationshiptypeCreate() : instance as! RelationshiptypeCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["aIsToB"] as AnyObject?) {
                case let .success(value): _result.aIsToB = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["bIsToA"] as AnyObject?) {
                case let .success(value): _result.bIsToA = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["weight"] as AnyObject?) {
                case let .success(value): _result.weight = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RelationshiptypeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [RelationshiptypeCreateFull]
        Decoders.addDecoder(clazz: [RelationshiptypeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RelationshiptypeCreateFull]> in
            return Decoders.decode(clazz: [RelationshiptypeCreateFull].self, source: source)
        }

        // Decoder for RelationshiptypeCreateFull
        Decoders.addDecoder(clazz: RelationshiptypeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RelationshiptypeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RelationshiptypeCreateFull() : instance as! RelationshiptypeCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["aIsToB"] as AnyObject?) {
                case let .success(value): _result.aIsToB = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["bIsToA"] as AnyObject?) {
                case let .success(value): _result.bIsToA = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["weight"] as AnyObject?) {
                case let .success(value): _result.weight = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RelationshiptypeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [RelationshiptypeGet]
        Decoders.addDecoder(clazz: [RelationshiptypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RelationshiptypeGet]> in
            return Decoders.decode(clazz: [RelationshiptypeGet].self, source: source)
        }

        // Decoder for RelationshiptypeGet
        Decoders.addDecoder(clazz: RelationshiptypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RelationshiptypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RelationshiptypeGet() : instance as! RelationshiptypeGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["aIsToB"] as AnyObject?) {
                case let .success(value): _result.aIsToB = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["bIsToA"] as AnyObject?) {
                case let .success(value): _result.bIsToA = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RelationshiptypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [RelationshiptypeGetFull]
        Decoders.addDecoder(clazz: [RelationshiptypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RelationshiptypeGetFull]> in
            return Decoders.decode(clazz: [RelationshiptypeGetFull].self, source: source)
        }

        // Decoder for RelationshiptypeGetFull
        Decoders.addDecoder(clazz: RelationshiptypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RelationshiptypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RelationshiptypeGetFull() : instance as! RelationshiptypeGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["aIsToB"] as AnyObject?) {
                case let .success(value): _result.aIsToB = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["bIsToA"] as AnyObject?) {
                case let .success(value): _result.bIsToA = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["weight"] as AnyObject?) {
                case let .success(value): _result.weight = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RelationshiptypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [RelationshiptypeGetRef]
        Decoders.addDecoder(clazz: [RelationshiptypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RelationshiptypeGetRef]> in
            return Decoders.decode(clazz: [RelationshiptypeGetRef].self, source: source)
        }

        // Decoder for RelationshiptypeGetRef
        Decoders.addDecoder(clazz: RelationshiptypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RelationshiptypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RelationshiptypeGetRef() : instance as! RelationshiptypeGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RelationshiptypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [RelationshiptypeUpdate]
        Decoders.addDecoder(clazz: [RelationshiptypeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RelationshiptypeUpdate]> in
            return Decoders.decode(clazz: [RelationshiptypeUpdate].self, source: source)
        }

        // Decoder for RelationshiptypeUpdate
        Decoders.addDecoder(clazz: RelationshiptypeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RelationshiptypeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RelationshiptypeUpdate() : instance as! RelationshiptypeUpdate
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RelationshiptypeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestCohortDefinitionCreate]
        Decoders.addDecoder(clazz: [ReportingrestCohortDefinitionCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestCohortDefinitionCreate]> in
            return Decoders.decode(clazz: [ReportingrestCohortDefinitionCreate].self, source: source)
        }

        // Decoder for ReportingrestCohortDefinitionCreate
        Decoders.addDecoder(clazz: ReportingrestCohortDefinitionCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestCohortDefinitionCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestCohortDefinitionCreate() : instance as! ReportingrestCohortDefinitionCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestCohortDefinitionCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestCohortDefinitionCreateFull]
        Decoders.addDecoder(clazz: [ReportingrestCohortDefinitionCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestCohortDefinitionCreateFull]> in
            return Decoders.decode(clazz: [ReportingrestCohortDefinitionCreateFull].self, source: source)
        }

        // Decoder for ReportingrestCohortDefinitionCreateFull
        Decoders.addDecoder(clazz: ReportingrestCohortDefinitionCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestCohortDefinitionCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestCohortDefinitionCreateFull() : instance as! ReportingrestCohortDefinitionCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestCohortDefinitionCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestCohortDefinitionGet]
        Decoders.addDecoder(clazz: [ReportingrestCohortDefinitionGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestCohortDefinitionGet]> in
            return Decoders.decode(clazz: [ReportingrestCohortDefinitionGet].self, source: source)
        }

        // Decoder for ReportingrestCohortDefinitionGet
        Decoders.addDecoder(clazz: ReportingrestCohortDefinitionGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestCohortDefinitionGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestCohortDefinitionGet() : instance as! ReportingrestCohortDefinitionGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestCohortDefinitionGet", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestCohortDefinitionGetFull]
        Decoders.addDecoder(clazz: [ReportingrestCohortDefinitionGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestCohortDefinitionGetFull]> in
            return Decoders.decode(clazz: [ReportingrestCohortDefinitionGetFull].self, source: source)
        }

        // Decoder for ReportingrestCohortDefinitionGetFull
        Decoders.addDecoder(clazz: ReportingrestCohortDefinitionGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestCohortDefinitionGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestCohortDefinitionGetFull() : instance as! ReportingrestCohortDefinitionGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestCohortDefinitionGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestCohortDefinitionGetRef]
        Decoders.addDecoder(clazz: [ReportingrestCohortDefinitionGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestCohortDefinitionGetRef]> in
            return Decoders.decode(clazz: [ReportingrestCohortDefinitionGetRef].self, source: source)
        }

        // Decoder for ReportingrestCohortDefinitionGetRef
        Decoders.addDecoder(clazz: ReportingrestCohortDefinitionGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestCohortDefinitionGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestCohortDefinitionGetRef() : instance as! ReportingrestCohortDefinitionGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestCohortDefinitionGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestCohortDefinitionUpdate]
        Decoders.addDecoder(clazz: [ReportingrestCohortDefinitionUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestCohortDefinitionUpdate]> in
            return Decoders.decode(clazz: [ReportingrestCohortDefinitionUpdate].self, source: source)
        }

        // Decoder for ReportingrestCohortDefinitionUpdate
        Decoders.addDecoder(clazz: ReportingrestCohortDefinitionUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestCohortDefinitionUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestCohortDefinitionUpdate() : instance as! ReportingrestCohortDefinitionUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestCohortDefinitionUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestCohortGet]
        Decoders.addDecoder(clazz: [ReportingrestCohortGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestCohortGet]> in
            return Decoders.decode(clazz: [ReportingrestCohortGet].self, source: source)
        }

        // Decoder for ReportingrestCohortGet
        Decoders.addDecoder(clazz: ReportingrestCohortGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestCohortGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestCohortGet() : instance as! ReportingrestCohortGet
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestCohortGet", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestCohortGetFull]
        Decoders.addDecoder(clazz: [ReportingrestCohortGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestCohortGetFull]> in
            return Decoders.decode(clazz: [ReportingrestCohortGetFull].self, source: source)
        }

        // Decoder for ReportingrestCohortGetFull
        Decoders.addDecoder(clazz: ReportingrestCohortGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestCohortGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestCohortGetFull() : instance as! ReportingrestCohortGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestCohortGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestCohortGetRef]
        Decoders.addDecoder(clazz: [ReportingrestCohortGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestCohortGetRef]> in
            return Decoders.decode(clazz: [ReportingrestCohortGetRef].self, source: source)
        }

        // Decoder for ReportingrestCohortGetRef
        Decoders.addDecoder(clazz: ReportingrestCohortGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestCohortGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestCohortGetRef() : instance as! ReportingrestCohortGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestCohortGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestDataSetDefinitionCreate]
        Decoders.addDecoder(clazz: [ReportingrestDataSetDefinitionCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestDataSetDefinitionCreate]> in
            return Decoders.decode(clazz: [ReportingrestDataSetDefinitionCreate].self, source: source)
        }

        // Decoder for ReportingrestDataSetDefinitionCreate
        Decoders.addDecoder(clazz: ReportingrestDataSetDefinitionCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestDataSetDefinitionCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestDataSetDefinitionCreate() : instance as! ReportingrestDataSetDefinitionCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestDataSetDefinitionCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestDataSetDefinitionCreateFull]
        Decoders.addDecoder(clazz: [ReportingrestDataSetDefinitionCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestDataSetDefinitionCreateFull]> in
            return Decoders.decode(clazz: [ReportingrestDataSetDefinitionCreateFull].self, source: source)
        }

        // Decoder for ReportingrestDataSetDefinitionCreateFull
        Decoders.addDecoder(clazz: ReportingrestDataSetDefinitionCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestDataSetDefinitionCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestDataSetDefinitionCreateFull() : instance as! ReportingrestDataSetDefinitionCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestDataSetDefinitionCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestDataSetDefinitionGet]
        Decoders.addDecoder(clazz: [ReportingrestDataSetDefinitionGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestDataSetDefinitionGet]> in
            return Decoders.decode(clazz: [ReportingrestDataSetDefinitionGet].self, source: source)
        }

        // Decoder for ReportingrestDataSetDefinitionGet
        Decoders.addDecoder(clazz: ReportingrestDataSetDefinitionGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestDataSetDefinitionGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestDataSetDefinitionGet() : instance as! ReportingrestDataSetDefinitionGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestDataSetDefinitionGet", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestDataSetDefinitionGetFull]
        Decoders.addDecoder(clazz: [ReportingrestDataSetDefinitionGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestDataSetDefinitionGetFull]> in
            return Decoders.decode(clazz: [ReportingrestDataSetDefinitionGetFull].self, source: source)
        }

        // Decoder for ReportingrestDataSetDefinitionGetFull
        Decoders.addDecoder(clazz: ReportingrestDataSetDefinitionGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestDataSetDefinitionGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestDataSetDefinitionGetFull() : instance as! ReportingrestDataSetDefinitionGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestDataSetDefinitionGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestDataSetDefinitionGetRef]
        Decoders.addDecoder(clazz: [ReportingrestDataSetDefinitionGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestDataSetDefinitionGetRef]> in
            return Decoders.decode(clazz: [ReportingrestDataSetDefinitionGetRef].self, source: source)
        }

        // Decoder for ReportingrestDataSetDefinitionGetRef
        Decoders.addDecoder(clazz: ReportingrestDataSetDefinitionGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestDataSetDefinitionGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestDataSetDefinitionGetRef() : instance as! ReportingrestDataSetDefinitionGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestDataSetDefinitionGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestDataSetDefinitionUpdate]
        Decoders.addDecoder(clazz: [ReportingrestDataSetDefinitionUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestDataSetDefinitionUpdate]> in
            return Decoders.decode(clazz: [ReportingrestDataSetDefinitionUpdate].self, source: source)
        }

        // Decoder for ReportingrestDataSetDefinitionUpdate
        Decoders.addDecoder(clazz: ReportingrestDataSetDefinitionUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestDataSetDefinitionUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestDataSetDefinitionUpdate() : instance as! ReportingrestDataSetDefinitionUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestDataSetDefinitionUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestDataSetGet]
        Decoders.addDecoder(clazz: [ReportingrestDataSetGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestDataSetGet]> in
            return Decoders.decode(clazz: [ReportingrestDataSetGet].self, source: source)
        }

        // Decoder for ReportingrestDataSetGet
        Decoders.addDecoder(clazz: ReportingrestDataSetGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestDataSetGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestDataSetGet() : instance as! ReportingrestDataSetGet
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestDataSetGet", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestDataSetGetFull]
        Decoders.addDecoder(clazz: [ReportingrestDataSetGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestDataSetGetFull]> in
            return Decoders.decode(clazz: [ReportingrestDataSetGetFull].self, source: source)
        }

        // Decoder for ReportingrestDataSetGetFull
        Decoders.addDecoder(clazz: ReportingrestDataSetGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestDataSetGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestDataSetGetFull() : instance as! ReportingrestDataSetGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestDataSetGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestDataSetGetRef]
        Decoders.addDecoder(clazz: [ReportingrestDataSetGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestDataSetGetRef]> in
            return Decoders.decode(clazz: [ReportingrestDataSetGetRef].self, source: source)
        }

        // Decoder for ReportingrestDataSetGetRef
        Decoders.addDecoder(clazz: ReportingrestDataSetGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestDataSetGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestDataSetGetRef() : instance as! ReportingrestDataSetGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestDataSetGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestReportDefinitionCreate]
        Decoders.addDecoder(clazz: [ReportingrestReportDefinitionCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestReportDefinitionCreate]> in
            return Decoders.decode(clazz: [ReportingrestReportDefinitionCreate].self, source: source)
        }

        // Decoder for ReportingrestReportDefinitionCreate
        Decoders.addDecoder(clazz: ReportingrestReportDefinitionCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestReportDefinitionCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestReportDefinitionCreate() : instance as! ReportingrestReportDefinitionCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestReportDefinitionCreate", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestReportDefinitionCreateFull]
        Decoders.addDecoder(clazz: [ReportingrestReportDefinitionCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestReportDefinitionCreateFull]> in
            return Decoders.decode(clazz: [ReportingrestReportDefinitionCreateFull].self, source: source)
        }

        // Decoder for ReportingrestReportDefinitionCreateFull
        Decoders.addDecoder(clazz: ReportingrestReportDefinitionCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestReportDefinitionCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestReportDefinitionCreateFull() : instance as! ReportingrestReportDefinitionCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestReportDefinitionCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestReportDefinitionGet]
        Decoders.addDecoder(clazz: [ReportingrestReportDefinitionGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestReportDefinitionGet]> in
            return Decoders.decode(clazz: [ReportingrestReportDefinitionGet].self, source: source)
        }

        // Decoder for ReportingrestReportDefinitionGet
        Decoders.addDecoder(clazz: ReportingrestReportDefinitionGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestReportDefinitionGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestReportDefinitionGet() : instance as! ReportingrestReportDefinitionGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestReportDefinitionGet", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestReportDefinitionGetFull]
        Decoders.addDecoder(clazz: [ReportingrestReportDefinitionGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestReportDefinitionGetFull]> in
            return Decoders.decode(clazz: [ReportingrestReportDefinitionGetFull].self, source: source)
        }

        // Decoder for ReportingrestReportDefinitionGetFull
        Decoders.addDecoder(clazz: ReportingrestReportDefinitionGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestReportDefinitionGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestReportDefinitionGetFull() : instance as! ReportingrestReportDefinitionGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestReportDefinitionGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestReportDefinitionGetRef]
        Decoders.addDecoder(clazz: [ReportingrestReportDefinitionGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestReportDefinitionGetRef]> in
            return Decoders.decode(clazz: [ReportingrestReportDefinitionGetRef].self, source: source)
        }

        // Decoder for ReportingrestReportDefinitionGetRef
        Decoders.addDecoder(clazz: ReportingrestReportDefinitionGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestReportDefinitionGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestReportDefinitionGetRef() : instance as! ReportingrestReportDefinitionGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestReportDefinitionGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestReportDefinitionUpdate]
        Decoders.addDecoder(clazz: [ReportingrestReportDefinitionUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestReportDefinitionUpdate]> in
            return Decoders.decode(clazz: [ReportingrestReportDefinitionUpdate].self, source: source)
        }

        // Decoder for ReportingrestReportDefinitionUpdate
        Decoders.addDecoder(clazz: ReportingrestReportDefinitionUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestReportDefinitionUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestReportDefinitionUpdate() : instance as! ReportingrestReportDefinitionUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestReportDefinitionUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestReportRequestGet]
        Decoders.addDecoder(clazz: [ReportingrestReportRequestGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestReportRequestGet]> in
            return Decoders.decode(clazz: [ReportingrestReportRequestGet].self, source: source)
        }

        // Decoder for ReportingrestReportRequestGet
        Decoders.addDecoder(clazz: ReportingrestReportRequestGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestReportRequestGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestReportRequestGet() : instance as! ReportingrestReportRequestGet
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestReportRequestGet", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestReportRequestGetFull]
        Decoders.addDecoder(clazz: [ReportingrestReportRequestGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestReportRequestGetFull]> in
            return Decoders.decode(clazz: [ReportingrestReportRequestGetFull].self, source: source)
        }

        // Decoder for ReportingrestReportRequestGetFull
        Decoders.addDecoder(clazz: ReportingrestReportRequestGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestReportRequestGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestReportRequestGetFull() : instance as! ReportingrestReportRequestGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestReportRequestGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestReportRequestGetRef]
        Decoders.addDecoder(clazz: [ReportingrestReportRequestGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestReportRequestGetRef]> in
            return Decoders.decode(clazz: [ReportingrestReportRequestGetRef].self, source: source)
        }

        // Decoder for ReportingrestReportRequestGetRef
        Decoders.addDecoder(clazz: ReportingrestReportRequestGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestReportRequestGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestReportRequestGetRef() : instance as! ReportingrestReportRequestGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestReportRequestGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestReportdataGet]
        Decoders.addDecoder(clazz: [ReportingrestReportdataGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestReportdataGet]> in
            return Decoders.decode(clazz: [ReportingrestReportdataGet].self, source: source)
        }

        // Decoder for ReportingrestReportdataGet
        Decoders.addDecoder(clazz: ReportingrestReportdataGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestReportdataGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestReportdataGet() : instance as! ReportingrestReportdataGet
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestReportdataGet", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestReportdataGetFull]
        Decoders.addDecoder(clazz: [ReportingrestReportdataGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestReportdataGetFull]> in
            return Decoders.decode(clazz: [ReportingrestReportdataGetFull].self, source: source)
        }

        // Decoder for ReportingrestReportdataGetFull
        Decoders.addDecoder(clazz: ReportingrestReportdataGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestReportdataGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestReportdataGetFull() : instance as! ReportingrestReportdataGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestReportdataGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingrestReportdataGetRef]
        Decoders.addDecoder(clazz: [ReportingrestReportdataGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingrestReportdataGetRef]> in
            return Decoders.decode(clazz: [ReportingrestReportdataGetRef].self, source: source)
        }

        // Decoder for ReportingrestReportdataGetRef
        Decoders.addDecoder(clazz: ReportingrestReportdataGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingrestReportdataGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingrestReportdataGetRef() : instance as! ReportingrestReportdataGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingrestReportdataGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [RoleCreate]
        Decoders.addDecoder(clazz: [RoleCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RoleCreate]> in
            return Decoders.decode(clazz: [RoleCreate].self, source: source)
        }

        // Decoder for RoleCreate
        Decoders.addDecoder(clazz: RoleCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RoleCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RoleCreate() : instance as! RoleCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PrivilegeCreate].self, source: sourceDictionary["privileges"] as AnyObject?) {
                case let .success(value): _result.privileges = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [RoleCreate].self, source: sourceDictionary["inheritedRoles"] as AnyObject?) {
                case let .success(value): _result.inheritedRoles = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RoleCreate", actual: "\(source)"))
            }
        }
        // Decoder for [RoleCreateFull]
        Decoders.addDecoder(clazz: [RoleCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RoleCreateFull]> in
            return Decoders.decode(clazz: [RoleCreateFull].self, source: source)
        }

        // Decoder for RoleCreateFull
        Decoders.addDecoder(clazz: RoleCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RoleCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RoleCreateFull() : instance as! RoleCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PrivilegeCreate].self, source: sourceDictionary["privileges"] as AnyObject?) {
                case let .success(value): _result.privileges = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [RoleCreate].self, source: sourceDictionary["inheritedRoles"] as AnyObject?) {
                case let .success(value): _result.inheritedRoles = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RoleCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [RoleGet]
        Decoders.addDecoder(clazz: [RoleGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RoleGet]> in
            return Decoders.decode(clazz: [RoleGet].self, source: source)
        }

        // Decoder for RoleGet
        Decoders.addDecoder(clazz: RoleGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RoleGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RoleGet() : instance as! RoleGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PrivilegeGetRef].self, source: sourceDictionary["privileges"] as AnyObject?) {
                case let .success(value): _result.privileges = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [RoleGetRef].self, source: sourceDictionary["inheritedRoles"] as AnyObject?) {
                case let .success(value): _result.inheritedRoles = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RoleGet", actual: "\(source)"))
            }
        }
        // Decoder for [RoleGetFull]
        Decoders.addDecoder(clazz: [RoleGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RoleGetFull]> in
            return Decoders.decode(clazz: [RoleGetFull].self, source: source)
        }

        // Decoder for RoleGetFull
        Decoders.addDecoder(clazz: RoleGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RoleGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RoleGetFull() : instance as! RoleGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PrivilegeGet].self, source: sourceDictionary["privileges"] as AnyObject?) {
                case let .success(value): _result.privileges = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [RoleGet].self, source: sourceDictionary["inheritedRoles"] as AnyObject?) {
                case let .success(value): _result.inheritedRoles = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [RoleGet].self, source: sourceDictionary["allInheritedRoles"] as AnyObject?) {
                case let .success(value): _result.allInheritedRoles = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RoleGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [RoleGetRef]
        Decoders.addDecoder(clazz: [RoleGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RoleGetRef]> in
            return Decoders.decode(clazz: [RoleGetRef].self, source: source)
        }

        // Decoder for RoleGetRef
        Decoders.addDecoder(clazz: RoleGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RoleGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RoleGetRef() : instance as! RoleGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RoleGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [RoleUpdate]
        Decoders.addDecoder(clazz: [RoleUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RoleUpdate]> in
            return Decoders.decode(clazz: [RoleUpdate].self, source: source)
        }

        // Decoder for RoleUpdate
        Decoders.addDecoder(clazz: RoleUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RoleUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RoleUpdate() : instance as! RoleUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PrivilegeCreate].self, source: sourceDictionary["privileges"] as AnyObject?) {
                case let .success(value): _result.privileges = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [RoleCreate].self, source: sourceDictionary["inheritedRoles"] as AnyObject?) {
                case let .success(value): _result.inheritedRoles = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RoleUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [ServerlogGet]
        Decoders.addDecoder(clazz: [ServerlogGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ServerlogGet]> in
            return Decoders.decode(clazz: [ServerlogGet].self, source: source)
        }

        // Decoder for ServerlogGet
        Decoders.addDecoder(clazz: ServerlogGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ServerlogGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ServerlogGet() : instance as! ServerlogGet
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["serverLog"] as AnyObject?) {
                case let .success(value): _result.serverLog = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ServerlogGet", actual: "\(source)"))
            }
        }
        // Decoder for [ServerlogGetFull]
        Decoders.addDecoder(clazz: [ServerlogGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ServerlogGetFull]> in
            return Decoders.decode(clazz: [ServerlogGetFull].self, source: source)
        }

        // Decoder for ServerlogGetFull
        Decoders.addDecoder(clazz: ServerlogGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ServerlogGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ServerlogGetFull() : instance as! ServerlogGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["serverLog"] as AnyObject?) {
                case let .success(value): _result.serverLog = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ServerlogGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [ServerlogGetRef]
        Decoders.addDecoder(clazz: [ServerlogGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ServerlogGetRef]> in
            return Decoders.decode(clazz: [ServerlogGetRef].self, source: source)
        }

        // Decoder for ServerlogGetRef
        Decoders.addDecoder(clazz: ServerlogGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ServerlogGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ServerlogGetRef() : instance as! ServerlogGetRef
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["serverLog"] as AnyObject?) {
                case let .success(value): _result.serverLog = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ServerlogGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [SystemsettingCreate]
        Decoders.addDecoder(clazz: [SystemsettingCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[SystemsettingCreate]> in
            return Decoders.decode(clazz: [SystemsettingCreate].self, source: source)
        }

        // Decoder for SystemsettingCreate
        Decoders.addDecoder(clazz: SystemsettingCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SystemsettingCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? SystemsettingCreate() : instance as! SystemsettingCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["property"] as AnyObject?) {
                case let .success(value): _result.property = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "SystemsettingCreate", actual: "\(source)"))
            }
        }
        // Decoder for [SystemsettingCreateFull]
        Decoders.addDecoder(clazz: [SystemsettingCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[SystemsettingCreateFull]> in
            return Decoders.decode(clazz: [SystemsettingCreateFull].self, source: source)
        }

        // Decoder for SystemsettingCreateFull
        Decoders.addDecoder(clazz: SystemsettingCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SystemsettingCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? SystemsettingCreateFull() : instance as! SystemsettingCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["property"] as AnyObject?) {
                case let .success(value): _result.property = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "SystemsettingCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [SystemsettingGet]
        Decoders.addDecoder(clazz: [SystemsettingGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[SystemsettingGet]> in
            return Decoders.decode(clazz: [SystemsettingGet].self, source: source)
        }

        // Decoder for SystemsettingGet
        Decoders.addDecoder(clazz: SystemsettingGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SystemsettingGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? SystemsettingGet() : instance as! SystemsettingGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["property"] as AnyObject?) {
                case let .success(value): _result.property = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "SystemsettingGet", actual: "\(source)"))
            }
        }
        // Decoder for [SystemsettingGetFull]
        Decoders.addDecoder(clazz: [SystemsettingGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[SystemsettingGetFull]> in
            return Decoders.decode(clazz: [SystemsettingGetFull].self, source: source)
        }

        // Decoder for SystemsettingGetFull
        Decoders.addDecoder(clazz: SystemsettingGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SystemsettingGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? SystemsettingGetFull() : instance as! SystemsettingGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["property"] as AnyObject?) {
                case let .success(value): _result.property = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "SystemsettingGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [SystemsettingGetRef]
        Decoders.addDecoder(clazz: [SystemsettingGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[SystemsettingGetRef]> in
            return Decoders.decode(clazz: [SystemsettingGetRef].self, source: source)
        }

        // Decoder for SystemsettingGetRef
        Decoders.addDecoder(clazz: SystemsettingGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SystemsettingGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? SystemsettingGetRef() : instance as! SystemsettingGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "SystemsettingGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [SystemsettingUpdate]
        Decoders.addDecoder(clazz: [SystemsettingUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[SystemsettingUpdate]> in
            return Decoders.decode(clazz: [SystemsettingUpdate].self, source: source)
        }

        // Decoder for SystemsettingUpdate
        Decoders.addDecoder(clazz: SystemsettingUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SystemsettingUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? SystemsettingUpdate() : instance as! SystemsettingUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "SystemsettingUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [TaskactionCreate]
        Decoders.addDecoder(clazz: [TaskactionCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaskactionCreate]> in
            return Decoders.decode(clazz: [TaskactionCreate].self, source: source)
        }

        // Decoder for TaskactionCreate
        Decoders.addDecoder(clazz: TaskactionCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaskactionCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TaskactionCreate() : instance as! TaskactionCreate
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["tasks"] as AnyObject?) {
                case let .success(value): _result.tasks = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["allTasks"] as AnyObject?) {
                case let .success(value): _result.allTasks = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: TaskactionCreate.Action.self, source: sourceDictionary["action"] as AnyObject?) {
                case let .success(value): _result.action = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaskactionCreate", actual: "\(source)"))
            }
        }
        // Decoder for [TaskactionCreateFull]
        Decoders.addDecoder(clazz: [TaskactionCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaskactionCreateFull]> in
            return Decoders.decode(clazz: [TaskactionCreateFull].self, source: source)
        }

        // Decoder for TaskactionCreateFull
        Decoders.addDecoder(clazz: TaskactionCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaskactionCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TaskactionCreateFull() : instance as! TaskactionCreateFull
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["tasks"] as AnyObject?) {
                case let .success(value): _result.tasks = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["allTasks"] as AnyObject?) {
                case let .success(value): _result.allTasks = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: TaskactionCreateFull.Action.self, source: sourceDictionary["action"] as AnyObject?) {
                case let .success(value): _result.action = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaskactionCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [TaskactionGet]
        Decoders.addDecoder(clazz: [TaskactionGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaskactionGet]> in
            return Decoders.decode(clazz: [TaskactionGet].self, source: source)
        }

        // Decoder for TaskactionGet
        Decoders.addDecoder(clazz: TaskactionGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaskactionGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TaskactionGet() : instance as! TaskactionGet
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaskactionGet", actual: "\(source)"))
            }
        }
        // Decoder for [TaskactionGetFull]
        Decoders.addDecoder(clazz: [TaskactionGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaskactionGetFull]> in
            return Decoders.decode(clazz: [TaskactionGetFull].self, source: source)
        }

        // Decoder for TaskactionGetFull
        Decoders.addDecoder(clazz: TaskactionGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaskactionGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TaskactionGetFull() : instance as! TaskactionGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaskactionGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [TaskactionGetRef]
        Decoders.addDecoder(clazz: [TaskactionGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaskactionGetRef]> in
            return Decoders.decode(clazz: [TaskactionGetRef].self, source: source)
        }

        // Decoder for TaskactionGetRef
        Decoders.addDecoder(clazz: TaskactionGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaskactionGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TaskactionGetRef() : instance as! TaskactionGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaskactionGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [TaskdefinitionCreate]
        Decoders.addDecoder(clazz: [TaskdefinitionCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaskdefinitionCreate]> in
            return Decoders.decode(clazz: [TaskdefinitionCreate].self, source: source)
        }

        // Decoder for TaskdefinitionCreate
        Decoders.addDecoder(clazz: TaskdefinitionCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaskdefinitionCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TaskdefinitionCreate() : instance as! TaskdefinitionCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaskdefinitionCreate", actual: "\(source)"))
            }
        }
        // Decoder for [TaskdefinitionCreateFull]
        Decoders.addDecoder(clazz: [TaskdefinitionCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaskdefinitionCreateFull]> in
            return Decoders.decode(clazz: [TaskdefinitionCreateFull].self, source: source)
        }

        // Decoder for TaskdefinitionCreateFull
        Decoders.addDecoder(clazz: TaskdefinitionCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaskdefinitionCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TaskdefinitionCreateFull() : instance as! TaskdefinitionCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaskdefinitionCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [TaskdefinitionGet]
        Decoders.addDecoder(clazz: [TaskdefinitionGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaskdefinitionGet]> in
            return Decoders.decode(clazz: [TaskdefinitionGet].self, source: source)
        }

        // Decoder for TaskdefinitionGet
        Decoders.addDecoder(clazz: TaskdefinitionGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaskdefinitionGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TaskdefinitionGet() : instance as! TaskdefinitionGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaskdefinitionGet", actual: "\(source)"))
            }
        }
        // Decoder for [TaskdefinitionGetFull]
        Decoders.addDecoder(clazz: [TaskdefinitionGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaskdefinitionGetFull]> in
            return Decoders.decode(clazz: [TaskdefinitionGetFull].self, source: source)
        }

        // Decoder for TaskdefinitionGetFull
        Decoders.addDecoder(clazz: TaskdefinitionGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaskdefinitionGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TaskdefinitionGetFull() : instance as! TaskdefinitionGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaskdefinitionGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [TaskdefinitionGetRef]
        Decoders.addDecoder(clazz: [TaskdefinitionGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaskdefinitionGetRef]> in
            return Decoders.decode(clazz: [TaskdefinitionGetRef].self, source: source)
        }

        // Decoder for TaskdefinitionGetRef
        Decoders.addDecoder(clazz: TaskdefinitionGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaskdefinitionGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TaskdefinitionGetRef() : instance as! TaskdefinitionGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaskdefinitionGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [TaskdefinitionUpdate]
        Decoders.addDecoder(clazz: [TaskdefinitionUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaskdefinitionUpdate]> in
            return Decoders.decode(clazz: [TaskdefinitionUpdate].self, source: source)
        }

        // Decoder for TaskdefinitionUpdate
        Decoders.addDecoder(clazz: TaskdefinitionUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaskdefinitionUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TaskdefinitionUpdate() : instance as! TaskdefinitionUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaskdefinitionUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [UserCreate]
        Decoders.addDecoder(clazz: [UserCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UserCreate]> in
            return Decoders.decode(clazz: [UserCreate].self, source: source)
        }

        // Decoder for UserCreate
        Decoders.addDecoder(clazz: UserCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? UserCreate() : instance as! UserCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["username"] as AnyObject?) {
                case let .success(value): _result.username = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["password"] as AnyObject?) {
                case let .success(value): _result.password = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonCreate.self, source: sourceDictionary["person"] as AnyObject?) {
                case let .success(value): _result.person = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["systemId"] as AnyObject?) {
                case let .success(value): _result.systemId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["userProperties"] as AnyObject?) {
                case let .success(value): _result.userProperties = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [RoleCreate].self, source: sourceDictionary["roles"] as AnyObject?) {
                case let .success(value): _result.roles = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Any].self, source: sourceDictionary["proficientLocales"] as AnyObject?) {
                case let .success(value): _result.proficientLocales = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["secretQuestion"] as AnyObject?) {
                case let .success(value): _result.secretQuestion = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UserCreate", actual: "\(source)"))
            }
        }
        // Decoder for [UserCreateFull]
        Decoders.addDecoder(clazz: [UserCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UserCreateFull]> in
            return Decoders.decode(clazz: [UserCreateFull].self, source: source)
        }

        // Decoder for UserCreateFull
        Decoders.addDecoder(clazz: UserCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? UserCreateFull() : instance as! UserCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["username"] as AnyObject?) {
                case let .success(value): _result.username = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["password"] as AnyObject?) {
                case let .success(value): _result.password = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonCreate.self, source: sourceDictionary["person"] as AnyObject?) {
                case let .success(value): _result.person = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["systemId"] as AnyObject?) {
                case let .success(value): _result.systemId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["userProperties"] as AnyObject?) {
                case let .success(value): _result.userProperties = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [RoleCreate].self, source: sourceDictionary["roles"] as AnyObject?) {
                case let .success(value): _result.roles = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Any].self, source: sourceDictionary["proficientLocales"] as AnyObject?) {
                case let .success(value): _result.proficientLocales = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["secretQuestion"] as AnyObject?) {
                case let .success(value): _result.secretQuestion = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UserCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [UserGet]
        Decoders.addDecoder(clazz: [UserGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UserGet]> in
            return Decoders.decode(clazz: [UserGet].self, source: source)
        }

        // Decoder for UserGet
        Decoders.addDecoder(clazz: UserGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? UserGet() : instance as! UserGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["username"] as AnyObject?) {
                case let .success(value): _result.username = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["systemId"] as AnyObject?) {
                case let .success(value): _result.systemId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["userProperties"] as AnyObject?) {
                case let .success(value): _result.userProperties = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonGetRef.self, source: sourceDictionary["person"] as AnyObject?) {
                case let .success(value): _result.person = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PrivilegeGetRef].self, source: sourceDictionary["privileges"] as AnyObject?) {
                case let .success(value): _result.privileges = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [RoleGetRef].self, source: sourceDictionary["roles"] as AnyObject?) {
                case let .success(value): _result.roles = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UserGet", actual: "\(source)"))
            }
        }
        // Decoder for [UserGetFull]
        Decoders.addDecoder(clazz: [UserGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UserGetFull]> in
            return Decoders.decode(clazz: [UserGetFull].self, source: source)
        }

        // Decoder for UserGetFull
        Decoders.addDecoder(clazz: UserGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? UserGetFull() : instance as! UserGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["username"] as AnyObject?) {
                case let .success(value): _result.username = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["systemId"] as AnyObject?) {
                case let .success(value): _result.systemId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["userProperties"] as AnyObject?) {
                case let .success(value): _result.userProperties = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonGet.self, source: sourceDictionary["person"] as AnyObject?) {
                case let .success(value): _result.person = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [PrivilegeGet].self, source: sourceDictionary["privileges"] as AnyObject?) {
                case let .success(value): _result.privileges = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [RoleGet].self, source: sourceDictionary["roles"] as AnyObject?) {
                case let .success(value): _result.roles = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [RoleGet].self, source: sourceDictionary["allRoles"] as AnyObject?) {
                case let .success(value): _result.allRoles = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Any].self, source: sourceDictionary["proficientLocales"] as AnyObject?) {
                case let .success(value): _result.proficientLocales = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["secretQuestion"] as AnyObject?) {
                case let .success(value): _result.secretQuestion = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UserGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [UserGetRef]
        Decoders.addDecoder(clazz: [UserGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UserGetRef]> in
            return Decoders.decode(clazz: [UserGetRef].self, source: source)
        }

        // Decoder for UserGetRef
        Decoders.addDecoder(clazz: UserGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? UserGetRef() : instance as! UserGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UserGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [UserUpdate]
        Decoders.addDecoder(clazz: [UserUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UserUpdate]> in
            return Decoders.decode(clazz: [UserUpdate].self, source: source)
        }

        // Decoder for UserUpdate
        Decoders.addDecoder(clazz: UserUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? UserUpdate() : instance as! UserUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["username"] as AnyObject?) {
                case let .success(value): _result.username = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["password"] as AnyObject?) {
                case let .success(value): _result.password = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PersonCreate.self, source: sourceDictionary["person"] as AnyObject?) {
                case let .success(value): _result.person = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["systemId"] as AnyObject?) {
                case let .success(value): _result.systemId = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["userProperties"] as AnyObject?) {
                case let .success(value): _result.userProperties = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [RoleCreate].self, source: sourceDictionary["roles"] as AnyObject?) {
                case let .success(value): _result.roles = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [Any].self, source: sourceDictionary["proficientLocales"] as AnyObject?) {
                case let .success(value): _result.proficientLocales = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["secretQuestion"] as AnyObject?) {
                case let .success(value): _result.secretQuestion = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UserUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [VisitAttributeCreate]
        Decoders.addDecoder(clazz: [VisitAttributeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitAttributeCreate]> in
            return Decoders.decode(clazz: [VisitAttributeCreate].self, source: source)
        }

        // Decoder for VisitAttributeCreate
        Decoders.addDecoder(clazz: VisitAttributeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitAttributeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VisitAttributeCreate() : instance as! VisitAttributeCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitAttributeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [VisitAttributeCreateFull]
        Decoders.addDecoder(clazz: [VisitAttributeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitAttributeCreateFull]> in
            return Decoders.decode(clazz: [VisitAttributeCreateFull].self, source: source)
        }

        // Decoder for VisitAttributeCreateFull
        Decoders.addDecoder(clazz: VisitAttributeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitAttributeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VisitAttributeCreateFull() : instance as! VisitAttributeCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitAttributeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [VisitAttributeGet]
        Decoders.addDecoder(clazz: [VisitAttributeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitAttributeGet]> in
            return Decoders.decode(clazz: [VisitAttributeGet].self, source: source)
        }

        // Decoder for VisitAttributeGet
        Decoders.addDecoder(clazz: VisitAttributeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitAttributeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VisitAttributeGet() : instance as! VisitAttributeGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitAttributeGet", actual: "\(source)"))
            }
        }
        // Decoder for [VisitAttributeGetFull]
        Decoders.addDecoder(clazz: [VisitAttributeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitAttributeGetFull]> in
            return Decoders.decode(clazz: [VisitAttributeGetFull].self, source: source)
        }

        // Decoder for VisitAttributeGetFull
        Decoders.addDecoder(clazz: VisitAttributeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitAttributeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VisitAttributeGetFull() : instance as! VisitAttributeGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitAttributeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [VisitAttributeGetRef]
        Decoders.addDecoder(clazz: [VisitAttributeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitAttributeGetRef]> in
            return Decoders.decode(clazz: [VisitAttributeGetRef].self, source: source)
        }

        // Decoder for VisitAttributeGetRef
        Decoders.addDecoder(clazz: VisitAttributeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitAttributeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VisitAttributeGetRef() : instance as! VisitAttributeGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitAttributeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [VisitAttributeUpdate]
        Decoders.addDecoder(clazz: [VisitAttributeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitAttributeUpdate]> in
            return Decoders.decode(clazz: [VisitAttributeUpdate].self, source: source)
        }

        // Decoder for VisitAttributeUpdate
        Decoders.addDecoder(clazz: VisitAttributeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitAttributeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VisitAttributeUpdate() : instance as! VisitAttributeUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["attributeType"] as AnyObject?) {
                case let .success(value): _result.attributeType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                case let .success(value): _result.value = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitAttributeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [VisitCreate]
        Decoders.addDecoder(clazz: [VisitCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitCreate]> in
            return Decoders.decode(clazz: [VisitCreate].self, source: source)
        }

        // Decoder for VisitCreate
        Decoders.addDecoder(clazz: VisitCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VisitCreate() : instance as! VisitCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["patient"] as AnyObject?) {
                case let .success(value): _result.patient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["visitType"] as AnyObject?) {
                case let .success(value): _result.visitType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDatetime"] as AnyObject?) {
                case let .success(value): _result.startDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["indication"] as AnyObject?) {
                case let .success(value): _result.indication = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["stopDatetime"] as AnyObject?) {
                case let .success(value): _result.stopDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["encounters"] as AnyObject?) {
                case let .success(value): _result.encounters = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [VisitAttributeCreate].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitCreate", actual: "\(source)"))
            }
        }
        // Decoder for [VisitCreateFull]
        Decoders.addDecoder(clazz: [VisitCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitCreateFull]> in
            return Decoders.decode(clazz: [VisitCreateFull].self, source: source)
        }

        // Decoder for VisitCreateFull
        Decoders.addDecoder(clazz: VisitCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VisitCreateFull() : instance as! VisitCreateFull
                switch Decoders.decodeOptional(clazz: PatientCreate.self, source: sourceDictionary["patient"] as AnyObject?) {
                case let .success(value): _result.patient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: VisittypeCreate.self, source: sourceDictionary["visitType"] as AnyObject?) {
                case let .success(value): _result.visitType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDatetime"] as AnyObject?) {
                case let .success(value): _result.startDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationCreate.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptCreate.self, source: sourceDictionary["indication"] as AnyObject?) {
                case let .success(value): _result.indication = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["stopDatetime"] as AnyObject?) {
                case let .success(value): _result.stopDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [EncounterCreate].self, source: sourceDictionary["encounters"] as AnyObject?) {
                case let .success(value): _result.encounters = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [VisitAttributeCreate].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [VisitGet]
        Decoders.addDecoder(clazz: [VisitGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitGet]> in
            return Decoders.decode(clazz: [VisitGet].self, source: source)
        }

        // Decoder for VisitGet
        Decoders.addDecoder(clazz: VisitGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VisitGet() : instance as! VisitGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDatetime"] as AnyObject?) {
                case let .success(value): _result.startDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["stopDatetime"] as AnyObject?) {
                case let .success(value): _result.stopDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientGetRef.self, source: sourceDictionary["patient"] as AnyObject?) {
                case let .success(value): _result.patient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: VisittypeGetRef.self, source: sourceDictionary["visitType"] as AnyObject?) {
                case let .success(value): _result.visitType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["indication"] as AnyObject?) {
                case let .success(value): _result.indication = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationGetRef.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [EncounterGetRef].self, source: sourceDictionary["encounters"] as AnyObject?) {
                case let .success(value): _result.encounters = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitGet", actual: "\(source)"))
            }
        }
        // Decoder for [VisitGetFull]
        Decoders.addDecoder(clazz: [VisitGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitGetFull]> in
            return Decoders.decode(clazz: [VisitGetFull].self, source: source)
        }

        // Decoder for VisitGetFull
        Decoders.addDecoder(clazz: VisitGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VisitGetFull() : instance as! VisitGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDatetime"] as AnyObject?) {
                case let .success(value): _result.startDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["stopDatetime"] as AnyObject?) {
                case let .success(value): _result.stopDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["voided"] as AnyObject?) {
                case let .success(value): _result.voided = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: PatientGet.self, source: sourceDictionary["patient"] as AnyObject?) {
                case let .success(value): _result.patient = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: VisittypeGet.self, source: sourceDictionary["visitType"] as AnyObject?) {
                case let .success(value): _result.visitType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["indication"] as AnyObject?) {
                case let .success(value): _result.indication = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationGet.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [EncounterGet].self, source: sourceDictionary["encounters"] as AnyObject?) {
                case let .success(value): _result.encounters = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [VisitGetRef]
        Decoders.addDecoder(clazz: [VisitGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitGetRef]> in
            return Decoders.decode(clazz: [VisitGetRef].self, source: source)
        }

        // Decoder for VisitGetRef
        Decoders.addDecoder(clazz: VisitGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VisitGetRef() : instance as! VisitGetRef
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [VisitUpdate]
        Decoders.addDecoder(clazz: [VisitUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitUpdate]> in
            return Decoders.decode(clazz: [VisitUpdate].self, source: source)
        }

        // Decoder for VisitUpdate
        Decoders.addDecoder(clazz: VisitUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VisitUpdate() : instance as! VisitUpdate
                switch Decoders.decodeOptional(clazz: VisittypeCreate.self, source: sourceDictionary["visitType"] as AnyObject?) {
                case let .success(value): _result.visitType = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["startDatetime"] as AnyObject?) {
                case let .success(value): _result.startDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: LocationCreate.self, source: sourceDictionary["location"] as AnyObject?) {
                case let .success(value): _result.location = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptCreate.self, source: sourceDictionary["indication"] as AnyObject?) {
                case let .success(value): _result.indication = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["stopDatetime"] as AnyObject?) {
                case let .success(value): _result.stopDatetime = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [EncounterCreate].self, source: sourceDictionary["encounters"] as AnyObject?) {
                case let .success(value): _result.encounters = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["attributes"] as AnyObject?) {
                case let .success(value): _result.attributes = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [VisitattributetypeCreate]
        Decoders.addDecoder(clazz: [VisitattributetypeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitattributetypeCreate]> in
            return Decoders.decode(clazz: [VisitattributetypeCreate].self, source: source)
        }

        // Decoder for VisitattributetypeCreate
        Decoders.addDecoder(clazz: VisitattributetypeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitattributetypeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VisitattributetypeCreate() : instance as! VisitattributetypeCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitattributetypeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [VisitattributetypeCreateFull]
        Decoders.addDecoder(clazz: [VisitattributetypeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitattributetypeCreateFull]> in
            return Decoders.decode(clazz: [VisitattributetypeCreateFull].self, source: source)
        }

        // Decoder for VisitattributetypeCreateFull
        Decoders.addDecoder(clazz: VisitattributetypeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitattributetypeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VisitattributetypeCreateFull() : instance as! VisitattributetypeCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitattributetypeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [VisitattributetypeGet]
        Decoders.addDecoder(clazz: [VisitattributetypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitattributetypeGet]> in
            return Decoders.decode(clazz: [VisitattributetypeGet].self, source: source)
        }

        // Decoder for VisitattributetypeGet
        Decoders.addDecoder(clazz: VisitattributetypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitattributetypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VisitattributetypeGet() : instance as! VisitattributetypeGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitattributetypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [VisitattributetypeGetFull]
        Decoders.addDecoder(clazz: [VisitattributetypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitattributetypeGetFull]> in
            return Decoders.decode(clazz: [VisitattributetypeGetFull].self, source: source)
        }

        // Decoder for VisitattributetypeGetFull
        Decoders.addDecoder(clazz: VisitattributetypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitattributetypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VisitattributetypeGetFull() : instance as! VisitattributetypeGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitattributetypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [VisitattributetypeGetRef]
        Decoders.addDecoder(clazz: [VisitattributetypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitattributetypeGetRef]> in
            return Decoders.decode(clazz: [VisitattributetypeGetRef].self, source: source)
        }

        // Decoder for VisitattributetypeGetRef
        Decoders.addDecoder(clazz: VisitattributetypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitattributetypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VisitattributetypeGetRef() : instance as! VisitattributetypeGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitattributetypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [VisitattributetypeUpdate]
        Decoders.addDecoder(clazz: [VisitattributetypeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisitattributetypeUpdate]> in
            return Decoders.decode(clazz: [VisitattributetypeUpdate].self, source: source)
        }

        // Decoder for VisitattributetypeUpdate
        Decoders.addDecoder(clazz: VisitattributetypeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisitattributetypeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VisitattributetypeUpdate() : instance as! VisitattributetypeUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeClassname"] as AnyObject?) {
                case let .success(value): _result.datatypeClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minOccurs"] as AnyObject?) {
                case let .success(value): _result.minOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["maxOccurs"] as AnyObject?) {
                case let .success(value): _result.maxOccurs = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["datatypeConfig"] as AnyObject?) {
                case let .success(value): _result.datatypeConfig = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferredHandlerClassname"] as AnyObject?) {
                case let .success(value): _result.preferredHandlerClassname = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["handlerConfig"] as AnyObject?) {
                case let .success(value): _result.handlerConfig = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisitattributetypeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [VisittypeCreate]
        Decoders.addDecoder(clazz: [VisittypeCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisittypeCreate]> in
            return Decoders.decode(clazz: [VisittypeCreate].self, source: source)
        }

        // Decoder for VisittypeCreate
        Decoders.addDecoder(clazz: VisittypeCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisittypeCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VisittypeCreate() : instance as! VisittypeCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisittypeCreate", actual: "\(source)"))
            }
        }
        // Decoder for [VisittypeCreateFull]
        Decoders.addDecoder(clazz: [VisittypeCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisittypeCreateFull]> in
            return Decoders.decode(clazz: [VisittypeCreateFull].self, source: source)
        }

        // Decoder for VisittypeCreateFull
        Decoders.addDecoder(clazz: VisittypeCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisittypeCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VisittypeCreateFull() : instance as! VisittypeCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisittypeCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [VisittypeGet]
        Decoders.addDecoder(clazz: [VisittypeGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisittypeGet]> in
            return Decoders.decode(clazz: [VisittypeGet].self, source: source)
        }

        // Decoder for VisittypeGet
        Decoders.addDecoder(clazz: VisittypeGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisittypeGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VisittypeGet() : instance as! VisittypeGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisittypeGet", actual: "\(source)"))
            }
        }
        // Decoder for [VisittypeGetFull]
        Decoders.addDecoder(clazz: [VisittypeGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisittypeGetFull]> in
            return Decoders.decode(clazz: [VisittypeGetFull].self, source: source)
        }

        // Decoder for VisittypeGetFull
        Decoders.addDecoder(clazz: VisittypeGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisittypeGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VisittypeGetFull() : instance as! VisittypeGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisittypeGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [VisittypeGetRef]
        Decoders.addDecoder(clazz: [VisittypeGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisittypeGetRef]> in
            return Decoders.decode(clazz: [VisittypeGetRef].self, source: source)
        }

        // Decoder for VisittypeGetRef
        Decoders.addDecoder(clazz: VisittypeGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisittypeGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VisittypeGetRef() : instance as! VisittypeGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisittypeGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [VisittypeUpdate]
        Decoders.addDecoder(clazz: [VisittypeUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VisittypeUpdate]> in
            return Decoders.decode(clazz: [VisittypeUpdate].self, source: source)
        }

        // Decoder for VisittypeUpdate
        Decoders.addDecoder(clazz: VisittypeUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VisittypeUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VisittypeUpdate() : instance as! VisittypeUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VisittypeUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [WorkflowCreate]
        Decoders.addDecoder(clazz: [WorkflowCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[WorkflowCreate]> in
            return Decoders.decode(clazz: [WorkflowCreate].self, source: source)
        }

        // Decoder for WorkflowCreate
        Decoders.addDecoder(clazz: WorkflowCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<WorkflowCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? WorkflowCreate() : instance as! WorkflowCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "WorkflowCreate", actual: "\(source)"))
            }
        }
        // Decoder for [WorkflowCreateFull]
        Decoders.addDecoder(clazz: [WorkflowCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[WorkflowCreateFull]> in
            return Decoders.decode(clazz: [WorkflowCreateFull].self, source: source)
        }

        // Decoder for WorkflowCreateFull
        Decoders.addDecoder(clazz: WorkflowCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<WorkflowCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? WorkflowCreateFull() : instance as! WorkflowCreateFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "WorkflowCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [WorkflowGet]
        Decoders.addDecoder(clazz: [WorkflowGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[WorkflowGet]> in
            return Decoders.decode(clazz: [WorkflowGet].self, source: source)
        }

        // Decoder for WorkflowGet
        Decoders.addDecoder(clazz: WorkflowGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<WorkflowGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? WorkflowGet() : instance as! WorkflowGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [WorkflowStateGetRef].self, source: sourceDictionary["states"] as AnyObject?) {
                case let .success(value): _result.states = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "WorkflowGet", actual: "\(source)"))
            }
        }
        // Decoder for [WorkflowGetFull]
        Decoders.addDecoder(clazz: [WorkflowGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[WorkflowGetFull]> in
            return Decoders.decode(clazz: [WorkflowGetFull].self, source: source)
        }

        // Decoder for WorkflowGetFull
        Decoders.addDecoder(clazz: WorkflowGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<WorkflowGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? WorkflowGetFull() : instance as! WorkflowGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [WorkflowStateGet].self, source: sourceDictionary["states"] as AnyObject?) {
                case let .success(value): _result.states = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "WorkflowGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [WorkflowGetRef]
        Decoders.addDecoder(clazz: [WorkflowGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[WorkflowGetRef]> in
            return Decoders.decode(clazz: [WorkflowGetRef].self, source: source)
        }

        // Decoder for WorkflowGetRef
        Decoders.addDecoder(clazz: WorkflowGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<WorkflowGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? WorkflowGetRef() : instance as! WorkflowGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display"] as AnyObject?) {
                case let .success(value): _result.display = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: [WorkflowStateGet].self, source: sourceDictionary["states"] as AnyObject?) {
                case let .success(value): _result.states = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "WorkflowGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [WorkflowStateCreate]
        Decoders.addDecoder(clazz: [WorkflowStateCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[WorkflowStateCreate]> in
            return Decoders.decode(clazz: [WorkflowStateCreate].self, source: source)
        }

        // Decoder for WorkflowStateCreate
        Decoders.addDecoder(clazz: WorkflowStateCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<WorkflowStateCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? WorkflowStateCreate() : instance as! WorkflowStateCreate
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "WorkflowStateCreate", actual: "\(source)"))
            }
        }
        // Decoder for [WorkflowStateCreateFull]
        Decoders.addDecoder(clazz: [WorkflowStateCreateFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[WorkflowStateCreateFull]> in
            return Decoders.decode(clazz: [WorkflowStateCreateFull].self, source: source)
        }

        // Decoder for WorkflowStateCreateFull
        Decoders.addDecoder(clazz: WorkflowStateCreateFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<WorkflowStateCreateFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? WorkflowStateCreateFull() : instance as! WorkflowStateCreateFull
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "WorkflowStateCreateFull", actual: "\(source)"))
            }
        }
        // Decoder for [WorkflowStateGet]
        Decoders.addDecoder(clazz: [WorkflowStateGet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[WorkflowStateGet]> in
            return Decoders.decode(clazz: [WorkflowStateGet].self, source: source)
        }

        // Decoder for WorkflowStateGet
        Decoders.addDecoder(clazz: WorkflowStateGet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<WorkflowStateGet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? WorkflowStateGet() : instance as! WorkflowStateGet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "WorkflowStateGet", actual: "\(source)"))
            }
        }
        // Decoder for [WorkflowStateGetFull]
        Decoders.addDecoder(clazz: [WorkflowStateGetFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[WorkflowStateGetFull]> in
            return Decoders.decode(clazz: [WorkflowStateGetFull].self, source: source)
        }

        // Decoder for WorkflowStateGetFull
        Decoders.addDecoder(clazz: WorkflowStateGetFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<WorkflowStateGetFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? WorkflowStateGetFull() : instance as! WorkflowStateGetFull
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["auditInfo"] as AnyObject?) {
                case let .success(value): _result.auditInfo = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGet.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "WorkflowStateGetFull", actual: "\(source)"))
            }
        }
        // Decoder for [WorkflowStateGetRef]
        Decoders.addDecoder(clazz: [WorkflowStateGetRef].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[WorkflowStateGetRef]> in
            return Decoders.decode(clazz: [WorkflowStateGetRef].self, source: source)
        }

        // Decoder for WorkflowStateGetRef
        Decoders.addDecoder(clazz: WorkflowStateGetRef.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<WorkflowStateGetRef> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? WorkflowStateGetRef() : instance as! WorkflowStateGetRef
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["retired"] as AnyObject?) {
                case let .success(value): _result.retired = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: ConceptGetRef.self, source: sourceDictionary["concept"] as AnyObject?) {
                case let .success(value): _result.concept = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "WorkflowStateGetRef", actual: "\(source)"))
            }
        }
        // Decoder for [WorkflowUpdate]
        Decoders.addDecoder(clazz: [WorkflowUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[WorkflowUpdate]> in
            return Decoders.decode(clazz: [WorkflowUpdate].self, source: source)
        }

        // Decoder for WorkflowUpdate
        Decoders.addDecoder(clazz: WorkflowUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<WorkflowUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? WorkflowUpdate() : instance as! WorkflowUpdate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                case let .success(value): _result.name = value
                case let .failure(error): break
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                case let .success(value): _result.description = value
                case let .failure(error): break
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "WorkflowUpdate", actual: "\(source)"))
            }
        }
    }()

    static fileprivate func initialize() {
        _ = Decoders.__once
    }
}
